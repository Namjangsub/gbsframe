<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
  <title>실행계획 > 간트 팝업 (GBS Framework)</title>

  <!-- 공통 CSS -->
  <link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/static/bootstrap/css/bootstrap-theme.min.css">
  <link rel="stylesheet" href="/static/bootstrap/css/dashboard.css">
  <link rel="stylesheet" href="/static/bootstrap/css/bootstrap-datepicker.css">
  <link rel="stylesheet" href="/static/fontawesome/css/all.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5grid.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5mask.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5modal.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5toast.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5menu.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5calendar.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5picker.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5select.css">
  <link rel="stylesheet" href="/static/css/jstree/style.min.css">
  <link rel="stylesheet" href="/static/css/ax5/ax5combobox.css">
  <link rel="stylesheet" href="/static/css/gnb.css">
  <link rel="stylesheet" href="/static/css/main.css">
  <link rel="stylesheet" href="/static/css/sub.css">
  <link rel="stylesheet" href="/static/css/common.css">
  <link rel="stylesheet" href="/static/css/jquery-ui.css">

  <!-- 공통 스크립트 -->
  <script type="text/javascript" src="/static/js/jquery-latest.min.js"></script>
  <script src="/static/js/jquery-ui.min.js"></script>
  <script type="text/javascript" src="/static/js/jquery.serializeObject.js"></script>
  <script type="text/javascript" src="/static/bootstrap/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="/static/bootstrap/js/bootstrap-datepicker.min.js"></script>
  <script type="text/javascript" src="/static/bootstrap/js/bootstrap-datepicker.ko.min.js"></script>
  <script type="text/javascript" src="/static/js/moment/moment-with-locales.js"></script>
  <script type="text/javascript" src="/static/js/jstree/jstree.min.js"></script>
  <script type="text/javascript" src="/static/js/ax5/ax5core.min.js"></script>
  <script type="text/javascript" src="/static/js/ax5/ax5grid.min.js"></script>
  <script type="text/javascript" src="/static/js/ax5/ax5mask.min.js"></script>
  <script type="text/javascript" src="/static/js/ax5/ax5modal.min.js"></script>
  <script type="text/javascript" src="/static/js/ax5/ax5toast.min.js"></script>
  <script src="/static/js/ax5/ax5calendar.min.js"></script>
  <script src="/static/js/ax5/ax5picker.min.js"></script>
  <script src="/static/js/ax5/ax5menu.min.js"></script>
  <script src="/static/js/ax5/ax5formatter.min.js"></script>
  <script src="/static/js/ax5/ax5combobox.min.js"></script>
  <script src="/static/js/ax5/ax5select.min.js"></script>
  <script src="/static/js/exceljs.min.js"></script>
  <script type="text/javascript" src="/static/js/global.js"></script>
  <script type="text/javascript" src="/static/js/fileTree.js"></script>
  <script type="text/javascript" src="/static/js/workingDayCalc.js"></script>
  <script type="text/javascript" src="/static/js/korean-lunar-calendar.min.js"></script>
  <script src="/static/js/jquery.blockUI.js"></script>
  <script src="/static/bootstrap/js/bootstrap-multiselect.min.js"></script>
  <script src="/static/js/manualPopup.js"></script>
  <script>
      const STS_CODE = {};
      const STS_NAME = {};
			var paramObj = {"codeKind" : 'WBSPLANSTS'};
			postAjaxSync("/admin/cm/cm05/selectChildCodeList", paramObj, null, function(data){
				var childCodeList = data.childCodeList;
				$.each(childCodeList, function(index, obj){
					STS_CODE[obj.codeNm] = obj.codeId;
					STS_NAME[obj.codeId] = obj.codeNm;
				});
			});

  </script>
  <link rel="stylesheet" href="/static/css/user/wb/wb06/WB0604M01.css">

</head>
<body>
<div id="head_area"></div>
<div id="top_area"></div>
<div id="main_area">
    <input type="hidden" id="pgmId"  name="pgmId" value="WB0604M01">
    <input type="hidden" id="coCd"  name="coCd">
<div class="app">
  <!-- LEFT: MindMap -->
  <section class="card">
    <div class="hd">
      <div class="search_form">
<input type="text" id="salesCd_S" name="salesCd_S" data-search="salesCd" onkeyup="event.keyCode==13 ? searchData() :''">
        <a onclick="wbsSalesCodeSearch($('#salesCd_S').val());"><i class="i_search_w"></i></a>
      </div>
      <div class="toolbar">
        <button class="btn" id="btnAddTask" title="하위 TASK 추가">+</button>
        <button class="btn" id="btnRemoveTask" title="선택 TASK 삭제">-</button>
        <button class="btn" id="btnTaskTemplate">템플릿</button>
      </div>
    </div>
    <div class="bd">
      <div class="mini">
        - 간트 1행에 계획(위) + 실적(아래) 동시 표시<br/>
        - 드래그 편집은 상단 토글(계획/실적)로 제어, 드롭 후 자동저장<br/>
        - 계획(PLAN)은 의존성 위반시 후 경고(허용), 실적(ACT)은 기본 경고 없음
      </div>
      <div class="sep"></div>
      <div id="tree" class="tree"></div>
    </div>
  </section>

  <!-- CENTER: Gantt -->
  <section class="card">
    <div class="hd">
      <div>간트</div>
      <div class="toolbar">
        <button class="btn" id="btnRecalc">재조회</button>
        <button class="btn primary" id="btnToday">오늘</button>
        <button class="btn" id="btnEditPlan">편집: 계획</button>
        <button class="btn" id="btnEditAct">편집: 실적</button>
        <span id="editModeInfo" style="font-size:12px; color:var(--primary); font-weight:700;"></span>
        <label style="font-size:12px; color:var(--muted); display:flex; align-items:center; gap:4px; margin-left:8px;">
          Zoom:
          <input id="zoomSlider" type="range" min="2" max="20" value="12" style="width:80px;"/>
          <span id="zoomVal">12</span>px 
        </label>
        <span id="rangeInfo" style="margin-left:auto;"></span>
      </div>
    </div>
    <div class="bd">
      <div class="ganttWrap" id="ganttWrap">
        <div class="gantt" id="gantt"></div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Detail -->
  <section class="card">
    <div class="hd">
      <div>상세</div>
      <div class="toolbar">
        <button class="btn" id="btnApproveAttach">결재/첨부</button>
        <button class="btn" id="btnAddIssue">문제 등록</button>
      </div>
    </div>
    <div class="bd" id="detail"></div>
  </section>
</div>
</div>
<div class="tooltip" id="tip"></div>


    <div class="mf">
    </div>
  </div>
</div>
<div class="toastWrap" id="toastWrap"></div>
<script>
/**
 * =========================================================
 * 정책(확정/반영)
 * - PLAN: 드래그 편집 시 start/end 휴일이면 nextWorkingDay, 의존성 위반은 저장 허용 + DIRECT/연쇄 경고
 * - ACT : 드래그 편집 시 start/end 휴일이면 nextWorkingDay, 기본은 의존성 경고 없음
 * - Resize-Start: end 고정 / Resize-End: start 고정
 * - Drop 후 Confirm: 저장/취소
 * =========================================================
 */

const WARN = { NONE:"NONE", DIRECT:"DIRECT", UPSTREAM:"UPSTREAM" };

/** ---------- Mock Data ---------- */
const MOCK = {
  docId: "DOC01",
  holidays: new Set(["2026-02-16"]), // 샘플 공휴일
  tasks: [
    { id:"T1001", parentId:null, title:"프로젝트 준비", planDurationWd:5, planStartAt:"2026-02-02", planEndAt:"2026-03-01" },
    { id:"T1002", parentId:"T1001", title:"요구사항 정리", planDurationWd:4, planStartAt:"2026-02-09", planEndAt:"2026-02-12", actStartAt:"2026-02-04", actEndAt:"2026-02-06", actProgress:60, status:"DOING", progress:40, assignees:["U01","U02"] },
    { id:"T1003", parentId:"T1001", title:"설계(아키텍처)", planDurationWd:6, planStartAt:"2026-02-13", planEndAt:"2026-02-20", actStartAt:null, actEndAt:null, actProgress:0, status:"TODO", progress:0, assignees:["U03"] },
    { id:"T2001", parentId:null, title:"구현", planDurationWd:8, planStartAt:"2026-02-23", planEndAt:"2026-03-04", actStartAt:null, actEndAt:null, actProgress:0, status:"TODO", progress:0, assignees:["U02"] },
    { id:"T2002", parentId:"T2001", title:"프런트(Mind/Gantt)", planDurationWd:7, planStartAt:"2026-02-23", planEndAt:"2026-03-03", actStartAt:null, actEndAt:null, actProgress:0, status:"TODO", progress:0, assignees:["U02"] },
    { id:"T2003", parentId:"T2001", title:"백엔드(API/Engine)", planDurationWd:7, planStartAt:"2026-03-04", planEndAt:"2026-03-12", actStartAt:null, actEndAt:null, actProgress:0, status:"TODO", progress:0, assignees:["U01"] },
    { id:"T3001", parentId:null, title:"검증/배포", planDurationWd:5, planStartAt:"2026-03-05", planEndAt:"2026-03-11", actStartAt:null, actEndAt:null, actProgress:0, status:"TODO", progress:0, assignees:["U03"] }
  ],
  deps: [ //선행, 후행 작업 정의 내역임
    { id:"D01", fromId:"T1001", toId:"T1002", type:"FS", lagWd:0 },
    { id:"D02", fromId:"T1002", toId:"T1003", type:"FS", lagWd:0 },
    { id:"D03", fromId:"T1003", toId:"T2001", type:"FS", lagWd:1 },
    { id:"D04", fromId:"T2001", toId:"T3001", type:"FS", lagWd:0 },
    { id:"D05", fromId:"T2002", toId:"T2003", type:"FS", lagWd:0 }
  ],
  issues: [
    { issueId:"ISS-001", taskId:"T1003", severity:"HIGH", title:"설계 검토 지연", status:"OPEN", occurredAt:"2026-02-15", owner:"U03" },
    { issueId:"ISS-002", taskId:"T2002", severity:"MEDIUM", title:"UI 이벤트 충돌", status:"OPEN", occurredAt:"2026-02-25", owner:"U02" }
  ]
};

/** ---------- State ---------- */
const STATE = {
  docId: MOCK.docId,
  tasks: new Map(MOCK.tasks.map(t => [t.id, {...t}])),
  deps: [...MOCK.deps.map(d => ({...d}))],
  issues: [...MOCK.issues.map(i => ({...i}))],
  holidays: MOCK.holidays,
  selectedId: "T1001",
  view: { baseDate: "2026-02-01", days: 28 },
  pendingChange: null,
  editMode: "PLAN" // PLAN | ACT
};

let prevFocus = { id: null, start: 0, end: 0 };
let UNDO_STACK = [];

function pushUndoSnapshot() {
  const snap = new Map();
  for(const [id, t] of STATE.tasks.entries()){
    snap.set(id, JSON.parse(JSON.stringify(t)));
  }
  UNDO_STACK.push(snap);
  if(UNDO_STACK.length > 50) UNDO_STACK.shift();
}

function popAndRestore() {
  if (UNDO_STACK.length === 0) {
    setToast("되돌릴 작업 내역이 없습니다.", {type:"warn", autoHideMs:1500});
    return;
  }
  const snap = UNDO_STACK.pop();
  restoreTasks(snap);
  setToast("실행 취소(Undo) 완료", {type:"ok", autoHideMs:1500});
}

/** ---------- Utilities: date helpers (YYYY-MM-DD) ---------- */
function pad2(n){ return String(n).padStart(2,"0"); }
function toDate(s){ if(!s) return null; const [y,m,d]=s.split("-").map(Number); return new Date(y,m-1,d); }
function toYmd(dt){ if(!dt) return null; return `${dt.getFullYear()}-${pad2(dt.getMonth()+1)}-${pad2(dt.getDate())}`; }
function addDays(ymd, n){ if(!ymd) return null; const dt=toDate(ymd); dt.setDate(dt.getDate()+n); return toYmd(dt); }
function diffDays(a,b){ if(!a || !b) return 0; return Math.round((toDate(b)-toDate(a))/(1000*60*60*24)); }
function dayOfWeek(ymd){ if(!ymd) return -1; return toDate(ymd).getDay(); } // 0 Sun .. 6 Sat
function isWeekend(ymd){ const w=dayOfWeek(ymd); return w===0||w===6; }
function isHoliday(ymd){ return STATE.holidays.has(ymd); }
function isWorkingDay(ymd){ return !isWeekend(ymd) && !isHoliday(ymd); }
function nextWorkingDay(ymd){
  let d=ymd, guard=0;
  while(d && !isWorkingDay(d)){
    d = addDays(d,1);
    if(++guard>500) throw new Error("nextWorkingDay guard exceeded");
  }
  return d;
}
function addWorkingDays(startYmd, wd){
  const n = Math.round(wd);
  if(n === 0) return startYmd;
  const step = n > 0 ? 1 : -1;
  let d = startYmd, remaining = Math.abs(n), guard = 0;
  while(remaining > 0){
    d = addDays(d, step);
    if(isWorkingDay(d)) remaining--;
    if(++guard > 5000) throw new Error("addWorkingDays guard exceeded");
  }
  return d;
}
function diffWorkingDaysInclusive(startYmd, endYmd){
  if(!startYmd || !endYmd) return 0;
  if(diffDays(startYmd, endYmd) < 0) return 0;
  let cnt=0, d=startYmd, guard=0;
  while(true){
    if(isWorkingDay(d)) cnt++;
    if(d===endYmd) break;
    d = addDays(d,1);
    if(++guard>6000) throw new Error("diffWorkingDaysInclusive guard exceeded");
  }
  return cnt;
}
function escapeHtml(s){
  return String(s||"")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function getDayW(){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue("--dayW")) || 13; }

/** ---------- Graph helpers ---------- */
function predecessorsOf(taskId){
  return STATE.deps.filter(d=>d.toId===taskId).map(d=>({fromId:d.fromId, lagWd:d.lagWd}));
}
function successorsOf(taskId){
  return STATE.deps.filter(d=>d.fromId===taskId).map(d=>({toId:d.toId, lagWd:d.lagWd}));
}
function topoSortTasks(){
  const ids=[...STATE.tasks.keys()];
  const indeg=new Map(ids.map(id=>[id,0]));
  for(const d of STATE.deps) indeg.set(d.toId,(indeg.get(d.toId)||0)+1);
  const q=[];
  for(const id of ids) if((indeg.get(id)||0)===0) q.push(id);
  const out=[];
  while(q.length){
    const id=q.shift();
    out.push(id);
    for(const s of successorsOf(id)){
      const v=s.toId;
      indeg.set(v, indeg.get(v)-1);
      if(indeg.get(v)===0) q.push(v);
    }
  }
  return (out.length===ids.length) ? out : ids;
}
function collectDownstreamTaskIds(seedIds){
  const visited = new Set();
  const q = [...seedIds];
  while(q.length){
    const cur = q.shift();
    for(const s of successorsOf(cur)){
      const toId = s.toId;
      if(!visited.has(toId)){
        visited.add(toId);
        q.push(toId);
      }
    }
  }
  return visited;
}

/** ---------- Schedule Engine (PLAN) ---------- */
function normalizeTaskFields(){
  // 기존(startAt/durationWd) 데이터가 들어오더라도 PLAN 필드로 흡수할 수 있게 방어(확장 대비)
  for(const t of STATE.tasks.values()){
    if(t.planDurationWd==null) t.planDurationWd = Math.max(1, Number(t.durationWd||1));
    if(!t.planStartAt && t.startAt) t.planStartAt = t.startAt;
    // ACT 필드 방어
    if(t.actProgress==null) t.actProgress = 0;
  }
}

function recalcPlanAll(){
  normalizeTaskFields();

  // 1. 개별 태스크 정규화 및 종료일 산정 (부모 요약 제외)
  for(const t of STATE.tasks.values()){
    if(t.planStartAt) t.planStartAt = nextWorkingDay(t.planStartAt);
    const dur = Math.max(1, Number(t.planDurationWd||1));
    t.planEndAt = addWorkingDays(t.planStartAt || STATE.view.baseDate, dur - 1);
    
    // 경고 초기화
    t.planWarnYn = "N";
    t.planWarnType = WARN.NONE;
  }

  // 2. 범위 기반 위반 체크 (Constraint Check)
  for(const t of STATE.tasks.values()){
    // (1) PLAN 위반: 부모 범위를 벗어나는지 체크
    if(t.parentId){
      const parent = STATE.tasks.get(t.parentId);
      if(parent && parent.planStartAt && parent.planEndAt){
        const startViolation = diffDays(t.planStartAt, parent.planStartAt) > 0; // t.start < parent.start
        const endViolation = diffDays(parent.planEndAt, t.planEndAt) > 0;       // t.end > parent.end
        if(startViolation || endViolation){
          t.planWarnYn = "Y";
          t.planWarnType = WARN.DIRECT; 
        }
      }
    }

    // (2) ACT 위반: 자신의 계획 범위를 벗어나는지 체크
    if(t.actStartAt && t.actEndAt && t.planStartAt && t.planEndAt){
      const actStartViol = diffDays(t.actStartAt, t.planStartAt) > 0; // actStart < planStart
      const actEndViol = diffDays(t.planEndAt, t.actEndAt) > 0;       // actEnd > planEnd
      t.actWarnYn = (actStartViol || actEndViol) ? "Y" : "N";
    } else {
      t.actWarnYn = "N";
    }
  }

  refreshSummariesOnly();
}

/** 실적 기간을 기반으로 진척율 자동 계산 (fProg 표시용) */
function recalcAutoProgress(t) {
  if (!t.actStartAt || !t.actEndAt || !t.planDurationWd) return 0;
  
  const actDur = diffWorkingDaysInclusive(t.actStartAt, t.actEndAt);
  const planDur = t.planDurationWd;
  
  // 계획 대비 실적 기간 비율 계산 (100% 초과 시 100%로 고정)
  let autoProg = Math.floor((actDur / planDur) * 100);
  autoProg = Math.min(100, Math.max(0, autoProg));

  // t.actProgress 및 t.status 변경 등 사이드 바이 사이드 제거 (User Req)
  
  return autoProg;
}

function refreshSummariesOnly(){
  const today = toYmd(new Date());
  
  // 1. 이슈 및 OVERDUE 기본 집계
  for(const t of STATE.tasks.values()){
    const allIss = STATE.issues.filter(i => i.taskId===t.id);
    t.issueOpenCnt = allIss.length; // 발생 (전체 건수)
    t.issueHighCnt = allIss.filter(i => i.status !== "완료").length; // 미완 (COMPLETED가 아닌 건수)
    
    // 이 시점에 planOverdueYn 등을 날짜 기반으로 다시 갱신
    if (t.planEndAt) {
      t.planOverdueYn = (diffDays(today, t.planEndAt) < 0) ? "Y" : "N";
    } else {
      t.planOverdueYn = "N";
    }
  }

  // 2. 부모 노드 실적(ACT) 자동 요약 (Bottom-up approach)
  for(const t of STATE.tasks.values()){
    if(t.parentId === null){
      const children = Array.from(STATE.tasks.values()).filter(c => c.parentId === t.id);
      if(children.length > 0){
        let minS = null, maxE = null, totalProg = 0, countProg = 0;
        children.forEach(c => {
          if(c.actStartAt){
            if(!minS || diffDays(minS, c.actStartAt) < 0) minS = c.actStartAt;
          }
          if(c.actEndAt){
            if(!maxE || diffDays(maxE, c.actEndAt) > 0) maxE = c.actEndAt;
          }
          totalProg += (c.actProgress || 0);
          countProg++;
        });
        t.actStartAt = minS;
        t.actEndAt = maxE;
        t.actProgress = countProg > 0 ? Math.round(totalProg / countProg) : 0;
      }
    }
    
    // 3. 모든 노드(부모 포함)의 상태(status)와 상태코드(wbsPlanStsCodeId)를 날짜/진척율 기반으로 재계산
    // 실시간 드래그나 요약 이후에도 "지연" 상태를 정확히 유지하기 위함
    const ap = Number(t.actProgress || 0);
    const pe = t.planEndAt;
    const ae = (t.actStartAt && !t.actEndAt) ? today : t.actEndAt;

    // 추가: WBSCODE 타입인데 하위 TASK가 없으면 지연 상태로 강제 전환
    const isWbsCode = (t.wbsPlanCodeKind === 'WBSCODE');
    const hasChildren = Array.from(STATE.tasks.values()).some(c => c.parentId === t.id);
    const isDelayed = (pe && ae && ae > pe); // 계획 종료일보다 실적 종료일이 늦은 경우

    if (isWbsCode && !hasChildren) {
      t.wbsPlanStsCodeId = "WBSPLANSTS30";
    } else if (ap === 100) {
      t.wbsPlanStsCodeId = isDelayed ? "WBSPLANSTS40" : "WBSPLANSTS50"; // 지연 여부에 따라 상태 구분
    } else if (isDelayed || (pe && pe < today)) {
      t.wbsPlanStsCodeId = "WBSPLANSTS30";
    } else if (t.revisedFinishDt) {
      t.wbsPlanStsCodeId = "WBSPLANSTS30";
    } else if (ap > 0) {
      t.wbsPlanStsCodeId = "WBSPLANSTS20";
    } else {
      // 기존에 서버에서 받은 값이 있으면 활용하되, 없으면 미진행
      if (!t.wbsPlanStsCodeId || t.wbsPlanStsCodeId === "TODO") {
         t.wbsPlanStsCodeId = "WBSPLANSTS10";
      }
    }
    t.status = STS_NAME[t.wbsPlanStsCodeId] || "TODO";
  }
}

function warnLabelPlan(t){
  if(!t || t.planWarnYn !== "Y") return "";
  return "상위 단계의 기간을 벗어남";
}

/** ---------- UI Render ---------- */
const elTree = $("#tree");
const elGantt = $("#gantt");
const elDetail = $("#detail");
const elTip = $("#tip");
const elRangeInfo = $("#rangeInfo");
const elEditModeInfo = $("#editModeInfo");

function showToast(msg, type="ok"){
  setToast(msg, {type, autoHideMs: 2600});
}

function refreshEditModeUI(){
  $("#btnEditPlan").toggleClass("primary", STATE.editMode==="PLAN");
  $("#btnEditAct").toggleClass("primary", STATE.editMode==="ACT");
  elEditModeInfo.text((STATE.editMode==="PLAN") ? "계획 바 드래그 편집" : "실적 바 드래그 편집");
}

function getTaskListInTreeOrder(){
  const byParent = new Map();
  for(const t of STATE.tasks.values()){
    const p = t.parentId || "__ROOT__";
    if(!byParent.has(p)) byParent.set(p, []);
    byParent.get(p).push(t);
  }
  for(const arr of byParent.values()){
    arr.sort((a,b)=> (a.sortNo||0)-(b.sortNo||0));
  }
  const out=[];
  function dfs(pid, depth){
    const kids=byParent.get(pid)||[];
    for(const k of kids){
      out.push({t:k, depth});
      if(k.collapsedYn!=="Y") dfs(k.id, depth+1);
    }
  }
  dfs("__ROOT__",0);
  return out;
}

/** ---------- Data Loading ---------- */
function loadWbsData(){
  const formData = {
    coCd: $("#coCd").val() || 'GUN',
    salesCd: $("#salesCd_S").val(), 
    userId: $("#userId").val() || '',
    wbscode: $('#wbscode').val() || '',
  };

  //임시 테스트용 MOCK 데이터
  if(jwt.userId == 'js.nam') {
    formData.userId = '';
  }

    // userId 처리가 필요한 경우 별도 input(hidden 등)이나 전역변수에 저장
    if ($('#salesCd_H').length === 0) {
      $('#main_area').append(`<input type="hidden" id="salesCd_H" value="${$("#salesCd_S").val()}">`);
    } else {
      $('#salesCd_H').val($("#salesCd_S").val());
    }
  
  postAjax("/user/wb/wb26/select_wb0603p_List", formData, null, function(data) {
    const list = data && data.result;
    if (!Array.isArray(list)) {
      setToast("데이터를 불러오지 못했습니다.", {type:"err"});
      return;
    }

    STATE.tasks.clear();
    list.forEach(item => {
      // 날짜 형식 방어 (yyyymmdd -> yyyy-mm-dd)
      const toDash = (s) => (s && /^\d{8}$/.test(s)) ? `${s.substr(0,4)}-${s.substr(4,2)}-${s.substr(6,2)}` : s;
      
      const t = {
        ...item,
        id: item.id || item.wbsPlanCodeId || item.WBS_PLAN_CODE_ID,
        parentId: (item.parentId && item.parentId !== "0" && item.parentId !== "") ? item.parentId : 
                  (item.PARENT_ID && item.PARENT_ID !== "0" && item.PARENT_ID !== "") ? item.PARENT_ID : null,
        title: item.title || item.wbsPlanCodeNm || item.WBS_PLAN_CODE_NM || "Untitled",
        planStartAt: toDash(item.planStartAt || item.PLAN_START_AT || item.WBS_PLANS_DT),
        planEndAt: toDash(item.planEndAt || item.PLAN_END_AT || item.WBS_PLANE_DT),
        planDurationWd: Number(item.planDurationWd || item.PLAN_DURATION_WD || item.DAYCNT || 1),
        actStartAt: toDash(item.actStartAt || item.ACT_START_AT || item.WBS_RSLTS_S_DT),
        actEndAt: toDash(item.actEndAt || item.ACT_END_AT || item.WBS_RSLTS_E_DT),
        actProgress: Number(item.actProgress || item.ACT_PROGRESS || item.WBS_RSLTS_RATE || 0),
        progress: Number(item.actProgress || item.ACT_PROGRESS || item.WBS_RSLTS_RATE || 0),
        wbsPlanStsCodeId: item.wbsPlanStsCodeId || item.WBS_PLAN_STS_CODE_ID || "WBSPLANSTS10",
        status: item.status || "TODO",
        assignees: (item.wbsPlanMngNm || item.WBS_PLAN_MNG_NM) ? [item.wbsPlanMngNm || item.WBS_PLAN_MNG_NM] : [],
        sortNo: Number(item.seqSort || item.SEQ_SORT || 0),
        resultsCnts: item.resultsCnts || item.wbsRsltsCnts || item.WBS_RSLTS_CNTS || "",
        revisedFinishDt: toDash(item.revisedFinishDt || item.REVISED_FINISH_DT),
        
        // Original values for dirty flag comparison
        _originalActStart: toDash(item.actStartAt || item.ACT_START_AT || item.WBS_RSLTS_S_DT) || null,
        _originalActEnd: toDash(item.actEndAt || item.ACT_END_AT || item.WBS_RSLTS_E_DT) || null,
        
        // Hidden fields for Update
        fileTrgtKey: item.fileTrgtKey || item.wbsPlanCodeId, 
        seq: item.seq || 0,
        salesCd: item.salesCd || "",
        wbsPlanMngId: item.wbsPlanMngId || "",
        expectMh: item.expectMh || "0",
        wbsRsltsMh: item.wbsRsltsMh || "0",
        verUpReason: item.verUpReason || "",
        verNo: item.verNo || "",
        // 실적 고유번호 관리 (0이면 신규)
        rsltsFileTrgtKey: Number(item.rsltsFileTrgtKey || 0),
        wbsPlanCodeId: item.wbsPlanCodeId,
        wbsPlanNo: item.wbsPlanNo,
        wbsPlanCodeKind: item.wbsPlanCodeKind,
        wbsRsltsNo: item.wbsRsltsNo || item.wbsPlanCodeId // 기본값은 PlanCodeId 사용
      };
      STATE.tasks.set(t.id, t);
    });
    
    STATE.issues = (data && data.resultProblem) || [];
    refreshSummariesOnly();
    recalcPlanAll(); // This might update dates
    updateGanttRange(); 
    autoZoomToFit();
    renderAll();
    setToast("WBS 데이터 로드 완료", {type:"ok", autoHideMs:1500});
  });
}

/** 데이터 검색 (재조회) */
function searchData(){
  loadWbsData();
}


function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
function fmtPlanRange(t){
  return `${t.planStartAt||"-"} ~ ${t.planEndAt||"-"} (WD ${t.planDurationWd||"-"})`;
}
function fmtActRange(t){
  if(!t.actStartAt || !t.actEndAt) return "-";
  return `${t.actStartAt} ~ ${t.actEndAt} (진척 ${t.actProgress||0}%)`;
}

function updateGanttRange() {
  const today = toYmd(new Date());
  let minD = today, maxD = today;
  
  for (const t of STATE.tasks.values()) {
    const dArr = [t.planStartAt, t.planEndAt, t.actStartAt, t.actEndAt].filter(Boolean);
    for (const d of dArr) {
      if (diffDays(minD, d) < 0) minD = d;
      if (diffDays(maxD, d) > 0) maxD = d;
    }
  }

  const start = addDays(minD, -7);
  const end = addDays(maxD, 7);
  STATE.view.baseDate = start;
  STATE.view.days = diffDays(start, end) + 1;
}

/** 전체 타임라인이 한 화면에 보이도록 배율(Zoom) 자동 조정 */
function autoZoomToFit() {
  const wrap = $("#ganttWrap");
  if (!wrap.length || !STATE.view.days) return;

  const totalW = wrap.width();
  const taskColW = 160; // TASK 명칭 열 너비 (CSS grid-template-columns)
  const availableW = totalW - taskColW - 20; // 스크롤 여유 공간
  
  if (availableW <= 0) return;

  let targetDayW = availableW / STATE.view.days;
  
  // 배율 제한 (최소 2px ~ 최대 50px)
  targetDayW = Math.min(50, Math.max(2, targetDayW));
  
  // CSS 변수 반영
  document.documentElement.style.setProperty("--dayW", targetDayW + "px");
  
  // 슬라이더 UI 동기화
  $("#zoomSlider").val(targetDayW);
  $("#zoomVal").text(Math.round(targetDayW));
}

function renderTree(){
  const rows=getTaskListInTreeOrder();
  elTree.empty();
  for(const {t, depth} of rows){
    if(t.parentId === null) continue; // 최상위 업무(요약용)는 리스트에서 제외
    
    const card = $("<div>")
      .addClass("nodeCard")
      .attr("data-id", t.id)
      .toggleClass("sel", t.id === STATE.selectedId)
      .toggleClass("overdue", t.planOverdueYn === "Y")
      .toggleClass("warning", t.planWarnYn === "Y")
      .toggleClass("modified", (t._planDirty || t._actDirty || t._metaDirty))
      .toggleClass("delayed", t.wbsPlanStsCodeId === "WBSPLANSTS30");

    const indent = $("<div>").addClass("indent").appendTo(card);
    for(let i=0;i<depth;i++){
      $("<div>").addClass("spacer").appendTo(indent);
    }
    
    const content = $("<div>").css("flex", "1").appendTo(indent);
    const r1 = $("<div>").addClass("nodeRow1").appendTo(content);
    $("<div>").text(t.title).appendTo(r1);
    
    const badges = $("<div>").addClass("badges").appendTo(r1);
    $("<span>").addClass("badge primary").text(`${t.status||"TODO"} ${t.progress||0}%`).appendTo(badges);

    if(t.planOverdueYn==="Y") $("<span>").addClass("badge danger").text("기한경과(PLAN)").appendTo(badges);
    if(t.planWarnYn==="Y") $("<span>").addClass("badge warn").text(warnLabelPlan(t)).appendTo(badges);
    
    if ((t.issueOpenCnt || 0) > 0 || (t.issueHighCnt || 0) > 0) {
      const b = $("<span>").addClass("badge").text(`발생 ${t.issueOpenCnt || 0} / 미완 ${t.issueHighCnt || 0}`).appendTo(badges);
      if ((t.issueHighCnt || 0) > 0) b.addClass("danger");
    }

    if (t._planDirty || t._actDirty || t._metaDirty) {
      $("<span>").addClass("badge warn-pulse").html('<i class="fas fa-pen"></i> 저장필요').appendTo(badges);
    }

    const r2 = $("<div>").addClass("nodeRow2").appendTo(content);
    $("<div>").text(`PLAN: ${fmtPlanRange(t)}`).appendTo(r2);
    $("<div>").text(` ACT : ${fmtActRange(t)}`).appendTo(r2);

    card.on("click", ()=>{
      prevFocus = { id: null, start: 0, end: 0 }; // Reset focus on task change
      STATE.selectedId=t.id;
      renderAll();
      focusOnGanttTask(t.id); // 클릭 시 간트 바 중앙 이동
      const mode = STATE.editMode || "PLAN";
      setToast(`${mode} 모드: 노드 선택`, { type:"ok", autoHideMs:1200 });
    });

    elTree.append(card);
  }
}

function getTimelineDays(){
  const base=STATE.view.baseDate;
  const days=[];
  for(let i=0;i<STATE.view.days;i++) days.push(addDays(base,i));
  return days;
}

/** ---------- Tooltip ---------- */
/** ---------- Tooltip ---------- */
function showTip(x,y,task,type){
  const s = (type === "PLAN") ? task.planStartAt : task.actStartAt;
  const e = (type === "PLAN") ? task.planEndAt : task.actEndAt;
  const dur = (type === "PLAN") ? task.planDurationWd : (task.actProgress + "%");
  const label = (type === "PLAN") ? "기간Wd" : "진척률";

  elTip.html(`
    <div class="tip-title">${task.title} [${type}]</div>
    <div class="tip-row"><span class="tip-label">범위:</span><span>${s} ~ ${e}</span></div>
    <div class="tip-row"><span class="tip-label">${label}:</span><span>${dur}</span></div>
    <div class="tip-row"><span class="tip-label">상태:</span><span>${task.status}</span></div>
  `);
  
  const winW = window.innerWidth;
  const winH = window.innerHeight;
  let left = x + 15;
  let top = y + 15;
  if(left + 200 > winW) left = x - 215;
  if(top + 100 > winH) top = y - 115;

  elTip.css({ left: left + "px", top: top + "px" }).addClass("on");
}
function hideTip(){ elTip.removeClass("on"); }



/** ---------- Toast (Right Bottom) : Single + Undo/Retry + Save Status ---------- */
const elToastWrap = document.getElementById("toastWrap");
let TOAST = {
  el: null,
  hideTimer: null,
  undoTimer: null,
  undoDeadlineAt: 0,
  lastAction: null // { snapshot, pending, saveFn }
};

function clearToastTimers(){
  if(TOAST.hideTimer){ clearTimeout(TOAST.hideTimer); TOAST.hideTimer=null; }
  if(TOAST.undoTimer){ clearTimeout(TOAST.undoTimer); TOAST.undoTimer=null; }
}

function getToastWrap(){
	  let wrap = document.getElementById("toastWrap");
	  if(!wrap){
	    wrap = document.createElement("div");
	    wrap.id = "toastWrap";
	    wrap.className = "toastWrap";
	    document.body.appendChild(wrap);
	  }
	  return wrap;
	}
	
function ensureToastEl(){
  const elToastWrap = getToastWrap();
  if(TOAST.el && TOAST.el.closest('body').length > 0) return TOAST.el;
  
  $(elToastWrap).empty();
  const el = $("<div>")
    .addClass("toast ok")
    .html(`
      <div class="tRow">
        <div class="tMsg" id="tMsg"></div>
        <div class="tBtns">
          <button class="tBtn warn" id="tUndo">롤백</button>
          <button class="tBtn primary" id="tRetry">재시도</button>
          <button class="tBtn" id="tClose">닫기</button>
        </div>
      </div>
    `);
    
  $(elToastWrap).append(el);
  TOAST.el = el;

  el.find("#tClose").on("click", ()=> hideToast());
  el.find("#tUndo").on("click", ()=> toastUndo());
  el.find("#tRetry").on("click", ()=> toastRetry());
  return el;
}

function setToast(msg, {type="ok", autoHideMs=null, canUndo=false, canRetry=false}={}){
  const el = ensureToastEl();
  el.removeClass("ok warn err").addClass(type);
  el.find("#tMsg").text(msg);

  el.find("#tUndo").prop("disabled", !canUndo);
  el.find("#tRetry").prop("disabled", !canRetry);

  clearToastTimers();
  el.removeClass("on");
  void el[0].offsetWidth; // force reflow
  el.addClass("on");
  if(autoHideMs!=null){
    TOAST.hideTimer = setTimeout(()=> hideToast(), autoHideMs);
  }
}

function hideToast(){
  if(!TOAST.el) return;
  clearToastTimers();
  TOAST.el.removeClass("on");
  // TOAST.lastAction = null; // Don't clear lastAction immediately to allow Ctrl+Z or persistent retry
}

function snapshotTasks(){
  const snap = new Map();
  for(const [id, t] of STATE.tasks.entries()){
    snap.set(id, JSON.parse(JSON.stringify(t)));
  }
  return snap;
}

function restoreTasks(snapshot){
  STATE.tasks = new Map();
  for(const [id, t] of snapshot.entries()){
    STATE.tasks.set(id, JSON.parse(JSON.stringify(t)));
  }
  recalcPlanAll();
  renderAll();
}

function startUndoWindow(ms=5000){
  TOAST.undoDeadlineAt = Date.now() + ms;
  TOAST.undoTimer = setTimeout(()=>{
    if(TOAST.el && TOAST.el.closest('body').length > 0){
      TOAST.el.find("#tUndo").prop("disabled", true);
    }
  }, ms);
}

function toastUndo(){
  if(!TOAST.lastAction) return;
  // 경고 발생 시에는 데드라인을 넉넉하게 적용하거나 체크를 완화
  if(TOAST.undoDeadlineAt && Date.now() > TOAST.undoDeadlineAt) return;
  
  restoreTasks(TOAST.lastAction.snapshot);
  setToast("롤백이 완료되었습니다.", {type:"ok", autoHideMs:2000});
}

async function toastRetry(){
  if(!TOAST.lastAction) return;
  const { pending, saveFn } = TOAST.lastAction;
  if(!saveFn) return;

  setToast("저장 재시도 중...", {type:"ok", canUndo: Date.now()<=TOAST.undoDeadlineAt});
  try{
    await saveFn(pending);
    setToast("저장 성공(재시도)", {type:"ok", autoHideMs:1800, canUndo: Date.now()<=TOAST.undoDeadlineAt});
  }catch(e){
    setToast("저장 실패(재시도)- 네트워크/서버 오류 가정- [재시도] 또는 5초 내 [롤백] 가능", {type:"err", canUndo: Date.now()<=TOAST.undoDeadlineAt, canRetry:true});
  }
}

/** ---------- Backend API Call (AJAX) ---------- */
/** 
 * WB0602M01의 작성 규칙(postAjax)을 참고한 서버 통신 샘플 
 * 실제 운영 환경에서는 아래 URL과 파라미터를 해당 컨트롤러에 맞게 수정하여 사용하십시오.
 */
async function saveToServer(pending) {
  // 실제 postAjax는 콜백 기반이므로 비동기 처리를 위해 Promise로 래핑
  return new Promise((resolve, reject) => {
    let url = "";
    
    // 바 타입에 따른 엔드포인트 분기 샘플
    if(pending.barType === "PLAN") {
      url = "/user/wb/wb26/updateWbsLevel2PlanGantt";
    } else if(pending.barType === "ACT") {
      url = (pending.editType === "CLEAR") ? "/user/wb/wb26/deleteWbsLevel2GanttAct" : "/user/wb/wb26/updateWbsLevel2ActGantt";
    } else {
      url = "/user/wb/wb26/updateWbsLevel2MetaGantt";
    }

    // 전송 파라미터 구성 (사용자 정보 등 보완)
    const t = STATE.tasks.get(pending.taskId) || {};
    
    // 필수 제약 조건 체크: 상태가 '지연'인 경우 완료예정일 필수
    if (t.wbsPlanStsCodeId === "WBSPLANSTS30" && !t.revisedFinishDt) {
      if (pending.barType === "PLAN") {
          setToast("계획상태가 '지연' 상태입니다. (PLAN 저장 진행)", {type:"warn", autoHideMs: 2000});
      } else {
          setToast("상태가 '지연'인 경우 완료예정일은 필수입니다.", {type:"err"});
          return Promise.reject("Validation Error");
      }
    }

    const param = {
      ...pending,
      userId: $("#userId").val(),
      pgmId: "WB0604M01",
      coCd: "GUN",
      salesCd: $('#salesCd_H').val(),
      
      // MyBatis wbsLevel2Update Mapping
      fileTrgtKey: t.fileTrgtKey,
      rsltsFileTrgtKey: t.rsltsFileTrgtKey || 0, // 실적 고유번호 (0이면 Insert, 아니면 Update)
      seq: t.seq,
      wbsPlanCodeNm: t.title,
      wbsPlanMngId: t.wbsPlanMngId,
      // If editing PLAN, use new values; otherwise use existing
      wbsPlansDt: (pending.barType === "PLAN") ? pending.normalizedStart : t.planStartAt,
      wbsPlaneDt: (pending.barType === "PLAN") ? pending.normalizedEnd : t.planEndAt,
      daycnt: (pending.barType === "PLAN") ? pending.durationWd : t.planDurationWd,
      
      // ACT 처리: CLEAR인 경우 빈 문자열로, 아니면 새 값 또는 기존 값 사용
      // (비즈니스 룰: 진척율 100%가 아니면 실적종료일은 현재일로 전송)
      wbsRsltssDt: (pending.barType === "ACT" && pending.editType === "CLEAR") ? "" : 
                   (pending.barType === "ACT" ? (pending.normalizedStart || "") : (t.actStartAt || "")),
      wbsRsltseDt: (pending.barType === "ACT" && pending.editType === "CLEAR") ? "" : 
                   (t.actProgress < 100 ? toYmd(new Date()) : (pending.barType === "ACT" ? (pending.normalizedEnd || "") : (t.actEndAt || ""))),
      rsltsDaycnt: (pending.barType === "ACT") ? pending.durationWd : t.actDurationWd,
      expectMh: t.expectMh,
      wbsRsltsMh: t.wbsRsltsMh,
      wbsPlanStsCodeId: t.wbsPlanStsCodeId,
      revisedFinishDt: t.revisedFinishDt,
      wbsPlanCodeKind: t.wbsPlanCodeKind,
      verUpReason: t.verUpReason,
      verNo: t.verNo,
      wbsPlanCodeId: t.wbsPlanCodeId,
      wbsRsltsNo: t.wbsPlanNo,
      wbsRsltsCnts: t.resultsCnts,
      wbsRsltsRate: t.actProgress, 

      // Aliases for UDT_ID/UDT_PGM
      creatId: $("#userId").val(),
      creatPgm: "WB0604M01",
      year: (t.planStartAt && t.planStartAt.length >= 4) ? t.planStartAt.substring(0,4) : ""
    };
    // Use postAjax instead of filePostAjax for standard form data
    if(typeof postAjax === 'function') {
      postAjax(url, param, null, function(res) {
        if(res.resultCode == 200 || res.ok) {
           // 백엔드에서 생성/업데이트된 키 및 보정된 데이터 반영
           if(t) {
             if(res.fileTrgtKey) t.fileTrgtKey = res.fileTrgtKey;
             if(res.rsltsFileTrgtKey) t.rsltsFileTrgtKey = Number(res.rsltsFileTrgtKey);
             if(res.wbsPlanCodeId) t.wbsPlanCodeId = res.wbsPlanCodeId;
             if(res.wbsRsltsNo) t.wbsRsltsNo = res.wbsRsltsNo;
             
             // 백엔드 비즈니스 룰에 의해 보정된 결과 반영 (지연완료 등)
             if(res.wbsPlanStsCodeId) {
                t.wbsPlanStsCodeId = res.wbsPlanStsCodeId;
                t.status = STS_NAME[t.wbsPlanStsCodeId] || t.status;
             }
             
             // 백엔드에서 받은 실적종료일이 빈값('')이면 오늘 날짜로 설정
             if (res.wbsRsltseDt !== undefined) {
                 if (res.wbsRsltseDt === "") {
                     t.actEndAt = toYmd(new Date());
                 } else {
                     t.actEndAt = toYmdStr(res.wbsRsltseDt);
                 }
             } else {
                 // Fallback: 진척도 100% 미만 시 종료일 현재일로 동기화
                 if(t.actProgress < 100) t.actEndAt = toYmd(new Date());
             }
           }
           resolve(res);
        } else {
           const msg = res.resultMessage || res.msg || "";
           alert("서버 처리 오류! " + msg);
           reject(new Error(msg));
        }
      });
    } else {
      console.error("postAjax is not defined");
    }
    
  });
}

/** ---------- Change Commit (No Confirm) ---------- */

function applyPendingChange(p){
  const t = STATE.tasks.get(p.taskId);
  if(!t) return;

  // 부모 노드(parentId: null)는 자동 계산되거나 템플릿에 의해 관리되므로 수동 변경 원천 차단
  if(t.parentId === null) {
    setToast("최상위 단계는 직접 수정할 수 없습니다.", {type:"warn"});
    return;
  }

  if(p.barType === "PLAN"){
    const isChanged = (t.planStartAt !== p.normalizedStart) || (p.editType !== "MOVE" && t.planDurationWd !== p.durationWd);
    
    t.planStartAt = p.normalizedStart;
    if(isChanged) t._planDirty = true; 

    if(p.editType !== "MOVE"){
      t.planDurationWd = Math.max(1, Number(p.durationWd || 1));
    }
    t.planEndAt = null;
    recalcPlanAll();
  } else if(p.barType === "ACT"){
    const isChanged = (t.actStartAt !== p.normalizedStart) || (t.actEndAt !== p.normalizedEnd);

    t.actStartAt = p.normalizedStart;
    t.actEndAt = p.normalizedEnd;
    if(isChanged) t._actDirty = true; 
    
    if(p.editType === "MOVE" && p.origStart && p.origEnd){
      const prevDur = diffWorkingDaysInclusive(p.origStart, p.origEnd);
      if(t.actStartAt) {
        t.actEndAt = addWorkingDays(t.actStartAt, prevDur - 1);
        t.actDurationWd = prevDur;
      }
    } else {
      t.actDurationWd = (t.actStartAt && t.actEndAt) ? Math.max(1, diffWorkingDaysInclusive(t.actStartAt, t.actEndAt)) : 0;
    }

    // 기간 변경에 따른 진척율 및 상태 자동 계산 적용
    recalcAutoProgress(t);

    // 실적 신규 생성(또는 기간 발생) 시 상태 및 진척도 초기화 (진척율 0%인 경우만 자동 1% 세팅)
    if(t.actDurationWd >= 1 && (t.actProgress === 0 || !t.actProgress)) {
      t.actProgress = 1;
      t.status = "진행중";
      t.wbsPlanStsCodeId = STS_CODE["진행중"] || "WBSPLANSTS20";
      t._metaDirty = true;
    }
    
    // 실적 위반 여부 업데이트 (드래그/상세 수정 공용)
    if(t.actStartAt && t.actEndAt) {
      t.actWarnYn = isActViolationLikely(t.id, t.actStartAt, t.actEndAt) ? "Y" : "N";
    } else {
      t.actWarnYn = "N";
    }

    refreshSummariesOnly();
  } else {
    t._metaDirty = true;
    refreshSummariesOnly();
  }

  STATE.selectedId = t.id;
  renderAll();
}

function refreshEditModeUI() {
  const mode = STATE.editMode || "PLAN";
  const btnPlan = $("#btnEditPlan");
  const btnAct = $("#btnEditAct");
  const info = $("#editModeInfo");

  btnPlan.toggleClass("active-red", mode === "PLAN");
  btnAct.toggleClass("active-red", mode === "ACT");
  info.text(`[${mode} 편집 중]`);
}

function commitDetailSave(barType, taskId, origStart, origEnd, normalizedStart, normalizedEnd, durationWd){
  commitChangeAndToast({
    taskId,
    barType,
    editType:"DETAIL",
    origStart: origStart || "-",
    origEnd: origEnd || "-",
    previewStart: normalizedStart,
    previewEnd: normalizedEnd,
    normalizedStart,
    normalizedEnd,
    durationWd,
    warningLikely: (barType==="PLAN") 
      ? isPlanViolationLikely(taskId, normalizedStart) 
      : isActViolationLikely(taskId, normalizedStart, normalizedEnd)
  });
}
function commitChangeAndToast(p){
  pushUndoSnapshot(); // Push UI state BEFORE change
  const snap = snapshotTasks();

  applyPendingChange(p);

  startUndoWindow(5000);
  setToast("저장 중...", {type:"ok", canUndo:true});

  TOAST.lastAction = { snapshot: snap, pending: p, saveFn: saveToServer };

  (async ()=>{
    try{
      await saveToServer(p);
      const t = STATE.tasks.get(p.taskId);
      if(!t) return;

      if(p.barType==="PLAN"){
        t._planDirty = false; // Clear dirty
        const warn = (t.planWarnYn==="Y") ? `
- ${warnLabelPlan(t)}` : "";
        setToast(
          `저장 성공(PLAN/${p.editType})
- ${p.origStart} ~ ${p.origEnd}
- ${t.planStartAt} ~ ${t.planEndAt} (WD ${t.planDurationWd})${warn}`,
          {type:(t.planWarnYn==="Y")?"warn":"ok", canUndo:true, autoHideMs:null} // Persist for undo
        );
      } else if(p.barType==="ACT"){
        t._actDirty = false; // Clear dirty
        t._metaDirty = false; // Also clear meta dirty since ACT save includes it
        
        // Update original values to current saved state
        t._originalActStart = t.actStartAt || null;
        t._originalActEnd = t.actEndAt || null;
        
        setToast(
          `저장 성공(ACT/${p.editType})
- ${p.origStart} ~ ${p.origEnd}
- ${t.actStartAt||"-"} ~ ${t.actEndAt||"-"} (진척 ${t.actProgress||0}%)`,
          {type:"ok", canUndo:true, autoHideMs:null} // Persist for undo
        );
      } else {
        t._metaDirty = false; // Clear dirty
    	  setToast(`${p.barType} 일정이 저장되었습니다.`, { type:"ok", autoHideMs:null, canUndo:true }); // Persist for undo
      }
      renderAll(); // Re-render to update highlights
      
      // Push post-save snapshot to UNDO_STACK for Ctrl+Z
      // This ensures Ctrl+Z restores to the saved state, not the pre-change state
      pushUndoSnapshot();
    }catch(e){
      setToast("저장 실패- 네트워크/서버 오류 가정- [재시도] 또는 5초 내 [롤백] 가능", {type:"err", canUndo:true, canRetry:true});
    }
  })();
}

/** ---------- Drag Handlers (PLAN/ACT) ----------  (PLAN/ACT) ---------- */
function attachDualBarDragWithConfirm(barEl, handleL, handleR, taskId, baseYmd, barType){
  const mode = { type:null }; // MOVE | RESIZE_START | RESIZE_END
  let startX=0, origStart=null, origEnd=null;

  function pxToDayDelta(px){ return Math.round(px/getDayW()); }
  function shift(ymd, dd){ return addDays(ymd, dd); } // 미리보기는 1:1 추적 위해 달력 기준 사용

  function getRange(t){
    if(barType==="PLAN") return { s: t.planStartAt, e: t.planEndAt };
    return { s: t.actStartAt, e: t.actEndAt };
  }

  function beginDrag(e, dragType){
    // 0. 포커스 및 이전 알림 초기화
    prevFocus = { id: null, start: 0, end: 0 };
    hideToast();
    
    // 1. 상태 업데이트
    STATE.selectedId = taskId;
    STATE.editMode = barType; 
    
    // 2. UI 즉시 업데이트 
    $(".bar.is-active").removeClass("is-active");
    $(barEl).addClass("is-active");
    
    renderTree(); 
    renderDetail(); 
    refreshEditModeUI();

    e.preventDefault(); e.stopPropagation();
    
    // 드래그 시작 시점의 상태를 실행 취소(Undo) 스택에 저장
    pushUndoSnapshot();

    const t = STATE.tasks.get(taskId);
    const r = getRange(t);
    if(!r.s || !r.e) return;

    mode.type = dragType;
    startX = e.clientX;
    origStart = r.s;
    origEnd = r.e;

    $(window).on("mousemove", onMove);
    $(window).on("mouseup", onUp);
  }

  function computePreview(dd){
    let ps=origStart, pe=origEnd;
    if(mode.type==="MOVE"){
      ps = shift(origStart, dd);
      pe = shift(origEnd, dd);
    } else if(mode.type==="RESIZE_START"){
      ps = shift(origStart, dd);
      // end 고정
      if(diffDays(ps, pe) < 0) ps = pe;
    } else if(mode.type==="RESIZE_END"){
      pe = shift(origEnd, dd);
      // start 고정
      if(diffDays(ps, pe) < 0) pe = ps;
    }
    return { ps, pe };
  }

  function onMove(e){
    const dd = pxToDayDelta(e.clientX - startX);
    const { ps, pe } = computePreview(dd);
    const t = STATE.tasks.get(taskId);
    // 임시 객체로 툴팁 표시
    const tempT = { ...t };
    if(barType === "PLAN") { tempT.planStartAt = ps; tempT.planEndAt = pe; }
    else { tempT.actStartAt = ps; tempT.actEndAt = pe; }
    
    showTip(e.clientX, e.clientY, tempT, barType);

    const sIdx = diffDays(baseYmd, ps);
    const eIdx = diffDays(baseYmd, pe);
    const dayW = getDayW();
    $(barEl).css({
      left: `${sIdx*dayW}px`,
      width: `${Math.max(1,(eIdx-sIdx+1))*dayW}px`
    });
  }

  function onUp(e){
    $(window).off("mousemove", onMove);
    $(window).off("mouseup", onUp);
    hideTip();

    const dd = pxToDayDelta(e.clientX - startX);
    const { ps, pe } = computePreview(dd);

    const ns = nextWorkingDay(ps);
    let ne = nextWorkingDay(pe);
    
    // MOVE인 경우 시작일 기준으로 원래 기간만큼 종료일 재산출 (휴일 제외)
    if(mode.type === "MOVE"){
       const originalDur = diffWorkingDaysInclusive(origStart, origEnd);
       ne = addWorkingDays(ns, originalDur - 1);
    }

    const durationWd = Math.max(1, diffWorkingDaysInclusive(ns, ne));
    
    // 드래그 전 상태 스냅샷 (롤백 버튼용)
    const snap = snapshotTasks();

    const isPlanBar = (barType === 'PLAN');
    const warningLikely = isPlanBar 
      ? isPlanViolationLikely(taskId, ns, ne) 
      : isActViolationLikely(taskId, ns, ne);

    applyPendingChange({
      taskId,
      editType: mode.type,
      barType,
      origStart,
      origEnd,
      normalizedStart: ns,
      normalizedEnd: ne,
      durationWd,
      warningLikely
    });

    if(warningLikely) {
      TOAST.lastAction = { snapshot: snap, pending: null, saveFn: null };
      startUndoWindow(3600000); // 1시간 동안 롤백 가능 (사실상 무제한)
      const msg = isPlanBar ? '상위 단계 기간을 벗어남 (경고 허용)' : '계획된 기간을 벗어남 (경고 허용)';
      // autoHideMs를 null로 설정하여 다른 작업 전까지 유지
      setToast(msg, {type:'warn', autoHideMs:null, canUndo:true});
    }
  }

  $(barEl).on("mousedown", (e)=>{
    if(e.target === handleL || e.target === handleR) return;
    beginDrag(e, "MOVE");
  });
  $(handleL).on("mousedown", (e) => beginDrag(e, "RESIZE_START"));
  $(handleR).on("mousedown", (e) => beginDrag(e, "RESIZE_END"));
}

function isPlanViolationLikely(taskId, newStart, newEnd){
  const t = STATE.tasks.get(taskId);
  if(!t || !t.parentId) return false;
  
  const parent = STATE.tasks.get(t.parentId);
  if(!parent || !parent.planStartAt || !parent.planEndAt) return false;

  if(!newEnd) {
    const dur = Math.max(1, Number(t.planDurationWd || 1));
    newEnd = addWorkingDays(newStart, dur - 1);
  }

  // 부모 범위를 벗어나는지 체크 (diffDays(a,b) = b-a)
  // b-a > 0 이면 a가 b보다 빠른 것이므로 위반
  const startViolation = diffDays(newStart, parent.planStartAt) > 0; // newStart < parent.planStartAt
  const endViolation = diffDays(parent.planEndAt, newEnd) > 0;       // newEnd > parent.planEndAt
  
  return startViolation || endViolation;
}

/** 실적(ACT)이 계획(PLAN) 범위를 벗어나는지 체크 */
function isActViolationLikely(taskId, newStart, newEnd){
  const t = STATE.tasks.get(taskId);
  if(!t || !t.planStartAt || !t.planEndAt) return false;

  if(!newEnd) {
    const dur = (t.actStartAt && t.actEndAt) ? diffWorkingDaysInclusive(t.actStartAt, t.actEndAt) : 1;
    newEnd = addWorkingDays(newStart, dur - 1);
  }

  // 계획 범위를 벗어나는지 체크 (diffDays(a,b) = b-a)
  const startViolation = diffDays(newStart, t.planStartAt) > 0; // newStart < planStartAt
  const endViolation = diffDays(t.planEndAt, newEnd) > 0;       // newEnd > planEndAt
  
  return startViolation || endViolation;
}

	// 경고 문구(선택)
	function warnLabelPlan(t){
	  // 필요 시 DIRECT/연쇄 케이스를 여기서 구체화
	  return "상위 범위를 벗어남";
	}

/** ---------- Gantt Render (Dual Bar) ---------- */
function renderGantt(){
  const days = getTimelineDays();
  const dayW = getDayW();
  elRangeInfo.text(`${days[0]} ~ ${days[days.length-1]}`);
  elGantt.empty();

  // header
  const headName = $("<div>").addClass("gHead").text("TASK");
  const headTime = $("<div>").addClass("gHead timeline");
  
  const months = [];
  let curM = null;
  for(const d of days){
    const ym = d.substring(0, 7);
    if(!curM || curM.ym !== ym){
      curM = { ym, count: 0 };
      months.push(curM);
    }
    curM.count++;
  }

  const rowM = $("<div>").addClass("timeline-row");
  for(const m of months){
    $("<div>")
      .addClass("timeline-month")
      .css("width", `${m.count * dayW}px`)
      .text(m.ym.replace("-","년 ") + "월")
      .appendTo(rowM);
  }
  headTime.append(rowM);

  const rowD = $("<div>").addClass("timeline-row timeline-days");
  for(const d of days){
    const w = dayOfWeek(d);
    $("<div>")
      .addClass("dayCell")
      .toggleClass("weekend", w===0||w===6)
      .toggleClass("holiday", isHoliday(d))
      .attr("title", isHoliday(d) ? `공휴일: ${d}` : d)
      .text(d.split("-")[2])
      .appendTo(rowD);
  }
  headTime.append(rowD);

  const today = toYmd(new Date());
  const todayIdx = diffDays(days[0], today);
  if(todayIdx >= 0 && todayIdx < days.length){
    $("<div>")
      .addClass("today-badge")
      .css("left", `${todayIdx * dayW + dayW/2}px`)
      .text("TODAY")
      .appendTo(headTime);
  }

  elGantt.append(headName).append(headTime);

  const rows = getTaskListInTreeOrder();
  for(const {t, depth} of rows){
    const name = $("<div>")
      .addClass("gName")
      .toggleClass("parent-row", t.parentId === null)
      .toggleClass("sel", t.id === STATE.selectedId)
      .toggleClass("delayed", t.wbsPlanStsCodeId === "WBSPLANSTS30")
      .css("padding-left", `${10 + depth*14}px`)
      .on("click", () => { 
        if(STATE.selectedId !== t.id) {
          STATE.selectedId = t.id; 
          renderAll(); 
          focusOnTreeTask(t.id);
        }
      });

    const titleInput = $("<input>")
      .addClass("gNameInput")
      .val(t.title)
      .prop("disabled", t.parentId === null)
      .on("focus", function() {
        pushUndoSnapshot();
      })
      .on("input", function() {
        const newVal = $(this).val();
        t.title = newVal;
        t._metaDirty = true;
        
        // 상세 패널 동기화
        if(STATE.selectedId === t.id) {
          $("#wbsPlanCodeNm").val(newVal);
          const isActDirtyUnified = (t._actDirty || t._metaDirty);
          const isCommonDirty = (t._planDirty && isActDirtyUnified);
          $("#btnSaveAct").toggleClass('highlight-blue', isActDirtyUnified).prop("disabled", !isActDirtyUnified);
          $("#btnSaveMeta").toggleClass('highlight-blue', isCommonDirty).prop("disabled", !isCommonDirty);
        }
        renderTree(); // 좌측 마인드맵 동기화
      })
      .appendTo(name);

    const line = $("<div>")
      .addClass("gLine")
      .toggleClass("parent-row", t.parentId === null)
      .toggleClass("delayed", t.wbsPlanStsCodeId === "WBSPLANSTS30")
      .toggleClass("sel", t.id === STATE.selectedId);
    const bg = $("<div>").addClass("bgGrid");
    for(const d of days){
      const w = dayOfWeek(d);
      $("<div>")
        .addClass("cell")
        .toggleClass("weekend", w===0||w===6)
        .toggleClass("holiday", isHoliday(d))
        .appendTo(bg);
    }
    if(todayIdx >= 0 && todayIdx < days.length){
      $("<div>")
        .addClass("today-line")
        .css("left", `${todayIdx * dayW}px`)
        .appendTo(line);
    }
    line.append(bg);

    // 행 클릭 시 선택 연동
    line.on("click", (e) => {
        // 드래그 핸들 클릭 시에는 무시
        if ($(e.target).hasClass('handle')) return;
        if(STATE.selectedId !== t.id) {
            STATE.selectedId = t.id;
            renderAll();
            focusOnTreeTask(t.id);
        }
    });

    // PLAN bar
    if(t.planStartAt && t.planEndAt){
      const psIdx = diffDays(days[0], t.planStartAt);
      const peIdx = diffDays(days[0], t.planEndAt);
      const barPlan = $("<div>")
        .addClass("bar plan")
        .toggleClass("parent", t.parentId === null)
        .attr({ "data-start": t.planStartAt, "data-end": t.planEndAt })
        .toggleClass("warning", t.planWarnYn === "Y")
        .toggleClass("overdue", t.planOverdueYn === "Y")
        .toggleClass("is-active", t.id === STATE.selectedId)
        .css({ left: `${psIdx*dayW}px`, width: `${Math.max(1,(peIdx-psIdx+1))*dayW}px` });

      const hl = $("<div>").addClass("handle left");
      const hr = $("<div>").addClass("handle right");
      barPlan.append(hl).append(hr);
      
      // parentId가 null(최상위)이 아닌 경우에만 드래그 편집 허용
      if(t.parentId !== null){
        attachDualBarDragWithConfirm(barPlan[0], hl[0], hr[0], t.id, days[0], "PLAN");
      } else {
        barPlan.css("cursor", "default");
        hl.hide(); hr.hide();
      }

      barPlan.on("mousemove", (e) => showTip(e.clientX, e.clientY, t, "PLAN"))
            .on("mouseleave", hideTip)
            .on("click", (e) => {
                e.stopPropagation(); // gLine 클릭과 중복 방지
                if(STATE.selectedId !== t.id) {
                    STATE.selectedId = t.id;
                    renderAll();
                    focusOnTreeTask(t.id);
                }
            });

      line.append(barPlan);
    }

    // ACT bar
    if(t.actStartAt && t.actEndAt){
      const asIdx = diffDays(days[0], t.actStartAt);
      const aeIdx = diffDays(days[0], t.actEndAt);
      const barAct = $("<div>")
        .addClass("bar act")
        .toggleClass("parent", t.parentId === null)
        .toggleClass("is-active", t.id === STATE.selectedId)
        .toggleClass("violation", t.actWarnYn === "Y") // 실적 위반 점선 표시
        .attr({ "data-start": t.actStartAt, "data-end": t.actEndAt })
        .css({ left: `${asIdx*dayW}px`, width: `${Math.max(1,(aeIdx-asIdx+1))*dayW}px` });

      const hl2 = $("<div>").addClass("handle left");
      const hr2 = $("<div>").addClass("handle right");
      barAct.append(hl2).append(hr2);
      
      // parentId가 null(최상위)이 아닌 경우에만 드래그 편집 허용
      if(t.parentId !== null){
        attachDualBarDragWithConfirm(barAct[0], hl2[0], hr2[0], t.id, days[0], "ACT");
      } else {
        barAct.css("cursor", "default");
        hl2.hide(); hr2.hide();
      }

      barAct.on("mousemove", (e) => showTip(e.clientX, e.clientY, t, "ACT"))
            .on("mouseleave", hideTip)
            .on("click", (e) => {
                e.stopPropagation(); // gLine 클릭과 중복 방지
                if(STATE.selectedId !== t.id) {
                    STATE.selectedId = t.id;
                    renderAll();
                    focusOnTreeTask(t.id);
                }
            });

      line.append(barAct);
    }

    elGantt.append(name).append(line);
  }
}

/** ---------- Detail Render (PLAN/ACT Editable) ---------- */
function renderDetail(){
  hideToast(); // 다른 TASK 선택 시 기존 알림(의존성 위반 등) 제거
  const t=STATE.tasks.get(STATE.selectedId);
  if(!t){ elDetail.html('<div class="mini">선택된 노드가 없습니다.</div>'); return; }

  const preds=predecessorsOf(t.id).map(p=>p.fromId);
  const succs=successorsOf(t.id).map(s=>s.toId);
  const issues=STATE.issues.filter(i=>i.taskId===t.id);

  elDetail.html(`
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 6px;">
      <input class="inp" id="wbsPlanCodeNm" type="text" value="${escapeHtml(t.title)}" style="font-weight:900; font-size:15px; width:100%; border:1px solid transparent; background:transparent; padding:4px;" placeholder="TASK명 입력" />
      <div class="badges">
        <span class="badge primary">${escapeHtml((t.status||"TODO")+" "+(t.progress||0)+"%")}</span>
        ${t.planOverdueYn==="Y" ? `<span class="badge danger">기한경과(PLAN)</span>` : ``}
        ${t.planWarnYn==="Y" ? `<span class="badge warn">${escapeHtml(warnLabelPlan(t))}</span>` : ``}
      </div>
    </div>

    <div class="mini" style="margin-top:6px;">
      - 의존성(선행): ${preds.length ? preds.join(", ") : "-"}<br/>
      - 의존성(후행): ${succs.length ? succs.join(", ") : "-"}
    </div>

    <div class="sep"></div>

    <div class="blockTitle">
      <div>계획(PLAN)</div>
      <span class="pill">상단 바</span>
    </div>

    <div class="field">
      <label>시작</label>
      <input class="inp" id="wbsPlansDt" type="date" value="${t.planStartAt||""}" ${t.parentId===null ? 'disabled' : ''}/>
    </div>

    <div class="field">
      <label>종료</label>
      <input class="inp" id="wbsPlaneDt" type="date" value="${t.planEndAt||""}" ${t.parentId===null ? 'disabled' : ''}/>
    </div>

    <div class="field">
      <label>기간(WD)</label>
      <input class="inp" id="daycnt" type="text" value="${Number(t.planDurationWd||1)}" disabled style="background:#f9fafb; color:#6b7280;"/>
    </div>

    <div style="display:flex; gap:8px; margin-top:6px;">
      ${t.parentId !== null ? `
        <button class="btn primary ${t._planDirty ? 'highlight-blue' : ''}" id="btnSavePlan" ${!t._planDirty ? 'disabled' : ''}>PLAN 저장</button>
        <button class="btn" id="btnSyncPlanFromAct">실적→계획</button>
      ` : ``}
    </div>

    <div class="sep"></div>

    <div class="blockTitle">
      <div>실적(ACT)</div>
      <span class="pill">하단 바</span>
    </div>

    <div class="field">
      <label>시작</label>
      <input class="inp" id="wbsRsltsSDt" type="date" value="${t.actStartAt||""}" ${t.parentId===null ? 'disabled' : ''}/>
    </div>

    <div class="field">
      <label>종료</label>
      <input class="inp ${t.wbsPlanStsCodeId === 'WBSPLANSTS30' ? 'required-delayed' : ''}" id="wbsRsltsEDt" type="date" value="${t.actEndAt||""}" ${t.parentId===null ? 'disabled' : ''}/>
    </div>

    <div class="field">
      <label>진행(%)</label>
      <input class="inp" id="calcProgress" type="text" value="${Number(t.progress||0)}" disabled style="background:#f9fafb; color:#6b7280;"/>
    </div>

    <div style="display:flex; gap:8px; margin-top:6px;">
      ${t.parentId !== null ? `
        <button class="btn primary ${(t._actDirty || t._metaDirty) ? 'highlight-blue' : ''}" id="btnSaveAct" ${!(t._actDirty || t._metaDirty) ? 'disabled' : ''}>ACT 저장</button>
        <button class="btn" id="btnClearAct" ${!(t.actStartAt || t.actEndAt) ? 'disabled' : ''}>ACT 제거</button>
      ` : `<div class="mini">하위 TASK 실적에 의해 자동 계산됩니다.</div>`}
    </div>

    <div class="sep"></div>

    <div class="blockTitle">
      <div>실적 진행 상태</div>
      <span class="pill">Meta</span>
    </div>

    <div class="field" style="font-size: 11px; opacity: 0.8;">
      <label>ID(Plan/Act)</label>
      <div style="display: flex; gap: 4px;">
        <span class="badge" title="Plan No">${t.wbsPlanNo || "-"}</span>
        <span class="badge" title="Results No">${t.wbsRsltsNo || "-"}</span>
      </div>
    </div>
    
    <div class="field">
      <label>상태</label>
      <select class="sel2 ${t.wbsPlanStsCodeId === 'WBSPLANSTS30' ? 'required-delayed' : ''}" id="wbsPlanStsCodeId">
        ${Object.entries(STS_NAME).map(([code, name]) => `<option value="${code}" ${t.wbsPlanStsCodeId === code ? "selected" : ""}>${name}</option>`).join("")}
      </select>
    </div>
    
    <div class="field" id="divRevisedFinishDt" style="display: ${t.wbsPlanStsCodeId === 'WBSPLANSTS30' ? 'grid' : 'none'};">
      <label>완료예정일</label>
      <input class="inp ${t.wbsPlanStsCodeId === 'WBSPLANSTS30' ? 'required-delayed' : ''}" id="revisedFinishDt" type="date" value="${t.revisedFinishDt || ""}"/>
    </div>

    <div class="field">
      <label>진척(%)</label>
      <input class="inp" id="actProgress" type="text" value="${Number(t.actProgress||0)}"/>
    </div>

    <div class="field" style="grid-template-columns: 100px 1fr;">
      <label>투입공수(MH)</label>
      <input class="inp" id="wbsRsltsMh" type="number" step="0.1" value="${t.wbsRsltsMh || "0"}"/>
    </div>

    <div class="field" style="grid-template-columns: 100px 1fr; align-items: flex-start;">
      <label style="margin-top: 4px;">특이사항</label>
      <textarea class="ta" id="wbsRsltsCnts" placeholder="특이사항을 입력하세요">${t.resultsCnts || ""}</textarea>
    </div>

    <div style="display:flex; gap:8px;">
      <button class="btn primary ${(t._planDirty && (t._actDirty || t._metaDirty)) ? 'highlight-blue' : ''}" id="btnSaveMeta" ${!(t._planDirty && (t._actDirty || t._metaDirty)) ? 'disabled' : ''}>공통 저장</button>
      <button class="btn" id="btnFocus">간트에서 보기</button>
    </div>

    <div class="sep"></div>

    <div style="font-weight:900; margin-bottom:8px;">이슈</div>
    <div class="issueList">
      ${issues.length ? issues.map(i=>`
        <div class="issue" data-issue-id="${i.issueId}" style="cursor: pointer;">
          <div class="t">
            <div>${escapeHtml(i.title)}</div>
            <div class="badges">

              <span class="badge ${i.status !== "완료" ? "danger" : ""}">${escapeHtml(i.status)}</span>
            </div>
          </div>
          <div class="s">발생: ${escapeHtml(i.occurredAt)} / 조치: ${escapeHtml(i.owner)} / 문제: ${escapeHtml(i.issueId)} / 발주 ${escapeHtml(i.reqNo)}</div>
        </div>
      `).join("") : `<div class="mini">등록된 이슈가 없습니다.</div>`}
    </div>
  `);

  // --- Issue Double Click Handler ---
  elDetail.find(".issue").on("dblclick", function() {
    const issueId = $(this).attr("data-issue-id");
    const issue = STATE.issues.find(iss => iss.issueId === issueId);
    if (!issue) return;

    var paramObj = {
      "actionType"     : "U4",
      "coCd"           : issue.coCd,
      "salesCd"        : issue.salesCd,
      "issFileTrgtKey" : issue.fileTrgtKey
    };
    
    if(typeof openModal === 'function') {
      openModal("/static/html/user/wb/wb24/WB2401P11.html", 1200, 870, "WBS 실적문제수정", paramObj, function (){
         loadWbsData();
      });
    } else {
      alert("openModal 함수를 찾을 수 없습니다.");
    }
  });

  // --- Focus Restoration Start ---
  if (prevFocus.id) {
    const el = $(`#${prevFocus.id}`);
    if (el.length) {
      el.focus();
      const node = el[0];
      if (node.setSelectionRange && (node.type === 'text' || node.type === 'textarea')) {
        node.setSelectionRange(prevFocus.start, prevFocus.end);
      }
    }
  }

  // Track Focus & Selection state
  const trackFocus = function() {
    prevFocus.id = this.id;
    if (this.setSelectionRange) {
      prevFocus.start = this.selectionStart;
      prevFocus.end = this.selectionEnd;
    }
  };

  elDetail.find("input, select, textarea").on("focus input click", trackFocus);
  // --- Focus Restoration End ---

  // --- Real-time Sync & Button Highlight Logic ---
  const btnSavePlan = $("#btnSavePlan");
  const btnSaveAct = $("#btnSaveAct");
  const btnSaveMeta = $("#btnSaveMeta");

  const syncPlan = () => {
    const elS = $("#wbsPlansDt");
    const elE = $("#wbsPlaneDt");
    const elD = $("#daycnt");
    
    let s = elS.val();
    let e = elE.val();
    
    if(s && e) {
      // 근무일 보정
      const ns = nextWorkingDay(s);
      const ne = nextWorkingDay(e);
      if(s !== ns) { elS.val(ns); s = ns; }
      if(e !== ne) { elE.val(ne); e = ne; }

      // 시작일이 종료일보다 늦은 경우 보정
      if(diffDays(s, e) < 0) {
        elE.val(s); e = s;
      }

      const dur = Math.max(1, diffWorkingDaysInclusive(s, e));
      elD.val(dur);

      if(t.planStartAt !== s || t.planDurationWd !== dur) {
        hideToast();
        t.planStartAt = s;
        t.planDurationWd = dur;
        t._planDirty = true; 
        recalcPlanAll();
        renderTree();
        renderGantt(); 
        renderDetail(); 
      }
    }
  };

  const syncAct = () => {
    const elS = $("#wbsRsltsSDt");
    const elE = $("#wbsRsltsEDt");
    const elActP = $("#actProgress"); // 진척도(Manual)
    const elP = $("#calcProgress");       // 진행도(Auto from WD)
    
    let s = elS.val() || null;
    let e = elE.val() || null;

    if(s) {
      const ns = nextWorkingDay(s);
      if(s !== ns) { elS.val(ns); s = ns; }
    }
    if(e) {
      const ne = nextWorkingDay(e);
      if(e !== ne) { elE.val(ne); e = ne; }
    }

    if(s && !e){ elE.val(s); e = s; }

    const oldS = t.actStartAt;
    const oldE = t.actEndAt;

    if(oldS !== s || oldE !== e) {
      t.actStartAt = s;
      t.actEndAt = e;
      
      // 날짜 변경 시 "진행(%)" 수치 자동 계산 (Manual Progress나 Status와 연동하지 않음)
      const autoProg = recalcAutoProgress(t);
      elP.val(autoProg);
      t.progress = autoProg;
      
      // 실적 신규 생성(또는 기간 발생) 시 상태 및 진척도 초기화 (진척율 0%인 경우만 자동 1% 세팅)
      const dur = (t.actStartAt && t.actEndAt) ? diffWorkingDaysInclusive(t.actStartAt, t.actEndAt) : 0;
      if (dur >= 1 && (t.actProgress === 0 || !t.actProgress)) {
         t.actProgress = 1;
         t.status = "진행중";
         t.wbsPlanStsCodeId = STS_CODE["진행중"] || "WBSPLANSTS20";
         t._metaDirty = true;
      }
      
      // Smart dirty flag: 원본 값과 비교하여 설정
      // 원본이 null이었고 현재도 null이면 dirty 아님
      const originalStart = t._originalActStart || null;
      const originalEnd = t._originalActEnd || null;
      const currentStart = t.actStartAt || null;
      const currentEnd = t.actEndAt || null;
      
      if(originalStart === currentStart && originalEnd === currentEnd) {
        t._actDirty = false; // 원본 상태로 돌아옴
      } else {
        t._actDirty = true; // 변경됨
      }
      
      hideToast();
      refreshSummariesOnly();
      renderTree();
      renderGantt();
      renderDetail();
    }
  };

  const syncMeta = () => {
    const elS = $("#wbsPlanStsCodeId");
    const elP = $("#calcProgress");
    const elActP = $("#actProgress");
    const elResult = $("#wbsRsltsCnts");
    const elWbsRsltsMh = $("#wbsRsltsMh");
    
    let actPVal = elActP.val().replace(/[^0-9]/g, '');
    if(actPVal !== '' && parseInt(actPVal) > 100) actPVal = '100';
    elActP.val(actPVal);
    let nap = parseInt(actPVal || 0);

    let newCode = elS.val(); // Code (WBSPLANSTS10, etc.)
    const nr = elResult.val();
    const nem = elWbsRsltsMh.val();

    // 1. 상태(Status Code)가 변경된 경우
    if (newCode !== t.wbsPlanStsCodeId) {
      if (newCode === "WBSPLANSTS50" || newCode === "WBSPLANSTS40") { // 완료계 포괄
        nap = 100;
        elActP.val(100);
      } else if ((newCode === "WBSPLANSTS20" || newCode === "WBSPLANSTS30") && nap === 100) { 
        nap = 90;
        elActP.val(90);
      } else if (newCode === "WBSPLANSTS10") { // 미진행
        nap = 0;
        elActP.val(0);
      }
    } 
    // 2. 진척율(Manual Progress)이 변경된 경우
    else if (nap !== t.actProgress) {
      if (nap === 100 && newCode !== "WBSPLANSTS50") {
        nap = 90;
        elActP.val(90);
      }
      
      if (nap === 100) {
        const isDelayed = (t.planEndAt && t.actEndAt && t.actEndAt > t.planEndAt);
        newCode = isDelayed ? "WBSPLANSTS40" : "WBSPLANSTS50";
      } else if (nap > 0) {
        const isDelayed = (t.planEndAt && ((t.actEndAt && t.actEndAt > t.planEndAt) || (!t.actEndAt && today > t.planEndAt)));
        newCode = isDelayed ? "WBSPLANSTS30" : "WBSPLANSTS20";
      } else {
        newCode = "WBSPLANSTS10";
      }
      elS.val(newCode);
    }
    
    const ns = STS_NAME[newCode] || "TODO";
    const newTitle = $("#wbsPlanCodeNm").val();
    const nrf = $("#revisedFinishDt").val();
    
    // 지연 상태(WBSPLANSTS30/40)일 때 완료예정일/실적필드 강조
    const isDelayedStatus = (newCode === "WBSPLANSTS30" || newCode === "WBSPLANSTS40");
    $("#divRevisedFinishDt").css("display", (newCode === "WBSPLANSTS30") ? "grid" : "none");
    $("#wbsPlanStsCodeId, #revisedFinishDt, #wbsRsltsEDt").toggleClass("required-delayed", isDelayedStatus);

    if(t.title !== newTitle || t.status !== ns || t.wbsPlanStsCodeId !== newCode || t.actProgress !== nap || t.resultsCnts !== nr || t.wbsRsltsMh !== nem || t.revisedFinishDt !== nrf) {
      hideToast();
      t.title = newTitle;
      t.status = ns;
      t.wbsPlanStsCodeId = newCode;
      t.actProgress = nap;
      t.resultsCnts = nr;
      t.wbsRsltsMh = nem;
      t.revisedFinishDt = nrf;
      t._metaDirty = true;
      refreshSummariesOnly();
      renderTree();
      
      // 입력 중인 필드가 있으면 포커스와 IME 유지를 위해 renderDetail 생략
      const editingIds = ["wbsPlanCodeNm", "wbsRsltsCnts", "actProgress", "wbsRsltsMh"];
      if (document.activeElement && editingIds.includes(document.activeElement.id)) {
        const isActDirtyUnified = (t._actDirty || t._metaDirty);
        const isCommonDirty = (t._planDirty && isActDirtyUnified);

        $("#btnSaveAct")
          .toggleClass('highlight-blue', isActDirtyUnified)
          .prop("disabled", !isActDirtyUnified);
          
        $("#btnSaveMeta")
          .toggleClass('highlight-blue', isCommonDirty)
          .prop("disabled", !isCommonDirty);
      } else {
        renderDetail();
      }
    }
  };

  // Attach Listeners
  const detailInputs = "#wbsPlansDt, #wbsPlaneDt, #wbsRsltsSDt, #wbsRsltsEDt, #actProgress, #wbsPlanStsCodeId, #wbsRsltsCnts, #wbsRsltsMh, #wbsPlanCodeNm, #revisedFinishDt";
  $(detailInputs).on("focus", function() {
    pushUndoSnapshot();
  });

  $("#wbsPlansDt").on("input", syncPlan);
  $("#wbsPlaneDt").on("input", syncPlan);
  $("#wbsRsltsSDt").on("input", syncAct);
  $("#wbsRsltsEDt").on("input", syncAct);
  $("#actProgress").on("input", syncMeta);
  $("#wbsPlanStsCodeId").on("change", syncMeta);
  $("#calcProgress").on("input", syncMeta);
  $("#wbsRsltsCnts").on("input", syncMeta);
  $("#wbsRsltsMh").on("input", syncMeta); 
  $("#wbsPlanCodeNm").on("input", syncMeta); 
  $("#revisedFinishDt").on("input", syncMeta);
  $("#wbsPlanCodeNm").on("focus", function() { 
    $(this).css({background:"#fff", border:"1px solid #d1d5db"}); 
  });
  $("#wbsPlanCodeNm").on("blur", function() { $(this).css({background:"transparent", border:"1px solid transparent"}); });

  // PLAN 저장
  $("#btnSavePlan").on("click", ()=>{
  const prevStart = t.planStartAt;
  const prevEnd = t.planEndAt;

  const planStartRaw = $("#wbsPlansDt").val() || null;
  const planDur = Math.max(1, Number($("#daycnt").val()||1));

  const ns = planStartRaw ? nextWorkingDay(planStartRaw) : (t.planStartAt || nextWorkingDay(STATE.view.baseDate));
  const ne = addWorkingDays(ns, planDur - 1);

  commitDetailSave("PLAN", t.id, prevStart, prevEnd, ns, ne, planDur);
  $("#btnSavePlan").removeClass("highlight-blue");
});
// 실적→계획 동기화(요구 발생 빈도 높음)
  $("#btnSyncPlanFromAct").on("click", ()=>{
  const actS = t.actStartAt;
  const actE = t.actEndAt;
  
  if(!actS || !actE){
    setToast("실적(ACT) 데이터가 충분하지 않습니다. 시작일과 종료일을 모두 입력해주세요.", {type:"warn", autoHideMs:2500});
    return;
  }
  
  const ns = nextWorkingDay(actS);
  const ne = nextWorkingDay(actE);
  const dur = Math.max(1, diffWorkingDaysInclusive(ns, ne));
  
  const prevS = t.planStartAt;
  const prevE = t.planEndAt;

  // 1. 서버 저장 예약 및 알림 (applyPendingChange가 내부에서 호출됨)
  commitDetailSave("PLAN", t.id, prevS, prevE, ns, ne, dur);
});
// ACT 저장
  $("#btnSaveAct").on("click", ()=>{
  const prevStart = t.actStartAt;
  const prevEnd = t.actEndAt;

  const actStartRaw = $("#wbsRsltsSDt").val() || null;
  const actEndRaw = $("#wbsRsltsEDt").val() || null;
  const actProg = Math.min(100, Math.max(0, Number($("#actProgress").val()||0)));

  const ns = actStartRaw ? nextWorkingDay(actStartRaw) : (t.actStartAt || null);
  let ne = actEndRaw ? nextWorkingDay(actEndRaw) : (t.actEndAt || null);

  // 시작일만 있고 종료일이 없는 경우 종료일을 현재일자로 설정
  if(ns && !ne) ne = toYmd(new Date());

  if(ns && ne && diffDays(ns, ne) < 0){
    setToast("ACT 종료일이 시작일보다 빠릅니다. 확인 후 다시 저장하십시오.", {type:"err"});
    return;
  }

  t.actProgress = actProg;
  const dur = (ns && ne) ? Math.max(1, diffWorkingDaysInclusive(ns, ne)) : 1;

  commitDetailSave("ACT", t.id, prevStart, prevEnd, ns, ne, dur);
  $("#btnSaveAct").removeClass("highlight-blue");
});
// ACT 제거
  $("#btnClearAct").on("click", ()=>{
  if(!confirm('실적(ACT) 데이터를 제거하시겠습니까?')) return;
  
  const prevStart = t.actStartAt;
  const prevEnd = t.actEndAt;
  
  pushUndoSnapshot();
  const snap = snapshotTasks();
  
  // 프론트엔드에서 즉시 제거
  t.actStartAt = null;
  t.actEndAt = null;
  t.actProgress = 0;
  t.actDurationWd = 0;
  t.actWarnYn = "N";
  t._actDirty = true;
  
  refreshSummariesOnly();
  renderAll();
  
  startUndoWindow(5000);
  setToast("ACT 제거 중...", {type:"ok", canUndo:true});
  TOAST.lastAction = { snapshot: snap, pending: {taskId:t.id, barType:"ACT", editType:"CLEAR"}, saveFn: saveToServer };
  
  // 백엔드 저장
  (async ()=>{
    try{
      await saveToServer({
        taskId: t.id,
        barType: "ACT",
        editType: "CLEAR",
        normalizedStart: null,
        normalizedEnd: null,
        origStart: prevStart || "-",
        origEnd: prevEnd || "-"
      });
      
      t._actDirty = false;
      setToast("ACT 제거 완료", {type:"ok", canUndo:true, autoHideMs:2000});
      renderAll();
      
      // Push post-save snapshot to UNDO_STACK for Ctrl+Z
      pushUndoSnapshot();
    }catch(e){
      setToast("ACT 제거 실패 - [재시도] 또는 5초 내 [롤백] 가능", {type:"err", canUndo:true, canRetry:true});
    }
  })();
});
// 공통 저장
  $("#btnSaveMeta").on("click", ()=>{
  pushUndoSnapshot();
  const snap = snapshotTasks();

  // syncMeta가 실시간으로 t 객체를 업데이트하므로 별도 추출 없이 t를 직접 사용하거나, 
  // 마지막으로 UI 값을 다시 한번 t에 확실히 반영
  const ns = $("#wbsPlanStsCodeId").val();
  const nap = Math.min(100, Math.max(0, Number($("#actProgress").val()||0)));
  const nr = $("#wbsRsltsCnts").val();
  const nem = $("#wbsRsltsMh").val();
  
  t.status = ns;
  t.wbsPlanStsCodeId = STS_CODE[ns] || t.wbsPlanStsCodeId;
  t.actProgress = nap;
  t.resultsCnts = nr;
  t.wbsRsltsMh = nem;

  refreshSummariesOnly();
  renderAll();

  startUndoWindow(5000);
  setToast("저장 중...(공통)", {type:"ok", canUndo:true});
  TOAST.lastAction = { snapshot: snap, pending: {taskId:t.id, barType:"META", editType:"DETAIL_META"}, saveFn: saveToServer };

  (async ()=>{
    try{
      await saveToServer({
        taskId: t.id, 
        barType: "META", 
        editType: "DETAIL_META", 
        status: t.status, 
        progress: t.actProgress,
        resultsCnts: t.resultsCnts,
        expectMh: t.expectMh,
        wbsRsltsMh: t.wbsRsltsMh
      });
      
      // 백엔드에서 Plan + Act + Meta를 모두 처리하므로 모든 dirty 플래그 클리어
      t._metaDirty = false;
      t._planDirty = false;
      t._actDirty = false;

      // 실적 비교 원본값 갱신
      t._originalActStart = t.actStartAt || null;
      t._originalActEnd = t.actEndAt || null;
      
      setToast("공통 저장 완료 (PLAN/ACT/META)", {type:"ok", canUndo:true, autoHideMs:2000}); 
      
      // 버튼 하이라이트 제거
      $("#btnSaveMeta, #btnSavePlan, #btnSaveAct").removeClass("highlight-blue");
      
      // Push post-save snapshot to UNDO_STACK for Ctrl+Z
      pushUndoSnapshot();
      
      renderAll(); 
    }catch(e){
      setToast("공통 저장 실패 - [재시도] 또는 5초 내 [롤백] 가능", {type:"err", canUndo:true, canRetry:true});
    }
  })();
});

  $("#btnFocus").on("click", () => focusOnGanttTask(t.id));
}

/** 간트 차트에서 특정 TASK 위치로 스크롤 이동 (중앙 정렬) */
function focusOnGanttTask(taskId) {
  const t = STATE.tasks.get(taskId);
  if (!t) return;

  const wrap = $("#ganttWrap");
  if (!wrap.length) return;

  const taskList = getTaskListInTreeOrder();
  const idx = taskList.findIndex(r => r.t.id === taskId);
  if (idx < 0) return;

  // 세로축 중앙 정렬
  const rowH = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--rowH") || 44);
  const viewH = wrap.innerHeight();
  wrap.scrollTop(Math.max(0, idx * rowH - (viewH / 2) + (rowH / 2)));

  // 가로축 중앙 정렬
  const scrollTarget = t.planStartAt || t.actStartAt;
  if (scrollTarget) {
    const dayW = getDayW();
    const sIdx = diffDays(STATE.view.baseDate, scrollTarget);
    const dur = t.planDurationWd || t.actDurationWd || 1;
    const viewW = wrap.innerWidth();
    
    // 바의 중앙이 화면 중앙에 오도록 계산
    const barCenterOffset = (sIdx * dayW) + (dur * dayW / 2);
    wrap.scrollLeft(Math.max(0, barCenterOffset - (viewW / 2)));
  }
}

/** 좌측 트리에서 특정 TASK 위치로 스크롤 이동 */
function focusOnTreeTask(taskId) {
  const card = $(`.nodeCard[data-id="${taskId}"]`);
  if (!card.length) return;

  const wrap = card.closest(".bd");
  if (!wrap.length) return;

  // 세로축 중앙 정렬
  const wrapH = wrap.innerHeight();
  const cardTop = card.position().top; // wrap 기준으로 상대 위치
  const currentScroll = wrap.scrollTop();
  
  wrap.animate({
    scrollTop: currentScroll + cardTop - (wrapH / 2) + (card.outerHeight() / 2)
  }, 200);
}


function applyZoom(v) {
  const root = document.documentElement;
  root.style.setProperty("--dayW", v + "px");

  // 개별 요소 위치/너비 업데이트 (전체 renderGantt 회피)
  const dayW = parseInt(v);
  
  // 1. 헤더 월 라벨 너비 업데이트
  const months = [];
  const days = getTimelineDays();
  let curM = null;
  for(const d of days){
    const ym = d.substring(0, 7);
    if(!curM || curM.ym !== ym){
      curM = { ym, count: 0 };
      months.push(curM);
    }
    curM.count++;
  }
  
  const monthCells = document.querySelectorAll(".timeline-month");
  monthCells.forEach((c, i) => {
    if(months[i]) c.style.width = (months[i].count * dayW) + "px";
  });

  // 2. 일 셀 너비 업데이트
  const dayCells = document.querySelectorAll(".dayCell");
  dayCells.forEach(c => {
    c.style.width = dayW + "px";
    c.style.fontSize = `calc(${dayW}px * 0.45)`; // Update font size dynamically
  });

  // 3. 간트 라인 배경 그리드 업데이트
  $(".bgGrid .cell").css("width", dayW + "px");

  // 4. 간트 바 위치/너비 업데이트
  $(".bar").each(function() {
    const bar = $(this);
    const s = bar.attr("data-start");
    const e = bar.attr("data-end");
    if(!s || !e) return;
    const psIdx = diffDays(days[0], s);
    const peIdx = diffDays(days[0], e);
    bar.css({
      left: `${psIdx * dayW}px`,
      width: `${Math.max(1, (peIdx - psIdx + 1)) * dayW}px`
    });
  });

  // 5. TODAY 라인/배지 업데이트
  const today = toYmd(new Date());
  const todayIdx = diffDays(days[0], today);
  if(todayIdx >= 0 && todayIdx < days.length){
    $(".today-line").css("left", `${todayIdx * dayW}px`);
    $(".today-badge").css("left", `${todayIdx * dayW + dayW/2}px`);
  }
}

function renderAll(){
  updateGanttRange();
  renderTree();
  renderGantt();
  renderDetail();
}

/** ---------- Init ---------- */
function init(){
  loadWbsData(); 
  setToast("데이터 로딩 중...", { type:"ok", autoHideMs:1200 });
  refreshEditModeUI();

  // Zoom slider setup
  const elSlider = $("#zoomSlider");
  const elZoomVal = $("#zoomVal");
  
  // 초기 CSS 변수값 가져와 슬라이더 동기화
  const currentDayW = getDayW();
  elSlider.val(currentDayW);
  elZoomVal.text(currentDayW);

  elSlider.on("input", (e) => {
    const v = $(e.target).val();
    elZoomVal.text(v);
    applyZoom(v);
  });
  
  // 결재/첨부 팝업 (Global Handler)
  $("#btnApproveAttach").on("click", () => {
    if(!STATE.selectedId) {
      setToast("작업 대상(TASK)이 선택되지 않았습니다.", {type:"warn"});
      return;
    }
    const t = STATE.tasks.get(STATE.selectedId);
    if(!t) {
      setToast("유효하지 않은 TASK입니다.", {type:"warn"});
      return;
    }
    
    // 현재 상세 화면의 입력값들을 수집 (elDetail 내부)
    var paramObj = {};
    const inputs = elDetail.find("input, select, textarea");
    inputs.each(function () {
      const id = $(this).attr('id');
      if(id) paramObj[id + "_P"] = $(this).val();
    });
    
    // 기본 키 및 컨텍스트 추가
    paramObj["fileTrgtKey_P"] = t.fileTrgtKey;
    paramObj["wbsPlanCodeId_P"] = t.id;
    
    // 실적(ACT) 데이터가 저장되지 않은 경우 차단
    if (!t.rsltsFileTrgtKey) {
      setToast("실적(ACT)이 저장된 상태에서만 결재/첨부가 가능합니다.", {type:"warn"});
      return;
    }

    paramObj["actionType"] = "U";
    paramObj["rsltsFileTrgtKey_P"] = t.rsltsFileTrgtKey;
    paramObj["wbsPlanNo"] = t.wbsPlanNo;
    paramObj["wbsRsltsNo"] = t.wbsRsltsNo;

    // openSecondModal 호출 (WB2201P02.html)
    // 체크: openSecondModal이 없으면 openModal 등을 사용
    if(typeof openSecondModal === 'function') {
      openSecondModal("/static/html/user/wb/wb22/WB2201P02.html", 1200, 700, "WBS 실적등록", paramObj, function () {
         // loadWbsData(); 
      });
    } else {
      alert("팝업 함수(openSecondModal)를 찾을 수 없습니다.");
    }
  });

  $("#btnRecalc").on("click", ()=>{
    searchData();
  });

  $("#btnToday").on("click", ()=>{
    const today=toYmd(new Date());
    const idx=diffDays(STATE.view.baseDate, today);
    if(idx>=0 && idx<STATE.view.days){
      const wrap=$("#ganttWrap");
      const dayW = getDayW();
      wrap.scrollLeft(Math.max(0, idx*dayW - 200));
    }
  });

  $("#btnEditPlan").on("click", ()=>{ STATE.editMode="PLAN"; refreshEditModeUI(); });
  $("#btnEditAct").on("click", ()=>{ STATE.editMode="ACT"; refreshEditModeUI(); });

  $("#btnAddIssue").on("click", ()=>{
    const t = STATE.tasks.get(STATE.selectedId);
    if(!t) {
      setToast("선택된 TASK가 없습니다.", {type:"warn"});
    }

    // 실적(ACT) 데이터가 저장되지 않은 경우 차단
    if (!t.rsltsFileTrgtKey) {
      setToast("실적(ACT)이 저장된 상태에서만 문제 등록이 가능합니다.", {type:"warn"});
      return;
    }

    // 날짜 대시(-) 제거 (yyyymmdd 형식)
    const sDt = (t.actStartAt || "").replace(/-/g, "");
    const eDt = (t.actEndAt || "").replace(/-/g, "");

    var paramObj = {
      "actionType"      : "C4",
      "coCd"            : t.coCd || "GUN",
      "clntPjtNm"       : t.clntPjtNm || "",
      "clntNm"          : t.clntNm || "",
      "salesCd"         : t.salesCd || "",
      "wbsPlanNo"       : t.pPlanNo || t.wbsPlanNo || "",
      "wbsRsltsNo"      : t.pRsltsNo || t.wbsRsltsNo || "",
      "wbsPlanCodeKind" : t.wbsPlanCodeKind || "",
      "wbsPlanCodeId"   : t.wbsPlanCodeId || t.id || "",
      "wbsPlanCodeNm"   : t.title || t.wbsPlanCodeNm || "",
      "wbsMngNm"        : (t.assignees && t.assignees[0]) || t.wbsMngNm || "",
      "wbsRsltssDt"     : sDt,
      "wbsRsltseDt"     : eDt,
    };

    if(typeof openModal === 'function') {
      openModal("/static/html/user/wb/wb24/WB2401P11.html", 1200, 870, "WBS 실적문제등록", paramObj, function () {
        // 성공 시 데이터 재조회 (필요 시)
        loadWbsData();
      });
    } else {
      alert("openModal 함수를 찾을 수 없습니다.");
    }
  });

  // Ctrl+Z global shortcut
  $(window).on("keydown", (e) => {
    if (e.ctrlKey && e.key.toLowerCase() === "z") {
      e.preventDefault();
      popAndRestore();
    }
  });

  // WBS Tree Change Actions
  $("#btnAddTask").on("click", () => {
    const sel = STATE.tasks.get(STATE.selectedId);
    let pid = null;

    if(sel){
      // 최상위 단계(parentId: null) 아래 자식 레벨로 생성
      // 선택된 TASK가 최상위이면 바로 그 아래에, 하위이면 그 부모(최상위) 아래에 생성
      pid = (sel.parentId === null) ? sel.id : sel.parentId;
    } else {
      // 선택된 TASK가 없는 경우 첫 번째 최상위 단계를 찾아 그 아래에 생성
      const firstRoot = Array.from(STATE.tasks.values()).find(t => t.parentId === null);
      if(firstRoot) pid = firstRoot.id;
    }

    const parent = STATE.tasks.get(pid);

    // 새 ID 생성 로직: 부모ID + (형제 중 최대 순번 + 1)
    let nextSeq = 1;
    const siblings = Array.from(STATE.tasks.values()).filter(t => t.parentId === pid);
    if (siblings.length > 0) {
      const suffixes = siblings
        .map(s => {
          if (!s.id.startsWith(pid)) return 0;
          const suffixStr = s.id.substring(pid.length);
          // 숫자만 있는 경우 파싱 (01, 02 등)
          return /^\d+$/.test(suffixStr) ? parseInt(suffixStr, 10) : 0;
        })
        .filter(n => n > 0);
      
      if (suffixes.length > 0) {
        nextSeq = Math.max(...suffixes) + 1;
      }
    }
    
    // 2자리 숫자로 포맷팅 (01~99)
    const suffix = String(nextSeq).padStart(2, '0');
    const newId = pid + suffix;
    
    const newTask = {
      id: newId,
      parentId: pid,
      wbsPlanCodeKind: pid, // 부모 코드를 종류로 분류
      title: "신규 TASK",
      
      // 부모로부터 상속받거나 기본값 설정
      coCd: parent ? parent.coCd : ($("#coCd").val() || "GUN"),
      salesCd: parent ? parent.salesCd : ($("#salesCd_H").val() || ""),
      verNo: parent ? parent.verNo :"",
      wbsPlanNo: "",
      fileTrgtKey: "",

      wbsPlanMngId: parent ? parent.wbsPlanMngId :$("#userId").val(),
      
      planStartAt: parent ? parent.planStartAt : toYmd(new Date()),
      planEndAt: parent ? parent.planEndAt : toYmd(new Date()),
      planDurationWd: 1,
      status: "준비",
      wbsPlanStsCodeId: "WBSPLANSTS10",
      closeYn: "N",
      rsltsCloseYn: "N",
      
      pIssCnt: "0",
      rIssCnt: "0",
      seqSort: String(nextSeq),
      sortNo: nextSeq,
      seq: nextSeq,
      
      actProgress: 0,
      progress: 0,
      resultsCnts: "",
      
      assignees: parent ? (parent.assignees || []) :$("#useId").val(),
      _planDirty: true // 신규 추가는 계획(PLAN) 변경으로 간주
    };
    
    pushUndoSnapshot();
    STATE.tasks.set(newId, newTask);
    STATE.selectedId = newId;
    recalcPlanAll();
    renderAll();
    setToast("신규 TASK가 추가되었습니다.");
  });

  $("#btnRemoveTask").on("click", () => {
    const t = STATE.tasks.get(STATE.selectedId);
    if(!t) { alert("삭제할 TASK를 선택하세요."); return; }
    
    // 문제가 등록되었거나, 완료상태는 삭제할 수 없습니다.
    const hasIssues = STATE.issues && STATE.issues.some(i => i.taskId === t.id);
    if (hasIssues) {
      alert("문제가 등록된 TASK는 삭제할 수 없습니다.");
      return;
    }
   
    // 완료 상태(WBSPLANSTS50) 체크
    if (t.wbsPlanStsCodeId === "WBSPLANSTS50") {
      alert("완료된 TASK는 삭제할 수 없습니다.");
      return;
    }
    if(!confirm(`[${t.title}] TASK를 삭제하시겠습니까?`)) return;

    pushUndoSnapshot();

    // 하위 TASK 삭제 함수
    const deleteRecursive = (id) => {
      const children = Array.from(STATE.tasks.values()).filter(x => x.parentId === id);
      children.forEach(c => deleteRecursive(c.id));
      STATE.tasks.delete(id);
    };

    // Server-side delete
    const param = {
        fileTrgtKey: t.fileTrgtKey,
        wbsPlanCodeId: t.id,
        coCd: $("#coCd").val() || "GUN",
    };

    if(typeof postAjax === 'function' && t.fileTrgtKey) {
        postAjax("/user/wb/wb26/deleteWbsLevel2Gantt", param, null, function(res){
            if(res.resultCode == 200) {
                deleteRecursive(t.id);
                STATE.selectedId = null;
                recalcPlanAll();
                renderAll();
                setToast("삭제되었습니다.", {type:"ok"});
            } else {
                alert("삭제 실패: " + (res.resultMessage || "서버 오류"));
            }
        });
    } else {
        // Fallback or Mock
        deleteRecursive(t.id);
        STATE.selectedId = null;
        recalcPlanAll();
        renderAll();
        setToast("TASK가 삭제되었습니다.(화면자료)");
    }
  });

  $("#btnTaskTemplate").on("click", () => {
    const t = STATE.tasks.get(STATE.selectedId);
    if (!t) { alert("TASK를 선택하세요."); return; }

    const wbsPlanCodeId = (t.parentId === null) ? t.id : t.wbsPlanCodeKind;
    const wbsPlanCodeNm = (t.parentId === null) ? t.title : t.wbsPlanKindNm;
    const paramObj = {
      "wbsPlanCodeId" : wbsPlanCodeId,
      "wbsPlanCodeNm" : wbsPlanCodeNm,
      "userId" : $('#userId').val() || ''
    };
    
    if(typeof openSecondModal === 'function') {
      openSecondModal("/static/html/user/wb/wb06/WB0604P05.html", 450, 450, "TASK 템플릿 관리", paramObj, function (){
        // 팝업 후처리 필요 시 여기에 작성
      });
    } else {
      alert("공통 모달 함수를 찾을 수 없습니다 (백엔드 연동 전)");
    }
  });
}

    // 템플릿(팝업)으로부터 건네받은 목록을 TASK로 일괄 추가
    window.addTemplateTasks = function(templates) {
        if(!templates || !templates.length) return;
        
        // 1. 부모 노드 식별 (선택된 노드의 상위 그룹, 혹은 최상위)
        const sel = STATE.tasks.get(STATE.selectedId);
        let pid = null;
        if(sel){
          pid = (sel.parentId === null) ? sel.id : sel.parentId;
        } else {
          // 선택없으면 첫번째 최상위
          const firstRoot = Array.from(STATE.tasks.values()).find(t => t.parentId === null);
          if(firstRoot) pid = firstRoot.id;
        }
    
        if(!pid) { alert("추가할 위치(상위 단계)를 찾을 수 없습니다."); return; }
        const parent = STATE.tasks.get(pid);

        // 2. ID 채번 (형제 중 최대 순번 + 1)
        let nextSeq = 1;
        const siblings = Array.from(STATE.tasks.values()).filter(t => t.parentId === pid);
        if (siblings.length > 0) {
          const suffixes = siblings.map(s => {
              if (!s.id.startsWith(pid)) return 0;
              const suffixStr = s.id.substring(pid.length);
              return /^\d+$/.test(suffixStr) ? parseInt(suffixStr, 10) : 0;
            }).filter(n => n > 0);
          if (suffixes.length > 0) nextSeq = Math.max(...suffixes) + 1;
        }

        pushUndoSnapshot();

        // 3. Loop & Add
        let addedCount = 0;
        templates.forEach(tpl => {
             const suffix = String(nextSeq).padStart(2, '0');
             const newId = pid + suffix;
             
             const newTask = {
                id: newId,
                parentId: pid,
                wbsPlanCodeKind: pid,
                title: tpl.codeNm || "신규 TASK",
                
                coCd: parent ? parent.coCd : ($("#coCd").val() || "GUN"),
                salesCd: parent ? parent.salesCd : ($("#salesCd_H").val() || ""),
                verNo: parent ? parent.verNo : "",
                
                wbsPlanMngId: parent ? parent.wbsPlanMngId : ($("#userId").val() || ""),
                planStartAt: parent ? parent.planStartAt : toYmd(new Date()),
                planEndAt: parent ? parent.planEndAt : toYmd(new Date()),
                planDurationWd: 1,
                
                status: "준비",
                wbsPlanStsCodeId: "WBSPLANSTS10",
                closeYn: "N",
                rsltsCloseYn: "N",
                
                seqSort: String(nextSeq),
                sortNo: nextSeq,
                seq: nextSeq,
                
                actProgress: 0,
                progress: 0,
                resultsCnts: "",
                
                assignees: parent ? (parent.assignees || []) : [($("#userId").val() || "")],
                _planDirty: true // 신규 추가는 계획(PLAN) 변경으로 간주
             };
             
             STATE.tasks.set(newId, newTask);
             nextSeq++;
             addedCount++;
        });
        
        if(addedCount > 0) {
            recalcPlanAll();
            renderAll();
            setToast(addedCount + "건의 템플릿 TASK가 추가되었습니다.");
            
            // 마지막 추가된 아이템 선택
            const lastId = pid + String(nextSeq - 1).padStart(2, '0');
            STATE.selectedId = lastId;
            renderAll();
            focusOnTreeTask(lastId);
        }
    };

    //Sales Code 검색
    window.wbsSalesCodeSearch = function() {
      var paramObj = { "coCd" : $('#coCd_S').val(), "searchValue": $('#salesCd_S').val() };
      openSecondModal("/static/html/cmn/modal/wbsSalesCodeSearch.html", 1200, 700, "SALES CODE 검색", paramObj, function (grid){
        var row = grid.target.getList("selected")[0];

        if ($('#salesCd_S').val() !=  row.salesCd) {
	        $('#salesCd_S').val(row.salesCd);
	        searchData();
        }
      });
    };
    
$(function() {
  // URL 파라미터 추출
  const urlParams = new URLSearchParams(window.location.search);
  const salesCd = urlParams.get('salesCd') || "";
  const userId = urlParams.get('userId');
  const equpNm = urlParams.get('equpNm') || "";
  const userNm = (typeof jwt !== 'undefined') ? (jwt.userNm || "") : "";

  // 제목에 [salesCd, userNm] 정보 추가
  const subTitle = `WBS Task 관리 [${salesCd}${userNm ? ', ' + userNm : ''}${equpNm ? ', ' + equpNm : ''}]`;
  mainDefaultLoad("실행계획", subTitle);
  setCommonSelect($("#main_area select[data-kind]"));

  $('#head_area').toggleClass('off');
  $('#top_area').toggleClass('on');
  $('#main_area').toggleClass('on');

  // 파라미터가 있으면 해당 값으로 설정, 없으면 기존 기본값 유지
  if (salesCd) $('#salesCd_S').val(salesCd);
  if (userId) {
    // userId 처리가 필요한 경우 별도 input(hidden 등)이나 전역변수에 저장
    if ($('#userId').length === 0) {
      $('#main_area').append(`<input type="hidden" id="userId" value="${userId}">`);
    } else {
      $('#userId').val(userId);
    }
  }

  // 뒤로가기 시 목록 화면으로 이동
  history.pushState(top.location.href, null, top.location.href);
  window.addEventListener('popstate', function(event) {
      location.href = "/static/html/user/wb/wb06/WB0603M02.html";
  });

  init();
});
</script>
<div class="toastWrap" id="toastWrap"></div>
</body>
</html>
