<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì‚¬ìš©ì ì„ì˜ ì¡°ì •í˜• ëŒ€ì‹œë³´ë“œ (Split/Grid/Flow)</title>

  <!-- CDN libs -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/split.js@1.6.5/dist/split.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

  <style>
    :root{
      --bg:#f4f6fa;
      --panel:#ffffff;
      --line:#e5e9f2;
      --text:#1f2a37;
      --muted:#6b7280;
      --primary:#1d4ed8;
      --danger:#dc2626;
      --ok:#16a34a;
      --warn:#f59e0b;

      --gap:12px;
      --rowH:92px;
      --cols:12;

      --shadow: 0 10px 22px rgba(16,24,40,.08);
      --radius: 14px;
      --toolbarH: 54px;

      /* WB1001M01 equipment card look */
      --card-border: #2563eb;
      --card-head-bg: rgba(37, 99, 235, 0.08);
      --card-head-line: rgba(37, 99, 235, 0.25);
      --card-shadow: 0 10px 24px rgba(15, 23, 42, 0.10);
      --card-radius: 12px;
      --card-bg: #fff6d6;
      --card-border-warm: #f5b94a;
      --card-head-warm: #fde7b2;
      --card-text-warm: #5b4b2f;
      --card-ok: #4b7c5a;
      --card-issue: #c63d2f;
      
      --rulerSize: 30px;
      --rulerBg: #2c3e50;
      --rulerText: #ecf0f1;
      --rulerMark: #7f8c8d;
      --gridColor: rgba(99, 110, 114, 0.15);
      --gridSize: 10px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      color:var(--text);
      background:var(--bg);
      overflow:hidden;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
    }

    /* toolbar */
    .toolbar{
      height:var(--toolbarH);
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:#fff;
    }
    .toolbar .left{ display:flex; align-items:center; gap:8px; flex:1; }
    .toolbar .right{ display:flex; align-items:center; gap:8px; }
    .btn{
      appearance:none; border:1px solid var(--line); background:#fff;
      padding:8px 10px; border-radius:10px; cursor:pointer;
      font-size:13px; line-height:1;
    }
    .btn[disabled]{
      opacity:.6;
      cursor:not-allowed;
      filter:grayscale(0.3);
    }
    .btn:hover{ border-color:#cfd6e6; }
    .btn.primary{ background:var(--primary); color:#fff; border-color:var(--primary); }
    .btn.danger{ background:var(--danger); color:#fff; border-color:var(--danger); }
    .btn.active{ outline:2px solid rgba(29,78,216,.22); border-color: rgba(29,78,216,.35); }
    .pill{
      font-size:12px; color:var(--muted);
      padding:6px 10px; border:1px solid var(--line);
      border-radius:999px; background:#fff;
    }
    .sep{ width:1px; height:24px; background:var(--line); margin:0 4px; }

    /* main */
    .main{
      flex:1;
      min-height:0;
      display:flex;
      position: relative;
    }
    
    /* Rulers and Grid */
    .ruler-corner{
      position: absolute;
      top: 0;
      left: 0;
      width: var(--rulerSize);
      height: var(--rulerSize);
      background: var(--rulerBg);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--rulerText);
      font-size: 10px;
      font-weight: 700;
      border-right: 1px solid rgba(255,255,255,0.1);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .ruler-horizontal{
      position: absolute;
      top: 0;
      left: var(--rulerSize);
      right: 0;
      height: var(--rulerSize);
      background: var(--rulerBg);
      z-index: 99;
      overflow: hidden;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .ruler-vertical{
      position: absolute;
      top: var(--rulerSize);
      left: 0;
      bottom: 0;
      width: var(--rulerSize);
      background: var(--rulerBg);
      z-index: 99;
      overflow: hidden;
      border-right: 1px solid rgba(255,255,255,0.1);
    }
    
    .ruler-marks{
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .ruler-mark{
      position: absolute;
      background: var(--rulerMark);
    }
    
    .ruler-horizontal .ruler-mark{
      width: 1px;
      height: 8px;
      bottom: 0;
    }
    
    .ruler-horizontal .ruler-mark.major{
      height: 14px;
      background: var(--rulerText);
    }
    
    .ruler-horizontal .ruler-mark.minor{
      height: 5px;
    }
    
    .ruler-vertical .ruler-mark{
      width: 8px;
      height: 1px;
      right: 0;
    }
    
    .ruler-vertical .ruler-mark.major{
      width: 14px;
      background: var(--rulerText);
    }
    
    .ruler-vertical .ruler-mark.minor{
      width: 5px;
    }
    
    .ruler-label{
      position: absolute;
      color: var(--rulerText);
      font-size: 9px;
      font-weight: 600;
      font-family: 'Courier New', monospace;
      user-select: none;
      pointer-events: none;
    }
    
    .ruler-horizontal .ruler-label{
      top: 2px;
      transform: translateX(-50%);
    }
    
    .ruler-vertical .ruler-label{
      left: 2px;
      transform: translateY(-50%);
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }
    
    .grid-background{
      display:none;
      position: absolute;
      top: var(--rulerSize);
      left: var(--rulerSize);
      right: 0;
      bottom: 0;
      background-image: 
        linear-gradient(var(--gridColor) 1px, transparent 1px),
        linear-gradient(90deg, var(--gridColor) 1px, transparent 1px);
      background-size: var(--gridSize) var(--gridSize);
      background-position: 0 0;
      pointer-events: none;
      z-index: 1;
    }

    .grid-layer{
      position:absolute;
      inset:0;
      background-image: 
        linear-gradient(var(--gridColor) 1px, transparent 1px),
        linear-gradient(90deg, var(--gridColor) 1px, transparent 1px);
      background-size: var(--gridSize) var(--gridSize);
      background-position: 0 0;
      pointer-events:none;
      z-index:0;
    }

    /* split root */
    #splitRoot{
      flex:1;
      min-width:0;
      min-height:0;
      display:flex;
      height:100%;
      margin-top: var(--rulerSize);
      margin-left: var(--rulerSize);
      position: relative;
      z-index: 10;
    }
    .pane{
      min-width:100px;
      min-height:0;
      overflow:auto;
      padding: 2px;
    }
    #splitRoot.split-row .pane,
    #splitRoot.split-col .pane{
      flex: 0 0 auto;
    }
    #splitRoot.single-pane .pane{
      flex: 1 1 auto;
      width: 100%;
      min-width: 0;
    }
    #splitRoot.split-col .pane{
      min-height:0;
    }
    .paneHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin: 0 0 2px 0;
      padding: 8px 10px;
      border:1px solid var(--line);
      border-radius: 12px;
      background:#fff;
      box-shadow: 0 4px 14px rgba(16,24,40,.05);
    }
    .paneHeader .title{
      font-size:13px;
      font-weight:700;
      color:var(--text);
    }
    .paneHeader .meta{
      font-size:12px;
      color:var(--muted);
    }

    /* Split.js gutter */
    .gutter{
      background: linear-gradient(180deg, #ffffff, #ffffff);
      border-left:1px solid var(--line);
      border-right:1px solid var(--line);
      position:relative;
      flex: 0 0 auto;
    }
    .gutter.gutter-horizontal{
      cursor:col-resize;
      width:10px;
    }
    .gutter.gutter-vertical{
      cursor:row-resize;
      height:10px;
      width:100%;
    }
    .gutter::after{
      content:"";
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      width:4px; height:40px;
      border-radius:999px;
      background:#d7deec;
    }
    .gutter.gutter-vertical::after{
      width:40px; height:4px;
    }
    .no-edit .gutter{
      pointer-events:none;
      cursor:default;
    }

    /* dashboards */
    .dashboard{
      position:relative;
      min-height: 2000px;
      width: 100%;
    }


    /* Grid */
    .dashboard.grid{
      position: relative;
      min-height: 2000px;
    }

    /* Flow (?ë“­ë€¡) */
    .dashboard.flow{
      display:flex;
      flex-wrap:wrap;
      gap: var(--gap);
      align-content:flex-start;
    }
    .dashboard.flow .panel{
      position:relative !important;
      width: calc((100% - (var(--gap) * 2)) / 3);
      min-width: 260px;
      height: calc(var(--rowH) * 2);
    }

    /* Panel card */
    .panel{
      background:var(--card-bg);
      border:2px solid var(--card-border-warm);
      border-radius:var(--card-radius);
      box-shadow: 0 8px 16px rgba(91, 75, 47, 0.15);
      overflow:hidden;
      position:absolute;
      user-select:none;
      touch-action:none;
      min-width: 100px;
      min-height: 100px;
      padding: 0;
    }
    .panel[data-type="Image"]{
      border: 1px solid #b0b0b0;
      min-width: 10px;
      min-height: 10px;
    }
    
    /* Scale panel content to fit panel size */
    .panel .panelBody{
      transform-origin: top left;
      width: 100%;
      height: 100%;
    }
    .panel.dragging{ opacity:.78; box-shadow: 0 14px 32px rgba(16,24,40,.12); }
    .panel.selected{ outline: 3px solid rgba(29,78,216,.25); }

    /* Panel header */
    .panelHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 8px;
      border-bottom:1px solid var(--card-border-warm);
      background: var(--card-head-warm);
      position:relative;
    }
    .headLeft{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .pIcon{
      width:22px; height:22px;
      display:grid; place-items:center;
      border-radius:999px;
      background:#fff1c4;
      border:1px solid rgba(245,185,74,.6);
      flex:0 0 auto;
      font-size:12px;
    }
    .pTitle{
      font-size:12px;
      font-weight:800;
      color: var(--card-text-warm);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 260px;
    }
    .headRight{
      display:flex;
      align-items:center;
      gap:0px;
      position:absolute;
      right:6px;
      top:2px;
      z-index:2;
    }
    .iconBtn{
      height:24px;
      padding:0 6px;
      width:auto;
      border-radius:999px;
      border:1px solid rgba(91,75,47,.25);
      background:#fff7df;
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size:12px;
      color: var(--card-text-warm);
    }
    .iconBtn:hover{ border-color:#cfd6e6; }
    .badge{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(91,75,47,.22);
      color:var(--card-text-warm);
      background:#fff1c4;
    }
    .badge.badge-Worklog{
      background:#e7f0ff;
      border-color:#c7dbff;
      color:#1e3a8a;
    }
    .badge.badge-Progress{
      background:#e7f6ec;
      border-color:#cfe9d7;
      color:#166534;
    }
    .badge.badge-Issues{
      background:#fde2e2;
      border-color:#f5b5b5;
      color:#991b1b;
    }
    .badge.badge-Composite{
      background:#f3e8ff;
      border-color:#e3d1ff;
      color:#6b21a8;
    }

    .panel.compact .badge{
      display:none;
    }

    /* Body */
    .panelBody{
      padding:8px 10px 10px 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      height: calc(100% - 40px);
      font-size:12px;
    }
    .panelBody.imageBody{
      padding:0;
      height: 100%;
    }
    .panelBody.imageBody img{
      width:100%;
      height:100%;
      object-fit:fill;
      border-radius:10px;
      background:#fffdf1;
      border:1px solid rgba(91,75,47,.15);
    }
    .cardSummary{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:11px;
      color: var(--card-text-warm);
    }
    .cardMeta{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:2px;
    }
    .cardBadges{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .cardBadge{
      font-size:10px;
      font-weight:800;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(91,75,47,.22);
      background:#fff1c4;
      color: var(--card-text-warm);
    }
    .cardBadge.ok{
      background:#e7f3ea;
      border-color:#cfe5d5;
      color: var(--card-ok);
    }
    .cardBadge.issue{
      background:#fde2df;
      border-color:#f4b7b1;
      color: var(--card-issue);
    }
    .cardRow{
      display:flex;
      gap:6px;
      align-items:center;
      font-size:11px;
    }
    .cardRow.split{
      justify-content:space-between;
      gap:10px;
    }
    .cardRow.split .pair{
      display:flex;
      align-items:center;
      gap:6px;
      flex:0 0 60%;
      min-width:0;
    }
    .cardRow.split .pair.secondary{
      flex:0 0 40%;
      justify-content:flex-start;
    }
    .cardRow .label{
      color:#7a694c;
      font-weight:700;
      min-width:58px;
    }
    .cardRow .value{
      color: var(--card-text-warm);
      font-weight:700;
    }
    .cardFoot{
      margin-top:2px;
      font-size:10px;
      color:#8b7a5f;
    }
    .section{
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      background:#fff;
    }
    .sectionTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:8px;
      font-weight:800;
      font-size:12px;
      color:var(--text);
    }
    .muted{ color:var(--muted); font-weight:600; font-size:12px; }

    .list{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .li{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--text);
      padding:6px 8px;
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
    }
    .li .left{
      display:flex; align-items:center; gap:8px; min-width:0;
    }
    .li .dot{
      width:10px; height:10px; border-radius:999px;
      background:#c7d2fe;
      border:1px solid rgba(29,78,216,.25);
      flex:0 0 auto;
    }
    .li .txt{
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width: 240px;
    }
    .li .time{
      font-size:11px; color:var(--muted); white-space:nowrap;
    }

    .kpiRow{
      display:flex;
      gap:10px;
      align-items:stretch;
    }
    .kpi{
      flex:1;
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      background:#fff;
    }
    .kpi .lbl{ font-size:11px; color:var(--muted); font-weight:700; }
    .kpi .val{ font-size:22px; font-weight:900; margin-top:4px; }
    .barWrap{
      height:10px;
      border-radius:999px;
      background:#eef2ff;
      border:1px solid rgba(29,78,216,.16);
      overflow:hidden;
      margin-top:10px;
    }
    .bar{
      height:100%;
      background: linear-gradient(90deg, rgba(29,78,216,.85), rgba(99,102,241,.85));
      width:0%;
    }

    .counts{
      display:flex;
      gap:10px;
    }
    .count{
      flex:1;
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      background:#fff;
    }
    .count .lbl{ font-size:11px; color:var(--muted); font-weight:800; }
    .count .val{ font-size:20px; font-weight:900; margin-top:4px; }
    .theme-ok .pIcon{ background: rgba(22,163,74,.08); border-color: rgba(22,163,74,.25); }
    .theme-warn .pIcon{ background: rgba(245,158,11,.10); border-color: rgba(245,158,11,.25); }
    .theme-danger .pIcon{ background: rgba(220,38,38,.10); border-color: rgba(220,38,38,.25); }
    /* Bootstrap-like theme mapping */
    .theme-ok{
      background:#d1e7dd;
      border-color:#0f5132;
    }
    .theme-ok .panelHead{
      background:#badbcc;
      border-color:#0f5132;
    }
    .theme-ok .pTitle,
    .theme-ok .badge{ color:#0f5132; }

    .theme-warn{
      background:#fff3cd;
      border-color:#664d03;
    }
    .theme-warn .panelHead{
      background:#ffecb5;
      border-color:#664d03;
    }
    .theme-warn .pTitle,
    .theme-warn .badge{ color:#664d03; }

    .theme-danger{
      background:#f8d7da;
      border-color:#842029;
    }
    .theme-danger .panelHead{
      background:#f5c2c7;
      border-color:#842029;
    }
    .theme-danger .pTitle,
    .theme-danger .badge{ color:#842029; }
    .panel:not(.theme-ok):not(.theme-warn):not(.theme-danger){
      background:#f8f9fa;
      border-color:#adb5bd;
    }
    .panel:not(.theme-ok):not(.theme-warn):not(.theme-danger) .panelHead{
      background:#e9ecef;
      border-color:#adb5bd;
    }

    /* resize handle hint */
    .resizeHint{
      position:absolute;
      right:8px; bottom:8px;
      width:16px; height:16px;
      opacity:.55;
      background:
        linear-gradient(135deg, transparent 50%, rgba(148,163,184,.85) 50%),
        linear-gradient(135deg, transparent 64%, rgba(148,163,184,.55) 64%);
      clip-path: polygon(0 100%, 100% 100%, 100% 0);
      pointer-events:none;
    }

    /* context menu */
    .ctx{
      position:fixed;
      z-index:9999;
      min-width: 180px;
      background:#fff;
      border:1px solid var(--line);
      border-radius:12px;
      box-shadow: 0 18px 42px rgba(16,24,40,.14);
      padding:6px;
      display:none;
    }
    .ctx .item{
      padding:10px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .ctx .item:hover{ background:#f6f8ff; }
    .ctx .hint{ font-size:11px; color:var(--muted); }
    .ctx .danger{ color: var(--danger); }

    /* modal */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(17,24,39,.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10000;
      padding: 14px;
    }
    .modal{
      width:min(920px, 96vw);
      max-height: 90vh;
      overflow:auto;
      background:#fff;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.55);
      box-shadow: 0 26px 70px rgba(16,24,40,.26);
      padding:14px;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:6px 6px 12px 6px;
      border-bottom:1px solid var(--line);
      margin-bottom:12px;
    }
    .modalHead .ttl{ font-weight:900; }
    .refreshControls{
      display:flex;
      align-items:center;
      gap:2px;
      font-size:12px;
      color:var(--muted);
    }
    .refreshControls input[type="number"]{
      width:80px;
      padding:1px 1px;
      border-radius:8px;
      border:1px solid var(--line);
      font: inherit;
    }
    #fRefreshMin{
      width:30px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .field{
      display:flex; flex-direction:column; gap:3px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
    }
    .field.rowField{
      flex-direction:row;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding-top:1px;
      padding-bottom:1px;
    }
    .field.rowField label{
      flex:0 0 30%;
      font-weight:800;
      text-align:right;
    }
    .field.rowField .control{
      flex:0 0 70%;
      display:flex;
      justify-content:flex-end;
    }
    .field.rowField .control input,
    .field.rowField .control select{
      width:100%;
    }
    .rowColors{
      grid-column: 1 / -1;
      display:flex;
      gap:12px;
    }
    .rowColors .field{
      flex:1;
    }
    .labelRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .colorInput{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0, 0, 0, 0);
      white-space:nowrap;
      border:0;
    }
    .colorSwatchInput{
      width:40px;
      height:20px;
      border-radius:0;
      border:2px solid var(--line);
      background:#fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.5);
      display:inline-block;
      position:relative;
    }
    .colorSwatchInner{
      position:absolute;
      top:50%;
      left:50%;
      width:70%;
      height:70%;
      transform:translate(-50%, -50%);
      border:1px solid rgba(0,0,0,.15);
      background:#fff;
    }
    .field label{
      font-size:12px; font-weight:800; color:var(--text);
    }
    .field input, .field select, .field textarea{
      font: inherit;
      padding:1px;
      border-radius:10px;
      border:1px solid var(--line);
      outline:none;
    }
    .field input, .field select{
      height:28px;
    }
    .field textarea{ min-height: 220px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .modalFoot{
      display:flex; justify-content:flex-end; gap:8px;
      padding-top:12px;
      border-top:1px solid var(--line);
      margin-top:12px;
    }
    #helpBack .li .txt{
      white-space:normal;
      overflow:visible;
      text-overflow:clip;
      max-width:none;
    }

    /* drop hints */
    .dropTarget{
      outline:3px dashed rgba(29,78,216,.35);
      outline-offset:-6px;
    }
    .mergeArmed{
      border-color: rgba(29,78,216,.55) !important;
      box-shadow: 0 0 0 4px rgba(29,78,216,.18), var(--shadow);
    }
  </style>
</head>

<body>
<div class="app">
  <div class="toolbar">
    <div class="left">
      <div class="refreshControls">
        <span>refresh:</span>
        <input id="fRefreshMin" type="number" min="1" step="1" value="5" />
        <span>ë¶„</span>
        <label><input id="fRefreshOn" type="checkbox" />ì‚¬ìš©</label>
      </div>
      <span class="pill" id="helpHint">íŒ: Shift+ë“œë = Merge</span>
      <span class="pill" id="gridInfo">Snap: 10px | Grid: 10px | Ruler: ON</span>
      <button class="btn" id="btnHelp">ë„ì›€ë§</button>
    </div>
    
    <div class="right">
      <button class="btn" id="btnGrid">Grid</button>
      <button class="btn active" id="btnSplit">Split</button>
      <button class="btn" id="btnFlow">Flow</button>

      <span class="sep"></span>

      <button class="btn" id="btnDir">Split: ì¢Œ/ìš°</button>
      <button class="btn" id="btnPanes">Pane: 2</button>

      <span class="sep"></span>

      <button class="btn primary" id="btnAdd">+ íŒ¨ë„ ì¶”ê°€</button>
      <button class="btn" id="btnAuto">ìë™ë°°ì¹˜</button>
      <button class="btn" id="btnUndo">Undo</button>
      <button class="btn" id="btnExport">ë‚´ë³´ë‚´ê¸°(JSON)</button>
      <button class="btn" id="btnImport">ê°€ì ¸ì˜¤ê¸°(JSON)</button>
      <button class="btn danger" id="btnReset">ì´ˆê¸°í™”</button>

      <span class="sep"></span>
      <span class="pill" id="saveState">ì €ì¥ë¨</span>
    </div>
  </div>

  <div class="main">
    <!-- Rulers and Grid -->
    <div class="ruler-corner">ğŸ“</div>
    <div class="ruler-horizontal">
      <div class="ruler-marks" id="rulerHorizontalMarks"></div>
    </div>
    <div class="ruler-vertical">
      <div class="ruler-marks" id="rulerVerticalMarks"></div>
    </div>
    <div class="grid-background"></div>
    
    <div id="splitRoot"></div>
  </div>
</div>

<!-- Context menu -->
<div class="ctx" id="ctxMenu">
  <div class="item" data-act="settings">âš™ ì„¤ì • <span class="hint">Enter</span></div>
  <div class="item" data-act="copy">ğŸ“‹ ë³µì‚¬ <span class="hint">Duplicate</span></div>
  <div class="item" data-act="zFront">â¬† ë§¨ì•ìœ¼ë¡œ <span class="hint">Front</span></div>
  <div class="item" data-act="zBack">â¬‡ ë§¨ë’¤ë¡œ <span class="hint">Back</span></div>
  <div class="item" data-act="splitH">â†” ë…¼ë¦¬ ë¶„ë¦¬(ê°€ë¡œ) <span class="hint">Split</span></div>
  <div class="item" data-act="splitV">â†• ë…¼ë¦¬ ë¶„ë¦¬(ì„¸ë¡œ) <span class="hint">Split</span></div>
  <div class="item" data-act="armMerge">ğŸ§© Merge ëŒ€ê¸° <span class="hint">ë‹¤ë¥¸ íŒ¨ë„ í´ë¦­</span></div>
  <div class="item danger" data-act="remove">ğŸ—‘ ì‚­ì œ</div>
</div>

<!-- Modal -->
<div class="modalBack" id="modalBack" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHead">
      <div class="ttl" id="modalTitle">íŒ¨ë„ ì„¤ì •</div>
      <button class="btn" id="modalClose">ë‹«ê¸°</button>
    </div>

    <div class="grid2">
      <div class="field rowField">
        <label for="fTitle">ì œëª© :</label>
        <div class="control"><input id="fTitle" type="text" /></div>
      </div>

      <div class="field rowField">
        <label for="fType">íƒ€ì… :</label>
        <div class="control">
          <select id="fType">
            <option value="Worklog">Worklog</option>
            <option value="Progress">Progress</option>
            <option value="Issues">Issues</option>
            <option value="Composite">Composite</option>
          </select>
        </div>
      </div>

      <div class="field rowField">
        <label for="fIcon">ì•„ì´ì½˜ :</label>
        <div class="control"><select id="fIcon"></select></div>
      </div>

      <div class="field rowField">
        <label for="fTheme">í…Œë§ˆ :</label>
        <div class="control">
          <select id="fTheme">
            <option value="default">default</option>
            <option value="ok">ok</option>
            <option value="warn">warn</option>
            <option value="danger">danger</option>
          </select>
        </div>
      </div>

      <div class="field rowField" id="compositeLayoutRow">
        <label for="fCompositeLayout">ì„¹ì…˜ ë°°ì¹˜ :</label>
        <div class="control">
          <select id="fCompositeLayout">
            <option value="stack">ì„¹ì…˜ì„¸ë¡œë°°ì¹˜</option>
            <option value="twoColumn">ì„¹ì…˜ê°€ë¡œë°°ì¹˜</option>
          </select>
        </div>
      </div>

      <div class="field rowField">
        <label for="fSalesCd">SalesCd :</label>
        <div class="control"><select id="fSalesCd"></select></div>
      </div>

      <div class="rowColors">
        <div class="field rowField">
          <label for="fColor">íŒ¨ë„ ìƒ‰ìƒ :</label>
          <div class="control">
          <label for="fColor">
            <span class="colorSwatchInput" id="fColorSwatch" aria-hidden="true">
              <span class="colorSwatchInner" id="fColorInner"></span>
            </span>
          </label>
          </div>
          <input id="fColor" class="colorInput" type="color" />
        </div>

        <div class="field rowField">
          <label for="fBorderColor">í…Œë‘ë¦¬ ìƒ‰ìƒ :</label>
          <div class="control">
          <label for="fBorderColor">
            <span class="colorSwatchInput" id="fBorderColorSwatch" aria-hidden="true">
              <span class="colorSwatchInner" id="fBorderColorInner"></span>
            </span>
          </label>
          </div>
          <input id="fBorderColor" class="colorInput" type="color" />
        </div>
      </div>

      <div class="field" style="grid-column: 1 / -1;">
        <label>ë°ì´í„°(JSON)</label>
        <textarea id="fData"></textarea>
        <div class="muted" id="dataHint">ìœ íš¨í•œ JSONë§Œ ì €ì¥ë©ë‹ˆë‹¤. Compositeì˜ ê²½ìš° composite.sections/dataë¥¼ í¸ì§‘í•˜ì„¸ìš”.</div>
      </div>
    </div>

    <div class="modalFoot">
      <button class="btn" id="btnValidate">JSON ê²€ì¦</button>
      <button class="btn primary" id="btnSave">ì €ì¥</button>
    </div>
  </div>
</div>

<!-- Export/Import Modal -->
<div class="modalBack" id="jsonBack" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHead">
      <div class="ttl" id="jsonTitle">ë ˆì´ì•„ì›ƒ JSON</div>
      <button class="btn" id="jsonClose">ë‹«ê¸°</button>
    </div>

    <div class="field">
      <label>JSON</label>
      <textarea id="jsonArea" style="min-height: 420px;"></textarea>
      <div class="muted" id="jsonHint"></div>
    </div>

    <div class="modalFoot">
      <button class="btn" id="jsonCopy">ë³µì‚¬</button>
      <button class="btn primary" id="jsonApply">ì ìš©</button>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div class="modalBack" id="helpBack" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHead">
      <div class="ttl">ì‚¬ìš©ì ì‘ì—… ë„ì›€ë§</div>
      <button class="btn" id="helpClose">ë‹«ê¸°</button>
    </div>
    <div class="field">
      <label>ìƒë‹¨ ë²„íŠ¼ ê¸°ëŠ¥ ì„¤ëª…</label>
      <div class="list">
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Grid: ëª¨ë“  Paneì˜ íŒ¨ë„ì„ í•˜ë‚˜ì˜ ê·¸ë¦¬ë“œ ìº”ë²„ìŠ¤ë¡œ ëª¨ì•„ ë°°ì¹˜í•©ë‹ˆë‹¤.</span></div><span class="time">Layout</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Split: Pane ë¶„í• (ì¢Œ/ìš° ë˜ëŠ” ìƒ/í•˜) ìƒíƒœì—ì„œ ê° Paneì— íŒ¨ë„ì„ ë°°ì¹˜í•©ë‹ˆë‹¤.</span></div><span class="time">Layout</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Flow: íŒ¨ë„ì„ ì¹´ë“œ ëª©ë¡ì²˜ëŸ¼ ìœ ë™ ë ˆì´ì•„ì›ƒìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤.</span></div><span class="time">Layout</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Split: ì¢Œ/ìš°/ìƒ/í•˜ ì „í™˜ ë²„íŠ¼ â€” Split ëª¨ë“œì˜ ë¶„í•  ë°©í–¥ì„ ë°”ê¿‰ë‹ˆë‹¤.</span></div><span class="time">Split</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Pane: 2/3 ì „í™˜ â€” Split ëª¨ë“œì˜ Pane ìˆ˜ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.</span></div><span class="time">Split</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">+ íŒ¨ë„ ì¶”ê°€: ê¸°ë³¸ íŒ¨ë„ì„ ìƒì„±í•˜ê³  ì²« Paneì— ë°°ì¹˜í•©ë‹ˆë‹¤.</span></div><span class="time">Add</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ìë™ë°°ì¹˜: ëª¨ë“  íŒ¨ë„ì„ ì¼ì • ê°„ê²©ìœ¼ë¡œ ì¬ì •ë ¬í•©ë‹ˆë‹¤.</span></div><span class="time">Arrange</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Undo: ì§ì „ ë³€ê²½ì„ ë˜ëŒë¦½ë‹ˆë‹¤.</span></div><span class="time">Undo</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°: í˜„ì¬ ë ˆì´ì•„ì›ƒì„ JSONìœ¼ë¡œ ì €ì¥/ë³µì›í•©ë‹ˆë‹¤.</span></div><span class="time">JSON</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ì´ˆê¸°í™”: ì €ì¥ëœ ë ˆì´ì•„ì›ƒì„ ì‚­ì œí•˜ê³  ì´ˆê¸° ìƒíƒœë¡œ ë³µê·€í•©ë‹ˆë‹¤.</span></div><span class="time">Reset</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Refresh(ë¶„): ì²´í¬ ì‹œ ì…ë ¥í•œ ë¶„ ê°„ê²©ìœ¼ë¡œ íŒ¨ë„ ë°ì´í„°ë¥¼ ìë™ ê°±ì‹ í•©ë‹ˆë‹¤.</span></div><span class="time">Auto</span></div>
      </div>
    </div>
    <div class="field">
      <label>íŒ¨ë„ ìƒì„¸ ê²°ê³¼(ë³¸ë¬¸) ì„¤ëª…</label>
      <div class="list">
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">SalesCd/PM/ê¸°ê°„/ì¼ì •ìƒíƒœ: ì—…ë¬´ ì‹ë³„, ë‹´ë‹¹ì, ê¸°ê°„, ì§„í–‰ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.</span></div><span class="time">Summary</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Worklog: ìµœê·¼ ì‘ì—… ëª©ë¡ê³¼ ì‹œê°„ ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.</span></div><span class="time">Worklog</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Progress: ì§„í–‰ë¥ (%)ê³¼ KPI ê°’ì„ í‘œì‹œí•©ë‹ˆë‹¤.</span></div><span class="time">Progress</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Issues: Open/Closed, Sev1/Sev2 ìš”ì•½ì„ í‘œì‹œí•©ë‹ˆë‹¤.</span></div><span class="time">Issues</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Composite: ì—¬ëŸ¬ ì„¹ì…˜ì„ í•©ì³ í•˜ë‚˜ì˜ ì¹´ë“œë¡œ í‘œì‹œí•©ë‹ˆë‹¤.</span></div><span class="time">Composite</span></div>
      </div>
    </div>
    <div class="field">
      <label>ì¡°ì‘ ë°©ë²•(ìƒì„¸)</label>
      <div class="list">
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ì´ë™: íŒ¨ë„ì„ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. (Snap ê°„ê²© ì ìš©)</span></div><span class="time">Drag</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ë¦¬ì‚¬ì´ì¦ˆ: íŒ¨ë„ ìš°í•˜ë‹¨ì„ ë“œë˜ê·¸í•˜ì—¬ í¬ê¸°ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.</span></div><span class="time">Resize</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ì„¤ì • ì—´ê¸°: íŒ¨ë„ ë”ë¸”í´ë¦­ ë˜ëŠ” âš™ ë²„íŠ¼ í´ë¦­.</span></div><span class="time">Settings</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ë³µì‚¬: ìš°í´ë¦­ ë©”ë‰´ â€˜ë³µì‚¬â€™ ë˜ëŠ” Ctrl+C â†’ Ctrl+V.</span></div><span class="time">Copy</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ë³‘í•©: Shift ëˆ„ë¥¸ ìƒíƒœë¡œ ë‹¤ë¥¸ íŒ¨ë„ì— ë“œë¡­í•˜ê±°ë‚˜ â€˜Merge ëŒ€ê¸°â€™ ì‚¬ìš©.</span></div><span class="time">Merge</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ë¶„ë¦¬: ìš°í´ë¦­ ë©”ë‰´ì—ì„œ ë…¼ë¦¬ ë¶„ë¦¬(ê°€ë¡œ/ì„¸ë¡œ)ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.</span></div><span class="time">Split</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">Z-ìˆœì„œ: ìš°í´ë¦­ ë©”ë‰´ì—ì„œ ë§¨ì•/ë§¨ë’¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.</span></div><span class="time">Z-Order</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">ì‚­ì œ: ìš°í´ë¦­ ë©”ë‰´ â€˜ì‚­ì œâ€™ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.</span></div><span class="time">Delete</span></div>
        <div class="li"><div class="left"><span class="dot"></span><span class="txt">JSON í¸ì§‘: ì„¤ì • ëª¨ë‹¬ì—ì„œ ì „ì²´ ìƒíƒœ JSONì„ ì§ì ‘ ìˆ˜ì • ê°€ëŠ¥í•©ë‹ˆë‹¤.</span></div><span class="time">JSON</span></div>
      </div>
    </div>
    <div class="modalFoot">
      <button class="btn primary" id="helpOk">í™•ì¸</button>
    </div>
  </div>
</div>

<script>
$(function(){
/* =========================
   0) Utilities
========================= */
const LS_KEY = "DASH_LAYOUT_V2";
const ICONS = ["ğŸ“‹","âœ…","âš ï¸","ğŸ§ ","ğŸ“ˆ","ğŸ§©","ğŸ§°","ğŸ§¾","ğŸ§²","ğŸ›°ï¸","ğŸ§¯","ğŸ”§","ğŸ—‚ï¸","ğŸ§ª","ğŸ§±","ğŸ§·","ğŸªª","ğŸ§­","ğŸ—’ï¸","ğŸ“Œ"];
const uid = () => "p-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
const deepClone = (o) => JSON.parse(JSON.stringify(o));
const AUTH_ALLOW = { userId: "js.nam", deptId: "GUN30" };
const AUTH_STATE = { canEdit: false };

function debounce(fn, wait){
  let t = null;
  return (...args) => {
    if(t) clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

function safeJsonParse(s){
  try { return {ok:true, val: JSON.parse(s)}; }
  catch(e){ return {ok:false, err: e}; }
}

function nowIso(){
  return new Date().toISOString();
}

function updateAuthState(){
  const jwt = { userId: "js.nam", deptId: "GUN30" };
  AUTH_STATE.canEdit = (jwt.userId === AUTH_ALLOW.userId && jwt.deptId === AUTH_ALLOW.deptId);
}

function setReadOnlyUI(){
  const canEdit = AUTH_STATE.canEdit;
  $("body").toggleClass("no-edit", !canEdit);
  $("#btnAdd, #btnAuto, #btnUndo, #btnExport, #btnImport, #btnReset").prop("disabled", !canEdit);
  $("#btnSave").prop("disabled", !canEdit);
  $("#jsonApply").prop("disabled", !canEdit);
  $("#fTitle, #fType, #fIcon, #fTheme, #fSalesCd, #fCompositeLayout, #fColor, #fBorderColor, #fData")
    .prop("disabled", !canEdit);
  $("#fRefreshOn, #fRefreshMin").prop("disabled", !canEdit);
}

/* =========================
   Rulers Generation
========================= */
function generateRulers(){
  const $hMarks = $("#rulerHorizontalMarks");
  const $vMarks = $("#rulerVerticalMarks");
  
  if(!$hMarks.length || !$vMarks.length) return;
  
  $hMarks.empty();
  $vMarks.empty();
  
  const $mainEl = $(".main");
  if(!$mainEl.length) return;
  
  const rect = getRectFromEl($mainEl);
  const rulerSize = parseInt($("html").css("--rulerSize"));
  
  // Horizontal ruler marks (width - rulerSize)
  const hWidth = rect.width - rulerSize;
  for(let i = 0; i <= hWidth; i += 10){
    const $mark = $("<div>").addClass("ruler-mark").css("left", i + "px");
    
    // Major marks every 100px, medium every 50px, minor every 10px
    if(i % 100 === 0){
      $mark.addClass("major");
      const $label = $("<div>").addClass("ruler-label").text(i).css("left", i + "px");
      $hMarks.append($label);
    }else if(i % 50 === 0){
      // Medium mark
      $mark.css("height", "10px");
    }else{
      $mark.addClass("minor");
    }
    
    $hMarks.append($mark);
  }
  
  // Vertical ruler marks (height - rulerSize)
  const vHeight = rect.height - rulerSize;
  for(let i = 0; i <= vHeight; i += 10){
    const $mark = $("<div>").addClass("ruler-mark").css("top", i + "px");
    
    // Major marks every 100px, medium every 50px, minor every 10px
    if(i % 100 === 0){
      $mark.addClass("major");
      const $label = $("<div>").addClass("ruler-label").text(i).css("top", i + "px");
      $vMarks.append($label);
    }else if(i % 50 === 0){
      // Medium mark
      $mark.css("width", "10px");
    }else{
      $mark.addClass("minor");
    }
    
    $vMarks.append($mark);
  }
}

// Debounced ruler regeneration on resize
const regenerateRulers = debounce(() => {
  generateRulers();
}, 250);

$(window).on("resize", regenerateRulers);

/* =========================
   1) State
========================= */
let STATE = null;
let SPLITTER = null;
let PANE_COUNT = 2;

let UI = {
  saveState: $("#saveState"),
  gridInfo: $("#gridInfo"),
  splitRoot: $("#splitRoot"),
  ctxMenu: $("#ctxMenu"),
  modalBack: $("#modalBack"),
  jsonBack: $("#jsonBack"),
  jsonArea: $("#jsonArea"),
  jsonHint: $("#jsonHint"),
  jsonTitle: $("#jsonTitle"),
  helpBack: $("#helpBack"),
  modalTitle: $("#modalTitle"),
  fTitle: $("#fTitle"),
  fType: $("#fType"),
  fCompositeLayout: $("#fCompositeLayout"),
  compositeLayoutRow: $("#compositeLayoutRow"),
  fSalesCd: $("#fSalesCd"),
  fIcon: $("#fIcon"),
  fTheme: $("#fTheme"),
  fColor: $("#fColor"),
  fBorderColor: $("#fBorderColor"),
  fData: $("#fData"),
  dataHint: $("#dataHint"),
  helpHint: $("#helpHint"),
  fRefreshOn: $("#fRefreshOn"),
  fRefreshMin: $("#fRefreshMin")
};

let DIR_LABEL = () => (STATE.split.direction === "vertical" ? "ì¢Œ/ìš°" : "ìƒ/í•˜");

let DIR_TO_SPLITJS = (dir) => (dir === "vertical" ? "horizontal" : "vertical");
/*
  Split.js option `direction`:
    - 'horizontal' => panes arranged side-by-side (left/right) with vertical gutter
    - 'vertical'   => panes stacked (top/bottom) with horizontal gutter
  ìš°ë¦¬ STATE.split.direction:
    - 'vertical' => ì¢Œ/ìš°
    - 'horizontal' => ìƒ/í•˜
  ë”°ë¼ì„œ:
    STATE.vertical  => Split.js horizontal
    STATE.horizontal=> Split.js vertical
*/

/* =========================
   2) Default layout (sample)
========================= */
function defaultState(){
  const st = {
    layoutMode: "split", // grid|split|flow
    grid: { cols: 12, rowHeight: 92, gap: 12 },
    split: {
      enabled: true,
      direction: "vertical", // vertical=ì¢Œìš°, horizontal=ìƒí•˜
      panes: [
        { paneId:"p1", ratio:0.55 },
        { paneId:"p2", ratio:0.45 }
      ]
    },
    panes: [
      { paneId:"p1", panels: [] },
      { paneId:"p2", panels: [] }
    ],
    meta: { savedAt: nowIso(), version: 1 }
  };

  // pane1
  st.panes[0].panels.push(
    mkPanel("Worklog","ì‘ì—…ë‚´ì—­", "ğŸ“‹","default",{x:0,y:0,w:6,h:3}, {
      cardSummary: {
        salesCd: "26001-01ABCDT",
        pm: "í™ê¸¸ë™",
        schedule: "ì •ìƒ",
        issueCount: 2,
        period: "2026.01.01~2026.06.30",
        last: "2026. 1. 24. 11:05:34"
      },
      items:[
        {t:"DWG ë²„ì „ê´€ë¦¬ ë¡œê·¸ ì ê²€", time:"09:12"},
        {t:"MES ì¸í„°í˜ì´ìŠ¤ íƒœê·¸ ê²€ì¦", time:"10:05"},
        {t:"DLP ì •ì±… ì˜ˆì™¸ ìŠ¹ì¸ ì²˜ë¦¬", time:"10:44"}
      ]
    }),
    mkPanel("Issues","ì´ìŠˆí˜„í™©", "âš ï¸","warn",{x:6,y:0,w:6,h:3}, {
      cardSummary: {
        salesCd: "26001-01ABCDT",
        pm: "í™ê¸¸ë™",
        schedule: "ì ê²€",
        issueCount: 12,
        period: "2026.01.01~2026.06.30",
        last: "2026. 1. 24. 10:58:12"
      },
      open:12, closed:34, sev1:2, sev2:5
    }),
    mkPanel("Worklog","ìµœê·¼ ë³€ê²½", "ğŸ§¾","default",{x:0,y:3,w:12,h:2}, {
      cardSummary: {
        salesCd: "26001-01ABCDT",
        pm: "í™ê¸¸ë™",
        schedule: "ì§„í–‰",
        issueCount: 1,
        period: "2026.01.01~2026.06.30",
        last: "2026. 1. 24. 11:42:00"
      },
      items:[
        {t:"ê°„íŠ¸ë°” actBar ë Œë”ë§ ê·œì¹™ ì ìš©", time:"11:20"},
        {t:"íˆ´íŒ/ëª¨ë‹¬ ì¶©ëŒ ë¡œì§ ë³´ì •", time:"11:42"}
      ]
    })
  );

  // pane2
  st.panes[1].panels.push(
    mkPanel("Progress","ì§„í–‰ìƒíƒœ", "ğŸ“ˆ","ok",{x:0,y:0,w:12,h:3}, {
      cardSummary: {
        salesCd: "26001-01ABCDT",
        pm: "í™ê¸¸ë™",
        schedule: "ì •ìƒ",
        issueCount: 0,
        period: "2026.01.01~2026.06.30",
        last: "2026. 1. 24. 11:02:10"
      },
      percent:72, status:"ì •ìƒ", kpi1:18, kpi2:4
    }),
    mkPanel("Issues","ìš´ì˜ ì´ìŠˆ", "âš ï¸","danger",{x:0,y:3,w:6,h:2}, {
      cardSummary: {
        salesCd: "26001-01ABCDT",
        pm: "í™ê¸¸ë™",
        schedule: "ì£¼ì˜",
        issueCount: 6,
        period: "2026.01.01~2026.06.30",
        last: "2026. 1. 24. 10:22:48"
      },
      open:6, closed:9, sev1:1, sev2:2
    }),
    mkPanel("Progress","ë°°í¬ íŒŒì´í”„ë¼ì¸", "âœ…","ok",{x:6,y:3,w:6,h:2}, {
      cardSummary: {
        salesCd: "26001-01ABCDT",
        pm: "í™ê¸¸ë™",
        schedule: "ì–‘í˜¸",
        issueCount: 1,
        period: "2026.01.01~2026.06.30",
        last: "2026. 1. 24. 11:18:07"
      },
      percent:91, status:"ì–‘í˜¸", kpi1:7, kpi2:1
    })
  );

  // Merge ë°ëª¨: pane1ì˜ Worklog + Issuesë¥¼ Compositeë¡œ ë¯¸ë¦¬ í•˜ë‚˜ ìƒì„± (ì˜µì…˜)
  // ì‹¤ì œ merge ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë³´ì—¬ì£¼ê¸° ìœ„í•´ composite í•˜ë‚˜ë¥¼ ì¶”ê°€í•˜ê³ , ê³µê°„ ì¶©ëŒ ì—†ì´ ë°°ì¹˜
  st.panes[0].panels.push(
    mkComposite(
      "í†µí•© ì¹´ë“œ(ì‘ì—…+ì´ìŠˆ)", "ğŸ§©", "default", {x:0,y:5,w:12,h:3},
      [
        {sectionId:"s1", type:"Worklog", visible:true, data:{
          cardSummary: { salesCd: "26001-01ABCDT", pm: "í™ê¸¸ë™", schedule: "ì§„í–‰", issueCount: 0, period: "2026.01.01~2026.06.30", last: "2026. 1. 24. 13:40:00" },
          items:[{t:"ì£¼ê°„ íšŒì˜ìë£Œ ì •ë¦¬", time:"13:10"},{t:"RAG ë¡œê·¸ ìŠ¤í‚¤ë§ˆ ê°œì„ ", time:"13:40"}]
        }},
        {sectionId:"s2", type:"Issues",  visible:true, data:{
          cardSummary: { salesCd: "26001-01ABCDT", pm: "í™ê¸¸ë™", schedule: "ì •ìƒ", issueCount: 3, period: "2026.01.01~2026.06.30", last: "2026. 1. 24. 13:35:12" },
          open:3, closed:20, sev1:0, sev2:1
        }}
      ],
      "stack"
    )
  );

  return st;
}

function mkPanel(type,title,icon,theme,layout,data){
  return {
    id: uid(),
    type, title, icon, theme,
    layout: { x:layout.x, y:layout.y, w:layout.w, h:layout.h },
    data: data || {},
    updatedAt: nowIso()
  };
}

function mkComposite(title, icon, theme, layout, sections, layoutPreset){
  return {
    id: uid(),
    type: "Composite",
    title,
    icon,
    theme,
    layout: { x:layout.x, y:layout.y, w:layout.w, h:layout.h },
    data: {},
    updatedAt: nowIso(),
    composite: {
      sections: sections || [],
      layout: layoutPreset || "stack"
    }
  };
}

/* =========================
   3) Persistence
========================= */
let dirty = false;
const markDirty = () => {
  dirty = true;
  UI.saveState.text("ë³€ê²½ë¨");
  UI.saveState.css({ borderColor: "rgba(245,158,11,.35)", color: "#92400e" });
};
const markSaved = () => {
  dirty = false;
  UI.saveState.text("ì €ì¥ë¨");
  UI.saveState.css({ borderColor: "", color: "" });
};

const autosave = debounce(() => {
  try{
    STATE.meta.savedAt = nowIso();
    localStorage.setItem(LS_KEY, JSON.stringify(STATE));
    markSaved();
  }catch(e){
    console.error(e);
    UI.saveState.text("ì €ì¥ ì˜¤ë¥˜");
  }
}, 400);

function loadState(){
  const raw = localStorage.getItem(LS_KEY);
  if(!raw) return null;
  const parsed = safeJsonParse(raw);
  if(!parsed.ok) return null;
  return parsed.val;
}

function resetState(){
  localStorage.removeItem(LS_KEY);
  STATE = defaultState();
  applyCssVars();
  renderAll();
  markDirty();
  autosave();
}

/* =========================
   4) Rendering
========================= */
function applyCssVars(){
  $("html")
    .css("--gap", STATE.grid.gap + "px")
    .css("--rowH", STATE.grid.rowHeight + "px")
    .css("--cols", STATE.grid.cols);

  UI.gridInfo.text(`Snap: 10px | Grid: 10px | Ruler: ON`);
}

function ensurePanes(count){
  // normalize split.panes & panes array
  const want = count;
  while(STATE.split.panes.length < want){
    const pid = "p" + (STATE.split.panes.length + 1);
    STATE.split.panes.push({ paneId: pid, ratio: 1/want });
    STATE.panes.push({ paneId: pid, panels: [] });
  }
  while(STATE.split.panes.length > want){
    const removed = STATE.split.panes.pop();
    // removed pane panels -> move to first pane as fallback
    const paneObj = STATE.panes.find(x=>x.paneId===removed.paneId);
    if(paneObj && paneObj.panels.length){
      const first = STATE.panes[0];
      first.panels.push(...paneObj.panels);
    }
    STATE.panes = STATE.panes.filter(x=>x.paneId!==removed.paneId);
  }

  // normalize ratios
  const n = STATE.split.panes.length;
  let sum = STATE.split.panes.reduce((a,b)=>a+(+b.ratio||0),0);
  if(sum <= 0){
    STATE.split.panes.forEach(p=>p.ratio = 1/n);
    sum = 1;
  }
  STATE.split.panes.forEach(p=>p.ratio = p.ratio / sum);
}

function renderAll(){
  ensureZOrder();
  // destroy old split
  if(SPLITTER){
    try { SPLITTER.destroy(); } catch(_){}
    SPLITTER = null;
  }
  UI.splitRoot.empty();
  $("body").toggleClass("mode-grid", STATE.layoutMode === "grid");

  // panes create (split ëª¨ë“œì—ì„œë„ grid/flow ëª¨ë“œì—ì„œë„ ë™ì¼í•œ wrapperë¥¼ ì‚¬ìš©)
  const paneIds = STATE.layoutMode === "grid"
    ? ["p1"]
    : (STATE.layoutMode === "flow" ? ["p1"] : STATE.split.panes.map(p=>p.paneId));

  paneIds.forEach((paneId, idx) => {
    const $pane = $("<div>").addClass("pane").attr("data-pane-id", paneId);
    const $header = $("<div>").addClass("paneHeader");
    // Grid/Flow ëª¨ë“œì—ì„œëŠ” "All Panes" í‘œì‹œ
    const paneTitles = {
      p1: "ê±´ì–‘ì•„ì´í‹°í‹° ìƒì‚°ë™",
      p2: "ìƒì‚°ë™2ì¸µ",
      p3: "ì™¸ì£¼ì œì‘ì „ì²´"
    };
    const title = (STATE.layoutMode === "grid" || STATE.layoutMode === "flow")
      ? "All Panes"
      : (paneTitles[paneId] || `Pane ${paneId.toUpperCase()}`);
    const metaText = (paneId === "p1") ? `${STATE.layoutMode.toUpperCase()} Â· Drag/Resize/Merge/Split` : `${STATE.layoutMode.toUpperCase()}`;
    $header.html(`
      <div class="title">${title}</div>
      <div class="meta">${metaText}</div>
    `);
    $pane.append($header);

    const $dash = $("<div>")
      .addClass("dashboard " + (STATE.layoutMode === "flow" ? "flow" : "grid"))
      .attr("data-pane-id", paneId);
    const $gridLayer = $("<div>").addClass("grid-layer");
    $dash.append($gridLayer);
    $pane.append($dash);

    UI.splitRoot.append($pane);
  });

  // set flex direction for split layout
  if(STATE.layoutMode === "split"){
    const splitjsDirection = DIR_TO_SPLITJS(STATE.split.direction);
    UI.splitRoot.css("flex-direction", (splitjsDirection === "vertical") ? "column" : "row");
    UI.splitRoot.toggleClass("split-col", splitjsDirection === "vertical");
    UI.splitRoot.toggleClass("split-row", splitjsDirection !== "vertical");
    UI.splitRoot.removeClass("single-pane");
  }else{
    UI.splitRoot.css("flex-direction", "row");
    UI.splitRoot.removeClass("split-col split-row");
    UI.splitRoot.addClass("single-pane");
  }

  // initialize split only in split mode
  if(STATE.layoutMode === "split"){
    // Split.js expects children elements to split
    const sizes = STATE.split.panes.map(p => Math.round(p.ratio * 1000) / 10); // %
    const splitjsDirection = DIR_TO_SPLITJS(STATE.split.direction);
    SPLITTER = Split(Array.from(UI.splitRoot[0].children), {
      sizes,
      minSize: 100,
      gutterSize: 10,
      snapOffset: 0,
      direction: splitjsDirection,
      onDragEnd: (newSizes) => {
        if(!AUTH_STATE.canEdit) return;
        // persist
        // newSizes are percentages
        STATE.split.panes.forEach((p,i)=> p.ratio = (newSizes[i]||0)/100);
        markDirty();
        autosave();
      }
    });
  }

  // render panels into each dashboard
  const $dashboards = $(".dashboard");
  $dashboards.empty();
  $dashboards.each((_, dashEl) => {
    const $gridLayer = $("<div>").addClass("grid-layer");
    $(dashEl).append($gridLayer);
  });

  const paneList = STATE.panes;
  
  // Grid/Flow ëª¨ë“œ: ëª¨ë“  panesì˜ íŒ¨ë„ë“¤ì„ ì²« ë²ˆì§¸ dashboardì— í†µí•© ë Œë”ë§
  if(STATE.layoutMode === "grid" || STATE.layoutMode === "flow"){
    const $mainDash = $(".dashboard").first();
    if($mainDash.length){
      if(STATE.layoutMode === "grid"){
        const cols = STATE.grid.cols || 12;
        const gap = STATE.grid.gap || 0;
        const cell = 100;
        const gridWidth = (cols * cell) + (Math.max(0, cols - 1) * gap);
        $mainDash.css({ width: gridWidth + "px", maxWidth: gridWidth + "px" });
      }else{
        $mainDash.css({ width: "", maxWidth: "" });
      }
      paneList.forEach(paneObj => {
        paneObj.panels.forEach(panel => {
          const el = renderPanel(panel);
          $mainDash.append(el);
          positionPanelEl(el, panel);
        });
      });
    }
  }else{
    // Split ëª¨ë“œ: ê° paneì˜ íŒ¨ë„ë“¤ì„ í•´ë‹¹ dashboardì— ë Œë”ë§
    paneList.forEach(paneObj => {
      const $dash = $(`.dashboard[data-pane-id="${paneObj.paneId}"]`);
      if(!$dash.length) return;

      paneObj.panels.forEach(panel => {
        const el = renderPanel(panel);
        $dash.append(el);
        positionPanelEl(el, panel);
      });
    });
  }

  bindInteract();
}

function renderPanel(p){
  const $el = $("<div>")
    .addClass("panel " + themeClass(p.theme))
    .attr("data-id", p.id)
    .attr("data-type", p.type || "");

  const bgColor = (p.style && p.style.bg) ? p.style.bg : "";
  const borderColor = (p.style && p.style.border) ? p.style.border : "";

  if(bgColor){
    $el.css("background-color", bgColor);
  }else{
    $el.css("background-color", "");
  }
  if(borderColor){
    $el.css("border-color", borderColor);
  }else{
    $el.css("border-color", "");
  }

  const typeBadge = p.type;

  $el.html(`
    <div class="panelHead">
      <div class="headLeft">
        <div class="pIcon" title="icon">${escapeHtml(p.icon || "ğŸ“Œ")}</div>
        <div class="pTitle" title="${escapeAttr(p.title)}">${escapeHtml(p.title)}</div>
        <span class="badge badge-${escapeAttr(typeBadge)}">${escapeHtml(typeBadge)}</span>
      </div>
      <div class="headRight">
        <button class="iconBtn btnSettings" title="ì„¤ì •(âš™)">âš™</button>
        <button class="iconBtn btnMore" title="ë”ë³´ê¸°(â€¦)" aria-label="more">â€¦</button>
      </div>
    </div>
    <div class="panelBody ${p.type === "Image" ? "imageBody" : ""}">
      ${renderPanelBody(p)}
    </div>
    <div class="resizeHint" title="Resize"></div>
  `);
  const $headEl = $el.find(".panelHead");
  if($headEl.length){
    $headEl.css({ backgroundColor: "", borderColor: "" });
  }

  if(p.type === "Image"){
    $el.find(".panelHead").remove();
  }

  // handlers
  $el.find(".btnSettings").on("click", (e) => {
    e.stopPropagation();
    openSettings(p.id);
  });

  $el.find(".btnMore").on("click", (e) => {
    e.stopPropagation();
    // minimal: open context menu
    const rect = getRectFromEl($el);
    openCtxMenu(rect.left + 14, rect.top + 42, p.id);
  });

  $el.on("click", () => {
    clearSelection();
    $el.addClass("selected");
    selectedPanelId = p.id;
  });

  $el.on("contextmenu", (e) => {
    e.preventDefault();
    clearSelection();
    $el.addClass("selected");
    selectedPanelId = p.id;
    openCtxMenu(e.clientX, e.clientY, p.id);
  });

  $el.on("dblclick", (e) => {
    e.preventDefault();
    openSettings(p.id);
  });

  return $el[0];
}

function renderCardSummary(data){
  // cardSummaryëŠ” JSONì— ëª…ì‹œì ìœ¼ë¡œ í¬í•¨ë˜ì–´ì•¼ í•œë‹¤.
  const summary = data.cardSummary || {};
  const salesCd = summary.salesCd ?? "-";
  const schedule = summary.schedule ?? "ì§„í–‰";
  const issues = (typeof summary.issueCount === "number") ? summary.issueCount : 0;
  const last = summary.last ?? "-";
  const pm = summary.pm ?? "-";
  const period = summary.period ?? "-";

  return `
    <div class="cardSummary">
      <div class="cardMeta">
        <span class="cardBadge">[ì„¤ë¹„]</span>
        <div class="cardBadges">
          <span class="cardBadge ok">${escapeHtml(String(schedule))}</span>
          <span class="cardBadge issue">ë¬¸ì œ ${escapeHtml(String(issues))}</span>
        </div>
      </div>
      <div class="cardRow split">
        <div class="pair">
          <span class="label">SalesCd:</span>
          <span class="value">${escapeHtml(String(salesCd))}</span>
        </div>
        <div class="pair secondary">
          <span class="label">PM:</span>
          <span class="value">${escapeHtml(String(pm))}</span>
        </div>
      </div>
      <div class="cardRow split">
        <div class="pair">
          <span class="label">ê¸°ê°„:</span>
          <span class="value">${escapeHtml(String(period))}</span>
        </div>
        <div class="pair secondary">
          <span class="label">ì¼ì •ìƒíƒœ:</span>
          <span class="value">${escapeHtml(String(schedule))}</span>
        </div>
      </div>
      <div class="cardFoot">Last: ${escapeHtml(String(last))}</div>
    </div>
  `;
}

function renderSalesCdLine(data){
  const salesCd = data?.cardSummary?.salesCd;
  if(!salesCd) return "";
  return `
    <div class="cardRow">
      <span class="label">SalesCd:</span>
      <span class="value">${escapeHtml(String(salesCd))}</span>
    </div>
  `;
}

function renderPanelBody(p){
  if(p.type === "Image"){
    const src = (p.data && p.data.src) ? p.data.src : "";
    return src
      ? `<img src="${escapeAttr(src)}" alt="pasted image" />`
      : `<div class="muted">ì´ë¯¸ì§€</div>`;
  }

  if(p.type !== "Composite"){
    return renderCardSummary(p.data || {});
  }

  if(p.type === "Worklog"){
    const items = (p.data && p.data.items) ? p.data.items : [];
    const lis = items.map(x => `
      <div class="li">
        <div class="left">
          <span class="dot"></span>
          <span class="txt" title="${escapeAttr(x.t||"")}">${escapeHtml(x.t||"")}</span>
        </div>
        <span class="time">${escapeHtml(x.time||"")}</span>
      </div>
    `).join("");
    return `
      <div class="section">
        <div class="sectionTitle">
          <span>ìµœê·¼ ì‘ì—…</span><span class="muted">${items.length}ê±´</span>
        </div>
        ${renderSalesCdLine(p.data || {})}
        <div class="list">${lis || `<div class="muted">ë“±ë¡ëœ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.</div>`}</div>
      </div>
    `;
  }

  if(p.type === "Progress"){
    const percent = clamp(+((p.data||{}).percent ?? 0), 0, 100);
    const status = (p.data||{}).status || "ìƒíƒœ";
    const kpi1 = (p.data||{}).kpi1 ?? 0;
    const kpi2 = (p.data||{}).kpi2 ?? 0;
    // render
    return `
      <div class="section">
        <div class="sectionTitle">
          <span>ì§„í–‰ë¥ </span><span class="muted">${escapeHtml(status)}</span>
        </div>
        ${renderSalesCdLine(p.data || {})}
        <div class="kpiRow">
          <div class="kpi"><div class="lbl">ì§„í–‰(%)</div><div class="val">${percent}</div></div>
          <div class="kpi"><div class="lbl">KPI-1</div><div class="val">${escapeHtml(String(kpi1))}</div></div>
          <div class="kpi"><div class="lbl">KPI-2</div><div class="val">${escapeHtml(String(kpi2))}</div></div>
        </div>
        <div class="barWrap"><div class="bar" style="width:${percent}%"></div></div>
      </div>
    `;
  }

  if(p.type === "Issues"){
    const open = +((p.data||{}).open ?? 0);
    const closed = +((p.data||{}).closed ?? 0);
    const sev1 = +((p.data||{}).sev1 ?? 0);
    const sev2 = +((p.data||{}).sev2 ?? 0);
    return `
      <div class="section">
        <div class="sectionTitle">
          <span>ì´ìŠˆ ìš”ì•½</span><span class="muted">Open ${open}</span>
        </div>
        ${renderSalesCdLine(p.data || {})}
        <div class="counts">
          <div class="count"><div class="lbl">Open</div><div class="val">${open}</div></div>
          <div class="count"><div class="lbl">Closed</div><div class="val">${closed}</div></div>
        </div>
        <div class="counts" style="margin-top:10px;">
          <div class="count"><div class="lbl">Sev1</div><div class="val">${sev1}</div></div>
          <div class="count"><div class="lbl">Sev2</div><div class="val">${sev2}</div></div>
        </div>
      </div>
    `;
  }

  if(p.type === "Composite"){
    const comp = p.composite || {sections:[], layout:"stack"};
    const sections = (comp.sections || []).filter(s => s.visible !== false);
    const preset = comp.layout || "stack";

    // simple presets: stack / twoColumn / kpiRight
    if(preset === "twoColumn"){
      const left = sections[0] ? renderCompositeSection(sections[0]) : `<div class="muted">ì„¹ì…˜ ì—†ìŒ</div>`;
      const right = sections[1] ? renderCompositeSection(sections[1]) : `<div class="muted">ì„¹ì…˜ ì—†ìŒ</div>`;
      const count = Math.max(1, sections.length);
      const colW = Math.max(1, Math.floor(100 / count));
      return `
        <div class="kpiRow" style="height:100%;">
          <div style="flex:0 0 ${colW}%; min-width:0;">${left}</div>
          <div style="flex:0 0 ${colW}%; min-width:0;">${right}</div>
        </div>
      `;
    }

    if(preset === "kpiRight"){
      const a = sections[0] ? renderCompositeSection(sections[0]) : `<div class="muted">ì„¹ì…˜ ì—†ìŒ</div>`;
      const b = sections[1] ? renderCompositeSection(sections[1]) : `<div class="muted">ì„¹ì…˜ ì—†ìŒ</div>`;
      return `
        <div class="kpiRow" style="height:100%;">
          <div style="flex:1.2; min-width:0;">${a}</div>
          <div style="flex:.8; min-width:0;">${b}</div>
        </div>
      `;
    }

    // stack default
    return sections.map(s => renderCompositeSection(s)).join("") || `<div class="muted">Composite ì„¹ì…˜ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.</div>`;
  }

  return `<div class="muted">ì§€ì›ë˜ì§€ ì•ŠëŠ” íƒ€ì…ì…ë‹ˆë‹¤.</div>`;
}

function renderCompositeSection(sec){
  const data = sec.data || {};
  const title = sec.title || sec.type;
  return `
    <div class="section">
      <div class="sectionTitle"><span>${escapeHtml(title)}</span></div>
      ${renderCardSummary(data)}
    </div>
  `;
  const t2 = sec.type;
  if(t2 === "Worklog"){
    const items = data.items || [];
    const lis = items.map(x => `
      <div class="li">
        <div class="left">
          <span class="dot"></span>
          <span class="txt" title="${escapeAttr(x.t||"")}">${escapeHtml(x.t||"")}</span>
        </div>
        <span class="time">${escapeHtml(x.time||"")}</span>
      </div>
    `).join("");
    return `
      <div class="section">
        <div class="sectionTitle"><span>${escapeHtml(title)}</span><span class="muted">${items.length}ê±´</span></div>
        <div class="list">${lis || `<div class="muted">ì‘ì—… ì—†ìŒ</div>`}</div>
      </div>
    `;
  }

  if(t2 === "Issues"){
    const open = +(data.open ?? 0);
    const closed = +(data.closed ?? 0);
    const sev1 = +(data.sev1 ?? 0);
    const sev2 = +(data.sev2 ?? 0);
    return `
      <div class="section">
        <div class="sectionTitle"><span>${escapeHtml(title)}</span><span class="muted">Open ${open}</span></div>
        <div class="counts">
          <div class="count"><div class="lbl">Open</div><div class="val">${open}</div></div>
          <div class="count"><div class="lbl">Closed</div><div class="val">${closed}</div></div>
        </div>
        <div class="counts" style="margin-top:10px;">
          <div class="count"><div class="lbl">Sev1</div><div class="val">${sev1}</div></div>
          <div class="count"><div class="lbl">Sev2</div><div class="val">${sev2}</div></div>
        </div>
      </div>
    `;
  }

  if(t2 === "Progress"){
    const percent = clamp(+((data).percent ?? 0), 0, 100);
    const status = data.status || "ìƒíƒœ";
    const kpi1 = data.kpi1 ?? 0;
    const kpi2 = data.kpi2 ?? 0;
    return `
      <div class="section">
        <div class="sectionTitle"><span>${escapeHtml(title)}</span><span class="muted">${escapeHtml(status)}</span></div>
        <div class="kpiRow">
          <div class="kpi"><div class="lbl">ì§„í–‰(%)</div><div class="val">${percent}</div></div>
          <div class="kpi"><div class="lbl">KPI-1</div><div class="val">${escapeHtml(String(kpi1))}</div></div>
          <div class="kpi"><div class="lbl">KPI-2</div><div class="val">${escapeHtml(String(kpi2))}</div></div>
        </div>
        <div class="barWrap"><div class="bar" style="width:${percent}%"></div></div>
      </div>
    `;
  }

  return `
    <div class="section">
      <div class="sectionTitle"><span>${escapeHtml(title)}</span><span class="muted">${escapeHtml(t2)}</span></div>
      <pre style="margin:0; font-size:12px; white-space:pre-wrap;">${escapeHtml(JSON.stringify(data, null, 2))}</pre>
    </div>
  `;
}

function applyPanelScale(el, width, height){
  const $el = $(el);
  const panelBody = $el.find(".panelBody")[0];
  if(!panelBody) return;
  const head = $el.find(".panelHead")[0];
  const headRight = $el.find(".headRight")[0];
  const headH = head ? $(head).outerHeight() : 0;
  const bodyW = Math.max(0, width);
  const bodyH = Math.max(0, height - headH);
  const baseSize = 200;
  let scale = Math.min(Math.max(Math.min(bodyW / baseSize, bodyH / baseSize), 0), 1.5);
  const btnScale = Math.min(Math.max(bodyW / 200, 0), 1.5);

  // composite: adjust scale by merged section count ratio
  const panelId = el.dataset.id;
  const p = panelId ? getPanel(panelId) : null;
  if(p && p.type === "Composite"){
    const count = (p.composite?.sections || []).filter(s => s && s.visible !== false).length || 1;
    const preset = p.composite?.layout || "stack";
    if(preset === "twoColumn"){
      const effectiveW = bodyW / count;
      const effectiveScale = Math.min(effectiveW / baseSize, bodyH / baseSize);
      scale = Math.min(Math.max(effectiveScale, 0.5), 1.5);
    }else{
      // stack (ì„¸ë¡œë°°ì¹˜): scale based on per-section height
      const effectiveH = bodyH / count;
      const effectiveScale = Math.min(bodyW / baseSize, effectiveH / baseSize);
      scale = Math.min(Math.max(effectiveScale, 0.5), 1.5);
    }
  }

  $el.toggleClass("compact", width <= 200);

  if(headRight){
    if(btnScale !== 1){
      headRight.style.transform = `scale(${btnScale})`;
      headRight.style.transformOrigin = "top right";
    }else{
      headRight.style.transform = "";
    }
  }

  if(scale !== 1){
    panelBody.style.transform = `scale(${scale})`;
    panelBody.style.transformOrigin = "top left";
    panelBody.style.width = (bodyW / scale) + "px";
    panelBody.style.height = (bodyH / scale) + "px";
  }else{
    panelBody.style.transform = "";
    panelBody.style.width = "";
    panelBody.style.height = "";
  }
}

function positionPanelEl(el, p){
  if(STATE.layoutMode === "flow"){
    // flow: keep default CSS size; ignore x/y
    el.style.position = "relative";
    return;
  }
  
  // Use pixel-based positioning
  const layout = p.layout;
  
  // If pixel coordinates exist, use them; otherwise convert from grid coordinates
  const left = layout.px?.x ?? (layout.x * 100);
  const top = layout.px?.y ?? (layout.y * 100);
  const width = layout.px?.w ?? (layout.w * 100);
  const height = layout.px?.h ?? (layout.h * 100);
  
  el.style.position = "absolute";
  el.style.left = left + "px";
  el.style.top = top + "px";
  el.style.width = width + "px";
  el.style.height = height + "px";
  el.style.zIndex = String(p.layout?.z ?? 1);

  applyPanelScale(el, width, height);
}

function themeClass(theme){
  if(theme === "ok") return "theme-ok";
  if(theme === "warn") return "theme-warn";
  if(theme === "danger") return "theme-danger";
  return "";
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}
function escapeAttr(s){ return escapeHtml(s).replaceAll("\n"," "); }

/* =========================
   5) Layout & Collision
========================= */
function paneOf(panelId){
  return STATE.panes.find(p => p.panels.some(x => x.id === panelId));
}
function getPanel(panelId){
  for(const pn of STATE.panes){
    const p = pn.panels.find(x=>x.id===panelId);
    if(p) return p;
  }
  return null;
}
function removePanel(panelId){
  for(const pn of STATE.panes){
    const idx = pn.panels.findIndex(x=>x.id===panelId);
    if(idx >= 0){
      return pn.panels.splice(idx,1)[0];
    }
  }
  return null;
}
function addPanelToPane(paneId, panel){
  const pn = STATE.panes.find(x=>x.paneId===paneId);
  if(!pn) return false;
  pn.panels.push(panel);
  return true;
}

function ensureZOrder(){
  let maxZ = 1;
  STATE.panes.forEach(pn => {
    pn.panels.forEach(p => {
      const z = p.layout?.z;
      if(typeof z === "number" && !Number.isNaN(z)){
        if(z < 1) p.layout.z = 1;
        maxZ = Math.max(maxZ, p.layout.z);
      }
    });
  });
  STATE.panes.forEach(pn => {
    pn.panels.forEach(p => {
      if(p.layout && (p.layout.z == null || Number.isNaN(p.layout.z))){
        maxZ += 1;
        p.layout.z = maxZ;
      }
    });
  });
}

function normalizePaneZOrder(pane){
  if(!pane) return;
  const ordered = pane.panels
    .filter(p => p && p.layout)
    .slice()
    .sort((a,b) => (a.layout?.z ?? 1) - (b.layout?.z ?? 1));
  ordered.forEach((p, i) => { p.layout.z = i + 1; });
}

function bringPanelToFront(panelId){
  const p = getPanel(panelId);
  if(!p) return;
  const pane = paneOf(panelId);
  if(!pane) return;
  ensureZOrder();
  normalizePaneZOrder(pane);
  const maxZ = Math.max(...pane.panels.map(x => (typeof x.layout?.z === "number" ? x.layout.z : 1)));
  p.layout.z = maxZ + 1;
  normalizePaneZOrder(pane);
}

function sendPanelToBack(panelId){
  const p = getPanel(panelId);
  if(!p) return;
  const pane = paneOf(panelId);
  if(!pane) return;
  ensureZOrder();
  normalizePaneZOrder(pane);
  const minZ = Math.min(...pane.panels.map(x => (typeof x.layout?.z === "number" ? x.layout.z : 1)));
  p.layout.z = Math.max(1, minZ - 1);
  normalizePaneZOrder(pane);
}

function rectsOverlap(a,b){
  return !(a.x+a.w <= b.x || b.x+b.w <= a.x || a.y+a.h <= b.y || b.y+b.h <= a.y);
}

function panelRect(p){ return {x:p.layout.x,y:p.layout.y,w:p.layout.w,h:p.layout.h}; }

function resolveCollision(paneId, movingId, desiredRect){
  const pn = STATE.panes.find(x=>x.paneId===paneId);
  if(!pn) return desiredRect;

  const cols = STATE.grid.cols;

  // clamp to cols
  desiredRect.x = clamp(desiredRect.x, 0, cols - desiredRect.w);

  // find overlaps
  const moving = pn.panels.find(p=>p.id===movingId);
  const overlaps = pn.panels
    .filter(p=>p.id!==movingId)
    .filter(p=> rectsOverlap(desiredRect, panelRect(p)));

  if(overlaps.length === 0) return desiredRect;

  // policy: if exactly one overlap and same size => swap
  if(overlaps.length === 1 && moving){
    const o = overlaps[0];
    const same = (o.layout.w === desiredRect.w && o.layout.h === desiredRect.h);
    if(same){
      // swap rectangles
      const old = deepClone(moving.layout);
      o.layout = old;
      return desiredRect;
    }
  }

  // push: scan rows from desired y, try to find first free spot for moving's size
  const size = {w: desiredRect.w, h: desiredRect.h};
  const startY = desiredRect.y;
  for(let y = startY; y < startY + 120; y++){ // bounded scan
    for(let x = 0; x <= cols - size.w; x++){
      const candidate = {x,y,w:size.w,h:size.h};
      const hit = pn.panels.some(p => p.id!==movingId && rectsOverlap(candidate, panelRect(p)));
      if(!hit) return candidate;
    }
  }

  // fallback (should not)
  return desiredRect;
}

function findDropPanelAt(clientX, clientY){
  const $panels = $(".panel");
  let hitId = null;
  $panels.each((_, el) => {
    const r = getRectFromEl($(el));
    if(clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom){
      hitId = $(el).data("id") || null;
      return false;
    }
  });
  return hitId;
}

function getRectFromEl($el){
  const offset = $el.offset() || { left: 0, top: 0 };
  const width = $el.outerWidth() || 0;
  const height = $el.outerHeight() || 0;
  return {
    left: offset.left,
    top: offset.top,
    right: offset.left + width,
    bottom: offset.top + height,
    width,
    height
  };
}

function findDropPanelByPoint(clientX, clientY, excludeId){
  const $panels = $(".panel");
  let hitId = null;
  $panels.each((_, el) => {
    const pid = $(el).data("id");
    if(pid && pid !== excludeId){
      const r = getRectFromEl($(el));
      if(clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom){
        hitId = pid;
        return false;
      }
    }
  });
  return hitId;
}

function findDropPanelByRect(rect, excludeId){
  const candidates = $(".panel").toArray()
    .filter(el => $(el).data("id") && $(el).data("id") !== excludeId);
  let bestId = null;
  let bestArea = 0;
  candidates.forEach(el => {
    const r = getRectFromEl($(el));
    const ix = Math.max(0, Math.min(rect.right, r.right) - Math.max(rect.left, r.left));
    const iy = Math.max(0, Math.min(rect.bottom, r.bottom) - Math.max(rect.top, r.top));
    const area = ix * iy;
    if(area > bestArea){
      bestArea = area;
      bestId = $(el).data("id") || null;
    }
  });
  return bestId;
}

function findPaneAt(clientX, clientY){
  const $panes = $(".pane");
  let hitId = null;
  $panes.each((_, el) => {
    const r = getRectFromEl($(el));
    if(clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom){
      hitId = $(el).attr("data-pane-id") || null;
      return false;
    }
  });
  return hitId;
}

function getDashboardForPane(paneId){
  if(STATE.layoutMode === "split"){
    return $(`.dashboard[data-pane-id="${paneId}"]`)[0];
  }
  return $(".dashboard")[0];
}

/* =========================
   6) Interactions (drag/resize)
========================= */
let selectedPanelId = null;
let ctxPanelId = null;
let mergeArmedId = null;
let SPLIT_LAYOUT_SNAPSHOT = null;
let UNDO_STACK = [];
let CLIPBOARD_PANEL = null;
let LAST_MOUSE_POS = { x: 0, y: 0 };
let SHIFT_DOWN = false;

function pushUndo(){
  UNDO_STACK.push(deepClone(STATE));
  if(UNDO_STACK.length > 30) UNDO_STACK.shift();
}

function undo(){
  const prev = UNDO_STACK.pop();
  if(!prev) return;
  STATE = deepClone(prev);
  // normalize
  if(!STATE.split) STATE.split = {enabled:true,direction:"vertical",panes:[{paneId:"p1",ratio:.55},{paneId:"p2",ratio:.45}]};
  if(!STATE.panes) STATE.panes = [{paneId:"p1",panels:[]},{paneId:"p2",panels:[]}];
  applyCssVars();
  renderAll();
  markDirty();
  autosave();
}

function bindInteract(){
  // clear previous interact bindings by reinitializing on selector (interactjs handles idempotently)
  interact(".panel").unset();

  if(STATE.layoutMode === "flow"){
    // flow: basic drag reorder is non-trivial; keep drag disabled to avoid inconsistent UX
    // still allow context menu/settings
    return;
  }

  if(!AUTH_STATE.canEdit){
    return;
  }

  // draggable
  interact(".panel").draggable({
    inertia: false,
    ignoreFrom: ".btnSettings, .btnMore, .iconBtn, button, input, select, textarea, a",
    modifiers: [
      interact.modifiers.snap({
        targets: [
          (x, y, interaction) => {
            const el = interaction?.element;
            const isImage = el?.dataset?.type === "Image";
            const step = isImage ? 1 : 10;
            return {
              x: Math.round(x / step) * step,
              y: Math.round(y / step) * step
            };
          }
        ],
        range: Infinity,
        relativePoints: [ { x: 0, y: 0 } ]
      })
    ],
    listeners: {
      start (event) {
        $(event.target).addClass("dragging");
        const id = event.target.dataset.id;
        // selection
        clearSelection();
        $(event.target).addClass("selected");
        selectedPanelId = id;
      },
      move (event) {
        // visual translate (for feedback only)
        const target = event.target;
        const dx = (parseFloat(target.getAttribute("data-dx")) || 0) + event.dx;
        const dy = (parseFloat(target.getAttribute("data-dy")) || 0) + event.dy;
        target.style.transform = `translate(${dx}px, ${dy}px)`;
        target.setAttribute("data-dx", dx);
        target.setAttribute("data-dy", dy);

        // highlight drop panel / pane
        const rect = getRectFromEl($(target));
        const cx = (rect.left + rect.right) / 2;
        const cy = (rect.top + rect.bottom) / 2;
        const overId = findDropPanelByPoint(cx, cy, target.dataset.id) || findDropPanelAt(event.clientX, event.clientY);
        $(".panel.dropTarget").removeClass("dropTarget");
        if(overId && overId !== target.dataset.id){
          const $overEl = $(`.panel[data-id="${overId}"]`);
          if($overEl.length) $overEl.addClass("dropTarget");
        }
      },
      end (event) {
        const target = event.target;
        const id = target.dataset.id;
        const dx = parseFloat(target.getAttribute("data-dx")) || 0;
        const dy = parseFloat(target.getAttribute("data-dy")) || 0;

        const isShift = (event.shiftKey === true) || (event?.originalEvent?.shiftKey === true) || SHIFT_DOWN;

        // snapshot for undo on drag move
        if(dx !== 0 || dy !== 0){
          pushUndo();
        }

        // merge handling: Shift+drop on another panel
        if(isShift){
          const rect = getRectFromEl($(target));
          const movedRect = {
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom
          };
          const cx = (movedRect.left + movedRect.right) / 2;
          const cy = (movedRect.top + movedRect.bottom) / 2;
          const dropOnPanelId = findDropPanelByPoint(cx, cy, id)
            || findDropPanelByRect(movedRect, id)
            || findDropPanelAt(event.clientX, event.clientY);
          if(dropOnPanelId && dropOnPanelId !== id){
            doMerge(id, dropOnPanelId);
            return;
          }
        }

        const dropPaneId = findPaneAt(event.clientX, event.clientY) || paneOf(id)?.paneId || "p1";
        const dashEl = $(`.dashboard[data-pane-id="${dropPaneId}"]`)[0];
        if(!dashEl) return;

        const p = getPanel(id);
        if(!p) return;

        // Get current pixel position (with snap applied by interact.js)
        const rect = getRectFromEl($(target));
        const dashRect = getRectFromEl($(dashEl));
        
        // Calculate position relative to dashboard and snap
        const isImage = p.type === "Image";
        const posStep = isImage ? 1 : 10;
        const newLeft = Math.round((rect.left - dashRect.left) / posStep) * posStep;
        const newTop = Math.round((rect.top - dashRect.top) / posStep) * posStep;
        const dragStepW = (isImage && rect.width < 100) ? 5 : 10;
        const dragStepH = (isImage && rect.height < 100) ? 5 : 10;
        const newWidth = Math.round(rect.width / dragStepW) * dragStepW;
        const newHeight = Math.round(rect.height / dragStepH) * dragStepH;

        $(target).removeClass("dragging");
        target.style.transform = "";
        target.removeAttribute("data-dx");
        target.removeAttribute("data-dy");
        $(".panel.dropTarget").removeClass("dropTarget");
        
        // Store pixel coordinates
        if(!p.layout.px) p.layout.px = {};
        const minPos = isImage ? -2 : 0;
        p.layout.px.x = Math.max(minPos, newLeft);
        p.layout.px.y = Math.max(minPos, newTop);
        const minSize = isImage ? 10 : 100;
        p.layout.px.w = Math.max(minSize, newWidth);
        p.layout.px.h = Math.max(minSize, newHeight);
        
        // Also update grid coordinates for backwards compatibility
        p.layout.x = Math.round(newLeft / 100);
        p.layout.y = Math.round(newTop / 100);
        p.layout.w = Math.max(1, Math.round(newWidth / 100));
        p.layout.h = Math.max(1, Math.round(newHeight / 100));

        // if moved across pane
        const fromPane = paneOf(id)?.paneId;
        if(fromPane && fromPane !== dropPaneId){
          const moved = removePanel(id);
          addPanelToPane(dropPaneId, moved);
        }

        markDirty();
        autosave();
        
        // Update panel position and apply scale
        positionPanelEl(target, p);
      }
    }
  });

  // resizable
  interact(".panel").resizable({
    edges: { left:false, right:true, bottom:true, top:false },
    modifiers: [
      interact.modifiers.snapSize({
        targets: [
          interact.snappers.grid({ width: 10, height: 10 })
        ]
      })
    ],
    listeners: {
      move (event) {
        const target = event.target;
        const dx = (parseFloat(target.getAttribute("data-rdx")) || 0) + event.deltaRect.left;
        const dy = (parseFloat(target.getAttribute("data-rdy")) || 0) + event.deltaRect.top;
        target.style.transform = `translate(${dx}px, ${dy}px)`;
        target.setAttribute("data-rdx", dx);
        target.setAttribute("data-rdy", dy);

        target.style.width = event.rect.width + "px";
        target.style.height = event.rect.height + "px";
        applyPanelScale(target, event.rect.width, event.rect.height);
      },
      end (event) {
        const target = event.target;
        const id = target.dataset.id;
        const p = getPanel(id);
        if(!p) return;

        const paneId = paneOf(id)?.paneId || "p1";
        const dashEl = $(`.dashboard[data-pane-id="${paneId}"]`)[0];
        if(!dashEl) return;

        // Get snapped size (interact.js already applies snap)
        const rect = getRectFromEl($(target));
        const dashRect = getRectFromEl($(dashEl));

        const newLeft = Math.round((rect.left - dashRect.left) / 10) * 10;
        const newTop = Math.round((rect.top - dashRect.top) / 10) * 10;
        const isImage = p.type === "Image";
        const stepW = (isImage && rect.width < 100) ? 5 : 10;
        const stepH = (isImage && rect.height < 100) ? 5 : 10;
        const newWidth = Math.round(rect.width / stepW) * stepW;
        const newHeight = Math.round(rect.height / stepH) * stepH;
        
        // Store pixel coordinates
        if(!p.layout.px) p.layout.px = {};
        const minPos = isImage ? -2 : 0;
        p.layout.px.x = Math.max(minPos, newLeft);
        p.layout.px.y = Math.max(minPos, newTop);
        const minSize = isImage ? 10 : 100;
        p.layout.px.w = Math.max(minSize, newWidth);
        p.layout.px.h = Math.max(minSize, newHeight);
        
        // Also update grid coordinates
        p.layout.x = Math.round(newLeft / 100);
        p.layout.y = Math.round(newTop / 100);
        p.layout.w = Math.max(1, Math.round(p.layout.px.w / 100));
        p.layout.h = Math.max(1, Math.round(p.layout.px.h / 100));

        markDirty();
        autosave();
        
        // reset inline resize styles after measuring
        target.style.transform = "";
        target.style.width = "";
        target.style.height = "";
        target.removeAttribute("data-rdx");
        target.removeAttribute("data-rdy");
        
        // Update panel position and apply scale
        positionPanelEl(target, p);
      }
    }
  });
}

/* =========================
   6.5) Copy Panel
========================= */
function doCopyPanel(panelId){
  const p = getPanel(panelId);
  if(!p) return;
  pushUndo();
  
  const paneId = paneOf(panelId)?.paneId || "p1";
  const pn = STATE.panes.find(x=>x.paneId===paneId);
  if(!pn) return;
  
  // Deep clone the panel
  const copied = deepClone(p);
  copied.id = uid(); // Generate new unique ID
  
  // Update title to indicate it's a copy
  copied.title = copied.title + " (ë³µì‚¬ë³¸)";
  
  // Offset position in pixels (50px offset to avoid exact overlap)
  if(!copied.layout.px) copied.layout.px = {};
  const originalX = copied.layout.px.x ?? (copied.layout.x * 100);
  const originalY = copied.layout.px.y ?? (copied.layout.y * 100);
  const originalW = copied.layout.px.w ?? (copied.layout.w * 100);
  const originalH = copied.layout.px.h ?? (copied.layout.h * 100);
  
  copied.layout.px.x = originalX + 50;
  copied.layout.px.y = originalY + 50;
  copied.layout.px.w = originalW;
  copied.layout.px.h = originalH;
  
  // Also update grid coordinates
  copied.layout.x = Math.round(copied.layout.px.x / 100);
  copied.layout.y = Math.round(copied.layout.px.y / 100);
  copied.layout.w = Math.max(1, Math.round(copied.layout.px.w / 100));
  copied.layout.h = Math.max(1, Math.round(copied.layout.px.h / 100));
  
  // Add to pane
  pn.panels.push(copied);
  
  markDirty();
  autosave();
  
  // Render the new panel
  const dash = getDashboardForPane(paneId);
  if(dash){
    const el = renderPanel(copied);
    $(dash).append(el);
    positionPanelEl(el, copied);
    bindInteract(); // Rebind interact for new panel
  }
  
  // Auto-select the copied panel
  setTimeout(() => {
    const $copiedEl = $(`.panel[data-id="${copied.id}"]`);
        if($copiedEl.length){
          clearSelection();
          $copiedEl.addClass("selected");
          selectedPanelId = copied.id;
        }
  }, 50);
}

/* =========================
   7) Merge / Split (logical)
========================= */
function doMerge(aId, bId){
  if(aId === bId) return;
  const a = getPanel(aId), b = getPanel(bId);
  if(!a || !b) return;

  pushUndo();

  const paneA = paneOf(aId)?.paneId;
  const paneB = paneOf(bId)?.paneId;
  // ì •ì±…: ë™ì¼ paneë§Œ merge í—ˆìš© (ìš´ì˜ ì•ˆì •ì„± ê´€ì )
  if(paneA !== paneB){
    alert("MergeëŠ” ë™ì¼ Pane ë‚´ íŒ¨ë„ë§Œ í—ˆìš©ë©ë‹ˆë‹¤.");
    return;
  }

  // create composite sections from each panel (already composite => include its sections)
  const secFromPanel = (p) => {
    if(p.type === "Composite" && p.composite?.sections){
      return p.composite.sections.map(s => ({...deepClone(s), sectionId: uid()}));
    }
    return [{
      sectionId: uid(),
      type: p.type,
      visible: true,
      title: p.title,
      data: deepClone(p.data || {})
    }];
  };

  const sections = [
    ...secFromPanel(a),
    ...secFromPanel(b)
  ];


  // layout: keep target(B) position, only expand size
  const ax2 = a.layout.x + a.layout.w;
  const ay2 = a.layout.y + a.layout.h;
  const bx2 = b.layout.x + b.layout.w;
  const by2 = b.layout.y + b.layout.h;
  const x = b.layout.x;
  const y = b.layout.y;
  const w = Math.min(STATE.grid.cols - x, Math.max(ax2, bx2) - x);
  const h = Math.max(1, Math.max(ay2, by2) - y);

  // choose preset based on types
  const types = sections.map(s=>s.type);
  let preset = "stack";
  if(types.includes("Progress") && types.includes("Issues")) preset = "kpiRight";
  else if(sections.length === 2) preset = "twoColumn";

  const merged = mkComposite(
    `í†µí•©: ${a.title} + ${b.title}`,
    "ğŸ§©",
    a.theme === "danger" || b.theme === "danger" ? "danger" : (a.theme === "warn" || b.theme === "warn" ? "warn" : "default"),
    {x,y,w,h},
    sections,
    preset
  );
  merged.updatedAt = nowIso();

  // remove both and insert merged
  removePanel(aId);
  removePanel(bId);
  addPanelToPane(paneA, merged);

  // keep position (no collision reflow on merge)

  mergeArmedId = null;
  markDirty();
  autosave();
  renderAll();
}

function doLogicalSplit(panelId, dir){
  const p = getPanel(panelId);
  if(!p) return;
  pushUndo();
  const paneId = paneOf(panelId)?.paneId || "p1";
  const pn = STATE.panes.find(x=>x.paneId===paneId);
  if(!pn) return;

  // Get pixel coordinates
  if(!p.layout.px) p.layout.px = {};
  const pxX = p.layout.px.x ?? (p.layout.x * 100);
  const pxY = p.layout.px.y ?? (p.layout.y * 100);
  const pxW = p.layout.px.w ?? (p.layout.w * 100);
  const pxH = p.layout.px.h ?? (p.layout.h * 100);

  // Composite: split sections into separate panels when 2+ sections
  if(p.type === "Composite"){
    const sections = (p.composite?.sections || []).filter(s => s && s.visible !== false);
    if(sections.length >= 2){
      const newPanels = [];
      const count = sections.length;
      for(let i = 0; i < count; i++){
        const sec = sections[i];
        const title = sec.title || sec.type || "íŒ¨ë„";
        const np = mkPanel(sec.type || "Worklog", title, "ğŸ“Œ", p.theme || "default", {x:0,y:0,w:1,h:1}, deepClone(sec.data || {}));
        np.layout.px = { x: pxX, y: pxY, w: pxW, h: pxH };
        if(dir === "V"){
          const w1 = Math.floor(pxW / count);
          const w = (i === count - 1) ? (pxW - w1 * (count - 1)) : w1;
          np.layout.px.x = pxX + w1 * i;
          np.layout.px.y = pxY;
          np.layout.px.w = w;
          np.layout.px.h = pxH;
        }else{
          const h1 = Math.floor(pxH / count);
          const h = (i === count - 1) ? (pxH - h1 * (count - 1)) : h1;
          np.layout.px.x = pxX;
          np.layout.px.y = pxY + h1 * i;
          np.layout.px.w = pxW;
          np.layout.px.h = h;
        }
        np.layout.x = Math.round(np.layout.px.x / 100);
        np.layout.y = Math.round(np.layout.px.y / 100);
        np.layout.w = Math.max(1, Math.round(np.layout.px.w / 100));
        np.layout.h = Math.max(1, Math.round(np.layout.px.h / 100));
        newPanels.push(np);
      }
      removePanel(panelId);
      pn.panels.push(...newPanels);
      markDirty();
      autosave();
      renderAll();
      return;
    }
  }

  // ìµœì†Œ í¬ê¸° ì²´í¬ (í”½ì…€ ê¸°ì¤€)
  if(dir === "V" && pxW < 100){
    alert("ê°€ë¡œ ë¶„ë¦¬ë¥¼ ìœ„í•´ íŒ¨ë„ ë„ˆë¹„ê°€ ìµœì†Œ 100px ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
    return;
  }
  if(dir === "H" && pxH < 100){
    alert("ì„¸ë¡œ ë¶„ë¦¬ë¥¼ ìœ„í•´ íŒ¨ë„ ë†’ì´ê°€ ìµœì†Œ 100px ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
    return;
  }

  const newP = mkPanel("Worklog", "ì‹ ê·œ íŒ¨ë„", "ğŸ“‹", "default", {x:0,y:0,w:1,h:1}, {
    items:[{t:"ìƒˆ ì‘ì—…", time:"--:--"}]
  });

  if(dir === "V"){
    // Horizontal split (left/right)
    const w1 = Math.floor(pxW / 2);
    const w2 = pxW - w1;
    
    // Update original panel (left)
    p.layout.px.x = pxX;
    p.layout.px.y = pxY;
    p.layout.px.w = w1;
    p.layout.px.h = pxH;
    
    // New panel (right)
    newP.layout.px = {
      x: pxX + w1,
      y: pxY,
      w: w2,
      h: pxH
    };
  }else{
    // Vertical split (top/bottom)
    const h1 = Math.floor(pxH / 2);
    const h2 = pxH - h1;
    
    // Update original panel (top)
    p.layout.px.x = pxX;
    p.layout.px.y = pxY;
    p.layout.px.w = pxW;
    p.layout.px.h = h1;
    
    // New panel (bottom)
    newP.layout.px = {
      x: pxX,
      y: pxY + h1,
      w: pxW,
      h: h2
    };
  }

  // Update grid coordinates for both panels
  p.layout.x = Math.round(p.layout.px.x / 100);
  p.layout.y = Math.round(p.layout.px.y / 100);
  p.layout.w = Math.max(1, Math.round(p.layout.px.w / 100));
  p.layout.h = Math.max(1, Math.round(p.layout.px.h / 100));
  
  newP.layout.x = Math.round(newP.layout.px.x / 100);
  newP.layout.y = Math.round(newP.layout.px.y / 100);
  newP.layout.w = Math.max(1, Math.round(newP.layout.px.w / 100));
  newP.layout.h = Math.max(1, Math.round(newP.layout.px.h / 100));

  // Add new panel
  pn.panels.push(newP);

  markDirty();
  autosave();
  
  // Update both panels in DOM
  const $originalEl = $(`.panel[data-id="${p.id}"]`);
  if($originalEl.length){
    positionPanelEl($originalEl[0], p);
  }
  
  // Render new panel
  const dash = getDashboardForPane(paneId);
  if(dash){
    const el = renderPanel(newP);
    $(dash).append(el);
    positionPanelEl(el, newP);
    bindInteract(); // Rebind interact for new panel
  }

  // open settings immediately
  setTimeout(() => openSettings(newP.id), 100);
}

/* =========================
   8) Settings modal
========================= */
function initIconSelect(){
  UI.fIcon.html(ICONS.map(x => `<option value="${escapeAttr(x)}">${escapeHtml(x)}</option>`).join(""));
}
initIconSelect();

let editingPanelId = null;

function updateColorPreviews(){
  const bg = UI.fColor.val() || "#ffffff";
  const border = UI.fBorderColor.val() || "#f5b94a";
  $("#fColorInner").css({ background: bg, borderColor: bg });
  $("#fBorderColorInner").css({ background: "transparent", borderColor: border });
}

function getSalesCdOptions(){
  const set = new Set();
  (STATE?.panes || []).forEach(pn => {
    (pn.panels || []).forEach(p => {
      const v = p?.data?.cardSummary?.salesCd;
      if(v) set.add(String(v));
    });
  });
  return Array.from(set);
}

function fillSalesCdOptions(current){
  const list = getSalesCdOptions();
  if(current && !list.includes(String(current))) list.unshift(String(current));
  const opts = ['<option value="">-</option>']
    .concat(list.map(v => `<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`));
  UI.fSalesCd.html(opts.join(""));
}

const REFRESH_TIMERS = new Map();

function clearRefreshTimers(){
  REFRESH_TIMERS.forEach((t) => clearInterval(t));
  REFRESH_TIMERS.clear();
}

function setupRefreshTimers(){
  clearRefreshTimers();
  STATE.panes.forEach(pn => {
    pn.panels.forEach(p => {
      const cfg = p.refresh || {};
      if(cfg.enabled && cfg.minutes && cfg.minutes > 0){
        const ms = cfg.minutes * 60 * 1000;
        const timer = setInterval(() => refreshPanel(p.id), ms);
        REFRESH_TIMERS.set(p.id, timer);
      }
    });
  });
}

function mockFetchPanelData(p){
  return new Promise((resolve) => {
    setTimeout(() => {
      const data = deepClone(p.data || {});
      data.cardSummary = data.cardSummary || {};
      data.cardSummary.last = new Date().toLocaleString("ko-KR");

      if(p.type === "Issues"){
        data.open = Math.max(0, (data.open ?? 0) + (Math.random() < 0.5 ? -1 : 1));
      }
      if(p.type === "Progress"){
        data.percent = clamp((data.percent ?? 0) + (Math.random() < 0.5 ? -1 : 1), 0, 100);
      }
      resolve(data);
    }, 300);
  });
}

function refreshPanel(panelId){
  const p = getPanel(panelId);
  if(!p) return;
  // sample backend fetch
  mockFetchPanelData(p).then((newData) => {
    p.data = newData;
    p.updatedAt = nowIso();
    markDirty();
    autosave();
    renderAll();
  });
}

function openSettings(panelId){
  const p = getPanel(panelId);
  if(!p) return;
  editingPanelId = panelId;

  UI.modalTitle.text(`íŒ¨ë„ ì„¤ì •: ${p.title}`);
  UI.fTitle.val(p.title || "");
  UI.fType.val(p.type || "Worklog");
  const currentSalesCd = p?.data?.cardSummary?.salesCd || "";
  fillSalesCdOptions(currentSalesCd);
  UI.fSalesCd.val(currentSalesCd);
  UI.fIcon.val(p.icon || "ğŸ“‹");
  UI.fTheme.val(p.theme || "default");
  const isComposite = p.type === "Composite";
  const sectionCount = (p.composite?.sections || []).filter(s => s && s.visible !== false).length;
  if(isComposite && sectionCount >= 2){
    UI.compositeLayoutRow.show();
    UI.fCompositeLayout.val(p.composite?.layout || "stack");
  }else{
    UI.compositeLayoutRow.hide();
  }
  UI.fColor.val((p.style && p.style.bg) ? p.style.bg : "#ffffff");
  UI.fBorderColor.val((p.style && p.style.border) ? p.style.border : "#f5b94a");
  updateColorPreviews();
  UI.fRefreshOn.prop("checked", !!(p.refresh && p.refresh.enabled));
  UI.fRefreshMin.val((p.refresh && p.refresh.minutes) ? p.refresh.minutes : 5);

  // data JSON
  UI.fData.val(JSON.stringify(deepClone(p), null, 2));

  showModal(UI.modalBack, true);
}

function closeSettings(){
  editingPanelId = null;
  showModal(UI.modalBack, false);
}

$("#modalClose").on("click", closeSettings);
UI.modalBack.on("click", (e) => {
  if(e.target === UI.modalBack[0]) closeSettings();
});
$("#btnValidate").on("click", () => {
  const parsed = safeJsonParse(UI.fData.val());
  alert(parsed.ok ? "JSON ìœ íš¨í•©ë‹ˆë‹¤." : ("JSON ì˜¤ë¥˜: " + parsed.err.message));
});

UI.fColor.on("input", updateColorPreviews);
UI.fBorderColor.on("input", updateColorPreviews);
$("#btnSave").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  if(!editingPanelId) return;
  const p = getPanel(editingPanelId);
  if(!p) return;

  // primary fields
  p.title = UI.fTitle.val().trim() || p.title;
  p.type = UI.fType.val();
  p.icon = UI.fIcon.val();
  p.theme = UI.fTheme.val();
  const colorVal = UI.fColor.val();
  if(colorVal){
    p.style = p.style || {};
    p.style.bg = colorVal;
  }else if(p.style){
    delete p.style.bg;
  }
  const borderVal = UI.fBorderColor.val();
  if(borderVal){
    p.style = p.style || {};
    p.style.border = borderVal;
  }else if(p.style){
    delete p.style.border;
  }

  // data field (strict JSON)
  const parsed = safeJsonParse(UI.fData.val());
  if(!parsed.ok){
    alert("JSONì´ ìœ íš¨í•˜ì§€ ì•Šì•„ ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n" + parsed.err.message);
    return;
  }

  // apply full json if provided, while keeping id
  const v = parsed.val || {};
  if(v && typeof v === "object"){
    const keepId = p.id;
    Object.assign(p, v);
    p.id = keepId;
  }
  // re-apply UI-controlled fields so changes are not overwritten by JSON
  p.title = UI.fTitle.val().trim() || p.title;
  p.type = UI.fType.val();
  if(p.type === "Composite"){
    p.composite = p.composite || { sections: [], layout: "stack" };
    p.composite.layout = UI.fCompositeLayout.val() || p.composite.layout || "stack";
  }
  p.icon = UI.fIcon.val();
  p.theme = UI.fTheme.val();
  p.data = (p.data && typeof p.data === "object") ? p.data : {};
  const salesCdVal = UI.fSalesCd.val();
  p.data.cardSummary = p.data.cardSummary || {};
  if(salesCdVal){
    p.data.cardSummary.salesCd = salesCdVal;
  }else{
    delete p.data.cardSummary.salesCd;
  }
  if(p.type === "Composite"){
    // ensure composite
    p.composite = (v.composite && typeof v.composite === "object") ? v.composite : (p.composite || {sections:[],layout:"stack"});
    if(!Array.isArray(p.composite.sections)) p.composite.sections = [];
    p.composite.layout = UI.fCompositeLayout.val() || p.composite.layout || "stack";
  }else{
    delete p.composite;
  }
  const refreshOn = UI.fRefreshOn.is(":checked");
  const refreshMin = Math.max(1, parseInt(UI.fRefreshMin.val(), 10) || 5);
  p.refresh = { enabled: refreshOn, minutes: refreshMin };
  p.updatedAt = nowIso();

  markDirty();
  autosave();
  renderAll();
  setupRefreshTimers();
  closeSettings();
});

/* =========================
   9) Export / Import
========================= */
function openJsonModal(title, value, hint){
  UI.jsonTitle.text(title);
  UI.jsonArea.val(value || "");
  UI.jsonHint.text(hint || "");
  showModal(UI.jsonBack, true);
}
function closeJsonModal(){
  showModal(UI.jsonBack, false);
}
$("#jsonClose").on("click", closeJsonModal);
UI.jsonBack.on("click", (e) => {
  if(e.target === UI.jsonBack[0]) closeJsonModal();
});
$("#jsonCopy").on("click", async () => {
  try{
    await navigator.clipboard.writeText(UI.jsonArea.val());
    alert("í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.");
  }catch(e){
    alert("ë³µì‚¬ ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.");
  }
});
$("#jsonApply").on("click", () => {
  const parsed = safeJsonParse(UI.jsonArea.val());
  if(!parsed.ok){
    alert("JSON ì˜¤ë¥˜: " + parsed.err.message);
    return;
  }
  const obj = parsed.val;
  // minimal validation
  if(!obj || typeof obj !== "object" || !obj.grid || !obj.panes){
    alert("ìŠ¤í‚¤ë§ˆê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (grid/panes ëˆ„ë½)");
    return;
  }
  STATE = obj;
  // normalize
  if(!STATE.split) STATE.split = {enabled:false,direction:"vertical",panes:[{paneId:"p1",ratio:1}]};
  if(!STATE.meta) STATE.meta = {savedAt: nowIso(), version:1};

  // ensure panes
  if(STATE.layoutMode === "split"){
    ensurePanes(STATE.split.panes.length);
  }else{
    ensurePanes(2);
  }

  applyCssVars();
  renderAll();
  markDirty();
  autosave();
  closeJsonModal();
});

/* =========================
   10) Context menu
========================= */
function openCtxMenu(x,y,panelId){
  ctxPanelId = panelId;
  UI.ctxMenu.data("panelId", panelId || "");

  UI.ctxMenu.css({ left: x + "px", top: y + "px" }).show();
}
function closeCtxMenu(){
  UI.ctxMenu.hide();
  ctxPanelId = null;
  UI.ctxMenu.data("panelId", "");
}
$("body").on("click", (e) => {
  if(UI.ctxMenu.is(":visible")){
    if(!$(e.target).closest(".ctx").length){
      closeCtxMenu();
    }
  }
});

UI.ctxMenu.on("click", (e) => {
  e.stopPropagation();
  const item = $(e.target).closest(".item")[0];
  const panelId = ctxPanelId || UI.ctxMenu.data("panelId");
  if(!item || !panelId) return;
  const act = item.dataset.act;
  const canEdit = AUTH_STATE.canEdit;

  if(act === "settings"){
    if(!canEdit) return;
    closeCtxMenu();
    openSettings(panelId);
    return;
  }
  if(act === "copy"){
    if(!canEdit) return;
    closeCtxMenu();
    doCopyPanel(panelId);
    return;
  }
  if(act === "zFront"){
    if(!canEdit) return;
    closeCtxMenu();
    pushUndo();
    bringPanelToFront(panelId);
    markDirty();
    autosave();
    renderAll();
    return;
  }
  if(act === "zBack"){
    if(!canEdit) return;
    closeCtxMenu();
    pushUndo();
    sendPanelToBack(panelId);
    markDirty();
    autosave();
    renderAll();
    return;
  }
  if(act === "splitH"){
    if(!canEdit) return;
    closeCtxMenu();
	doLogicalSplit(panelId, "V"); // "ê°€ë¡œ ë¶„í• " => ì¢Œìš° ë‚˜ëˆ„ê¸°
	return;
  }
  if(act === "splitV"){
    if(!canEdit) return;
    closeCtxMenu();
	doLogicalSplit(panelId, "H"); // "ì„¸ë¡œ ë¶„í• " => ìƒí•˜ ë‚˜ëˆ„ê¸°
	return;
  }
  if(act === "armMerge"){
    if(!canEdit) return;
    mergeArmedId = panelId;
    closeCtxMenu();
    armMergeUi(true);
    return;
  }
  if(act === "remove"){
    if(!canEdit) return;
    closeCtxMenu();
    if(confirm("ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")){
      pushUndo();
      const panelEl = $(`.panel[data-id="${panelId}"]`)[0];
      removePanel(panelId);
      
      // Remove from DOM
      if(panelEl){
        panelEl.remove();
      }
      
      // Clear selection if deleted panel was selected
      if(selectedPanelId === panelId){
        selectedPanelId = null;
      }
      
      markDirty();
      autosave();
    }
    return;
  }
});

function armMergeUi(on){
  $(".panel").removeClass("mergeArmed");
  if(on && mergeArmedId){
    const $srcEl = $(`.panel[data-id="${mergeArmedId}"]`);
    if($srcEl.length) $srcEl.addClass("mergeArmed");
    UI.helpHint.text("Merge ëŒ€ê¸°: ëŒ€ìƒ íŒ¨ë„ì„ í´ë¦­í•˜ì„¸ìš” (ESC ì·¨ì†Œ)");
  }else{
    UI.helpHint.text("íŒ: Shift+ë“œë = Merge");
  }
}

$("body").on("keydown", (e) => {
  if(e.key === "Shift") SHIFT_DOWN = true;
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "c"){
    if(selectedPanelId){
      const p = getPanel(selectedPanelId);
      if(p){
        CLIPBOARD_PANEL = deepClone(p);
      }
    }
    return;
  }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "v"){
    if(CLIPBOARD_PANEL){
      e.preventDefault();
      pushUndo();
      const paneId = (STATE.layoutMode === "split")
        ? (findPaneAt(LAST_MOUSE_POS.x, LAST_MOUSE_POS.y) || paneOf(selectedPanelId)?.paneId || "p1")
        : "p1";
      const pn = STATE.panes.find(x=>x.paneId===paneId);
      if(!pn) return;

      const copied = deepClone(CLIPBOARD_PANEL);
      copied.id = uid();
      copied.title = (copied.title || "íŒ¨ë„") + " (ë³µì‚¬ë³¸)";

      const dash = getDashboardForPane(paneId);
      const dashRect = dash ? (getRectFromEl($(dash))) : { left: 0, top: 0 };
      const left = Math.max(0, Math.round((LAST_MOUSE_POS.x - dashRect.left) / 10) * 10);
      const top = Math.max(0, Math.round((LAST_MOUSE_POS.y - dashRect.top) / 10) * 10);

      if(!copied.layout.px) copied.layout.px = {};
      copied.layout.px.x = left;
      copied.layout.px.y = top;
      copied.layout.px.w = copied.layout.px.w ?? (copied.layout.w * 100);
      copied.layout.px.h = copied.layout.px.h ?? (copied.layout.h * 100);

      copied.layout.x = Math.round(copied.layout.px.x / 100);
      copied.layout.y = Math.round(copied.layout.px.y / 100);
      copied.layout.w = Math.max(1, Math.round(copied.layout.px.w / 100));
      copied.layout.h = Math.max(1, Math.round(copied.layout.px.h / 100));

      pn.panels.push(copied);

      const el = renderPanel(copied);
      if(dash) $(dash).append(el);
      positionPanelEl(el, copied);
      bindInteract();

      clearSelection();
      $(el).addClass("selected");
      selectedPanelId = copied.id;

      markDirty();
      autosave();
    }
    return;
  }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z"){
    e.preventDefault();
    undo();
    return;
  }
  if(e.key === "Escape"){
    mergeArmedId = null;
    armMergeUi(false);
    closeCtxMenu();
    closeSettings();
    closeJsonModal();
  }
  if(e.key === "Enter" && selectedPanelId){
    openSettings(selectedPanelId);
  }
});

$("body").on("keyup", (e) => {
  if(e.key === "Shift") SHIFT_DOWN = false;
});

/* Merge armed click target */
$("body").on("click", (e) => {
  if(!mergeArmedId) return;
  const panelEl = $(e.target).closest(".panel")[0];
  if(!panelEl) return;
  const tgt = panelEl.dataset.id;
  if(!tgt || tgt === mergeArmedId) return;
  doMerge(mergeArmedId, tgt);
  mergeArmedId = null;
  armMergeUi(false);
});

$("body").on("mousemove", (e) => {
  LAST_MOUSE_POS.x = e.clientX;
  LAST_MOUSE_POS.y = e.clientY;
});

/* =========================
   10.4) Paste image at mouse position
========================= */
function addImagePanelAt(x, y, dataUrl, naturalW, naturalH){
  pushUndo();

  const paneId = (STATE.layoutMode === "split")
    ? (findPaneAt(x, y) || "p1")
    : "p1";
  const pn = STATE.panes.find(p => p.paneId === paneId);
  if(!pn) return;

  const dash = getDashboardForPane(paneId);
  const dashRect = dash ? (getRectFromEl($(dash))) : { left: 0, top: 0 };
  const snap = 10;

  const baseW = Math.max(100, naturalW || 320);
  const baseH = Math.max(100, naturalH || 220);
  const pxX = Math.max(0, Math.round((x - dashRect.left) / snap) * snap);
  const pxY = Math.max(0, Math.round((y - dashRect.top) / snap) * snap);
  const pxW = Math.max(100, Math.round(baseW / snap) * snap);
  const pxH = Math.max(100, Math.round(baseH / snap) * snap);

  const p = mkPanel("Image", "ì´ë¯¸ì§€", "ğŸ–¼ï¸", "default", {x:0,y:0,w:1,h:1}, {
    src: dataUrl
  });
  p.layout.px = { x: pxX, y: pxY, w: pxW, h: pxH };
  p.layout.x = Math.round(pxX / 100);
  p.layout.y = Math.round(pxY / 100);
  p.layout.w = Math.max(1, Math.round(pxW / 100));
  p.layout.h = Math.max(1, Math.round(pxH / 100));

  const resolved = resolveCollision(paneId, p.id, panelRect(p));
  p.layout.x = resolved.x;
  p.layout.y = resolved.y;
  if(p.layout.px){
    p.layout.px.x = p.layout.x * 100;
    p.layout.px.y = p.layout.y * 100;
  }

  pn.panels.push(p);
  markDirty();
  autosave();
  renderAll();
}

$("body").on("paste", (e) => {
  const items = e.originalEvent?.clipboardData?.items || [];
  const item = Array.from(items).find(it => it.type && it.type.startsWith("image/"));
  if(!item) return;

  const file = item.getAsFile();
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    const img = new Image();
    img.onload = () => {
      addImagePanelAt(LAST_MOUSE_POS.x, LAST_MOUSE_POS.y, String(evt.target.result), img.naturalWidth, img.naturalHeight);
    };
    img.src = String(evt.target.result);
  };
  reader.readAsDataURL(file);
});

/* =========================
   10.5) Auto arrange
========================= */
function autoArrangePanels(){
  pushUndo();
  const gap = STATE.grid?.gap ?? 12;
  const snap = 10;

  const setPanelPos = (p, x, y, w, h) => {
    if(!p.layout.px) p.layout.px = {};
    p.layout.px.x = Math.max(0, Math.round(x / snap) * snap);
    p.layout.px.y = Math.max(0, Math.round(y / snap) * snap);
    p.layout.px.w = Math.max(100, Math.round(w / snap) * snap);
    p.layout.px.h = Math.max(100, Math.round(h / snap) * snap);

    p.layout.x = Math.round(p.layout.px.x / 100);
    p.layout.y = Math.round(p.layout.px.y / 100);
    p.layout.w = Math.max(1, Math.round(p.layout.px.w / 100));
    p.layout.h = Math.max(1, Math.round(p.layout.px.h / 100));
  };

  const arrangeList = (panels, dashEl) => {
    if(!dashEl) return;
    const dashWidth = Math.max(100, Math.floor($(dashEl).outerWidth() || 0));
    let x = 0;
    let y = 0;
    let rowH = 0;

    panels.filter(p => p.type !== "Image").forEach(p => {
      const baseW = p.layout.px?.w ?? (p.layout.w * 100);
      const baseH = p.layout.px?.h ?? (p.layout.h * 100);
      const w = Math.max(100, Math.round(baseW / snap) * snap);
      const h = Math.max(100, Math.round(baseH / snap) * snap);

      if(x > 0 && x + w > dashWidth){
        x = 0;
        y += rowH + gap;
        rowH = 0;
      }

      setPanelPos(p, x, y, w, h);
      x += w + gap;
      rowH = Math.max(rowH, h);

      const $el = $(`.panel[data-id="${p.id}"]`);
      if($el.length) positionPanelEl($el[0], p);
    });
  };

  if(STATE.layoutMode === "split"){
    STATE.panes.forEach(paneObj => {
      const dash = $(`.dashboard[data-pane-id="${paneObj.paneId}"]`)[0];
      arrangeList(paneObj.panels, dash);
    });
  }else{
    // grid/flow: render to the first dashboard
    const dash = $(".dashboard")[0];
    const allPanels = STATE.panes.flatMap(p => p.panels);
    arrangeList(allPanels, dash);
  }

  markDirty();
  autosave();
}

/* =========================
   11) Toolbar actions
========================= */
function setMode(mode){
  STATE.layoutMode = mode;
  // split enable flag
  STATE.split.enabled = (mode === "split");

  // UI
  $("#btnGrid").toggleClass("active", mode==="grid");
  $("#btnSplit").toggleClass("active", mode==="split");
  $("#btnFlow").toggleClass("active", mode==="flow");

  markDirty();
  autosave();
  renderAll();
  if(mode === "grid"){
    // snapshot split layout so we can restore later
    if(!SPLIT_LAYOUT_SNAPSHOT){
      SPLIT_LAYOUT_SNAPSHOT = deepClone(STATE.panes);
    }
    autoArrangePanels();
  }else if(mode === "split"){
    if(SPLIT_LAYOUT_SNAPSHOT){
      STATE.panes = deepClone(SPLIT_LAYOUT_SNAPSHOT);
      SPLIT_LAYOUT_SNAPSHOT = null;
      renderAll();
    }
  }
}

$("#btnGrid").on("click", () => setMode("grid"));
$("#btnSplit").on("click", () => setMode("split"));
$("#btnFlow").on("click", () => setMode("flow"));

$("#btnDir").on("click", () => {
  // toggle split direction
  STATE.split.direction = (STATE.split.direction === "vertical") ? "horizontal" : "vertical";
  $("#btnDir").text("Split: " + DIR_LABEL());
  if(STATE.layoutMode === "split"){
    markDirty();
    autosave();
    renderAll();
  }else{
    markDirty();
    autosave();
  }
});

$("#btnPanes").on("click", () => {
  PANE_COUNT = (STATE.split.panes.length === 2) ? 3 : 2;
  ensurePanes(PANE_COUNT);
  // default ratios
  STATE.split.panes.forEach(p => p.ratio = 1 / PANE_COUNT);
  $("#btnPanes").text("Pane: " + PANE_COUNT);
  markDirty();
  autosave();
  renderAll();
});

$("#btnAdd").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  const paneId = (STATE.layoutMode === "split") ? STATE.split.panes[0].paneId : "p1";
  const pn = STATE.panes.find(x=>x.paneId===paneId);
  if(!pn) return;

  const p = mkPanel("Worklog", "ì‹ ê·œ ì‘ì—…", "ğŸ“‹", "default", {x:0,y:0,w:4,h:2}, {
    items:[{t:"ìƒˆ ì‘ì—… í•­ëª©", time:"--:--"}]
  });

  // find first free spot
  const resolved = resolveCollision(paneId, p.id, panelRect(p));
  p.layout.x = resolved.x;
  p.layout.y = resolved.y;

  pn.panels.push(p);
  markDirty();
  autosave();
  renderAll();
  openSettings(p.id);
});

$("#btnAuto").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  autoArrangePanels();
});
$("#btnUndo").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  undo();
});

$("#btnExport").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  openJsonModal("ë‚´ë³´ë‚´ê¸°: ë ˆì´ì•„ì›ƒ JSON", JSON.stringify(STATE, null, 2), "ë³µì‚¬ í›„ ë³„ë„ ë³´ê´€ ë˜ëŠ” ì„œë²„ ì €ì¥ APIë¡œ ì „ì†¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
  // export modal does not apply by default (apply button still available)
});
$("#btnImport").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  openJsonModal("ê°€ì ¸ì˜¤ê¸°: ë ˆì´ì•„ì›ƒ JSON", "", "ì—¬ê¸°ì— JSONì„ ë¶™ì—¬ë„£ê³  [ì ìš©]ì„ ëˆ„ë¥´ì„¸ìš”. (ìŠ¤í‚¤ë§ˆ ì˜¤ë¥˜ ì‹œ ì ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)");
});
$("#btnReset").on("click", () => {
  if(!AUTH_STATE.canEdit) return;
  if(confirm("ì €ì¥ëœ ë ˆì´ì•„ì›ƒì„ ì‚­ì œí•˜ê³  ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦¬ê² ìŠµë‹ˆê¹Œ?")){
    resetState();
  }
});

function showModal(backEl, on){
  backEl.css("display", on ? "flex" : "none");
  backEl.attr("aria-hidden", on ? "false" : "true");
}

// Help modal handlers
function closeHelp(){
  showModal(UI.helpBack, false);
}
$("#btnHelp").on("click", () => showModal(UI.helpBack, true));
$("#helpClose").on("click", closeHelp);
$("#helpOk").on("click", closeHelp);
UI.helpBack.on("click", (e) => {
  if(e.target === UI.helpBack[0]) closeHelp();
});

/* =========================
   12) Selection helpers
========================= */
function clearSelection(){
  $(".panel.selected").removeClass("selected");
}

$("body").on("keydown", (e) => {
  if(!selectedPanelId) return;
  if(STATE.layoutMode === "flow") return;

  const p = getPanel(selectedPanelId);
  if(!p) return;

  const paneId = paneOf(selectedPanelId)?.paneId || "p1";
  let moved = false;

  const step = 1;
  if(e.key === "ArrowLeft"){ p.layout.x = Math.max(0, p.layout.x - step); moved = true; }
  if(e.key === "ArrowRight"){ p.layout.x = Math.min(STATE.grid.cols - p.layout.w, p.layout.x + step); moved = true; }
  if(e.key === "ArrowUp"){ p.layout.y = Math.max(0, p.layout.y - step); moved = true; }
  if(e.key === "ArrowDown"){ p.layout.y = Math.max(0, p.layout.y + step); moved = true; }

  // ctrl+arrow => resize
  if(e.ctrlKey){
    moved = false;
    if(e.key === "ArrowLeft"){ p.layout.w = Math.max(1, p.layout.w - 1); moved = true; }
    if(e.key === "ArrowRight"){ p.layout.w = Math.min(STATE.grid.cols, p.layout.w + 1); moved = true; }
    if(e.key === "ArrowUp"){ p.layout.h = Math.max(1, p.layout.h - 1); moved = true; }
    if(e.key === "ArrowDown"){ p.layout.h = Math.min(50, p.layout.h + 1); moved = true; }
    // clamp x
    p.layout.x = clamp(p.layout.x, 0, STATE.grid.cols - p.layout.w);
  }

  if(moved){
    const resolved = resolveCollision(paneId, selectedPanelId, panelRect(p));
    p.layout.x = resolved.x; p.layout.y = resolved.y;
    markDirty();
    autosave();
    renderAll();
    e.preventDefault();
  }
});

/* =========================
   13) Startup
========================= */
(function init(){
  updateAuthState();
  setReadOnlyUI();
  const loaded = loadState();
  STATE = loaded || defaultState();

  // normalize, ensure required
  if(!STATE.grid) STATE.grid = {cols:12,rowHeight:92,gap:12};
  if(!STATE.split) STATE.split = {enabled:true,direction:"vertical",panes:[{paneId:"p1",ratio:.55},{paneId:"p2",ratio:.45}]};
  if(!STATE.panes) STATE.panes = [{paneId:"p1",panels:[]},{paneId:"p2",panels:[]}];
  if(!STATE.meta) STATE.meta = {savedAt: nowIso(), version: 1};

  ensurePanes(STATE.split.panes.length || 2);

  applyCssVars();
  $("#btnDir").text("Split: " + DIR_LABEL());
  $("#btnPanes").text("Pane: " + (STATE.split.panes.length || 2));

  // mode buttons
  $("#btnGrid").toggleClass("active", STATE.layoutMode==="grid");
  $("#btnSplit").toggleClass("active", STATE.layoutMode==="split");
  $("#btnFlow").toggleClass("active", STATE.layoutMode==="flow");

  renderAll();
  markSaved();
  armMergeUi(false);
  setupRefreshTimers();
  
  // Generate rulers after initial render
  setTimeout(() => {
    generateRulers();
  }, 100);
})();
});
</script>

<!--
  ====== (ì°¸ê³ ) ì„œë²„ ì €ì¥/ì¡°íšŒ API ìŠ¤í™ (ìƒ˜í”Œ) ======
  POST   /user/wb/wb06/selectLayoutList
  POST   /user/wb/wb06/selectLayout
  POST   /user/wb/wb06/saveLayout
  PUT    /user/wb/wb06/setDefaultLayout
  DELETE /user/wb/wb06/deleteLayout

  ====== (ì°¸ê³ ) í…Œì´ë¸” DDL ======
  CREATE TABLE TB_WB06_DASH_LAYOUT (
      LAYOUT_ID       VARCHAR2(32)   NOT NULL,
      OWNER_USER_ID   VARCHAR2(40)   NOT NULL,
      SCOPE_CD        VARCHAR2(10)   DEFAULT 'USER' NOT NULL,
      LAYOUT_NM       VARCHAR2(100)  NOT NULL,
      LAYOUT_JSON     CLOB           NOT NULL,
      DEFAULT_YN      CHAR(1)        DEFAULT 'N' NOT NULL,
      USE_YN          CHAR(1)        DEFAULT 'Y' NOT NULL,
      REG_ID          VARCHAR2(40),
      REG_DTTM        DATE           DEFAULT SYSDATE,
      UPD_ID          VARCHAR2(40),
      UPD_DTTM        DATE,
      CONSTRAINT PK_TB_WB06_DASH_LAYOUT PRIMARY KEY (LAYOUT_ID)
  );
  CREATE INDEX IX_TB_WB06_DASH_LAYOUT_01 ON TB_WB06_DASH_LAYOUT (OWNER_USER_ID, SCOPE_CD);

  ====== (ì°¸ê³ ) ì»¬ëŸ¼ ì •ì˜ í‘œ ======
  | ì»¬ëŸ¼ëª…        | íƒ€ì…           | ì„¤ëª… |
  |-------------|----------------|------|
  | LAYOUT_ID   | VARCHAR2(32)   | ë ˆì´ì•„ì›ƒ ID (UUID 32) |
  | OWNER_USER_ID | VARCHAR2(40) | ì†Œìœ ì ì‚¬ìš©ì ID |
  | SCOPE_CD    | VARCHAR2(10)   | ë²”ìœ„(USER/COMMON) |
  | LAYOUT_NM   | VARCHAR2(100)  | ë ˆì´ì•„ì›ƒ ì´ë¦„ |
  | LAYOUT_JSON | CLOB           | ë ˆì´ì•„ì›ƒ JSON ë³¸ë¬¸ |
  | DEFAULT_YN  | CHAR(1)        | ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ì—¬ë¶€(Y/N) |
  | USE_YN      | CHAR(1)        | ì‚¬ìš© ì—¬ë¶€(Y/N) |
  | REG_ID      | VARCHAR2(40)   | ë“±ë¡ì ID |
  | REG_DTTM    | DATE           | ë“±ë¡ ì¼ì‹œ |
  | UPD_ID      | VARCHAR2(40)   | ìˆ˜ì •ì ID |
  | UPD_DTTM    | DATE           | ìˆ˜ì • ì¼ì‹œ |

  ====== (ì°¸ê³ ) ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ì¡°íšŒ/ì €ì¥ íŒŒë¼ë¯¸í„° ìƒ˜í”Œ ======
  [ëª©ë¡ ì¡°íšŒ] /user/wb/wb06/selectLayoutList
  {
    "ownerUserId": "U0001",
    "scopeCd": "USER"
  }

  [ë‹¨ê±´ ì¡°íšŒ] /user/wb/wb06/selectLayout
  {
    "layoutId": "A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6"
  }

  [ì €ì¥] /user/wb/wb06/saveLayout
  {
    "layoutId": "A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6",
    "ownerUserId": "U0001",
    "scopeCd": "USER",
    "layoutNm": "ë‚´ ëŒ€ì‹œë³´ë“œ",
    "layoutJson": "{...}",
    "defaultYn": "Y",
    "useYn": "Y",
    "regId": "U0001",
    "updId": "U0001"
  }

  [ê¸°ë³¸ ì§€ì •] /user/wb/wb06/setDefaultLayout
  {
    "layoutId": "A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6",
    "ownerUserId": "U0001",
    "scopeCd": "USER",
    "updId": "U0001"
  }

  [ì‚­ì œ] /user/wb/wb06/deleteLayout
  {
    "layoutId": "A1B2C3D4E5F6G7H8I9J0K1L2M3N4O5P6",
    "updId": "U0001"
  }
-->
</body>
</html>
