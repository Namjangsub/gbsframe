<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8" />
	<title>WB1001M01 Drawing Editor</title>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=0.6, user-scalable=no">
	<link rel="icon" href="/static/favicon.ico" type="image/x-icon">

	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-theme.min.css">
	<link rel="stylesheet" href="/static/bootstrap/css/dashboard.css">
	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-datepicker.css">
	<link rel="stylesheet" href="/static/fontawesome/css/all.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5grid.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5mask.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5modal.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5toast.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5menu.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5calendar.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5picker.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5select.css">
	<link rel="stylesheet" href="/static/css/jstree/style.min.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5combobox.css">
	<link rel="stylesheet" href="/static/css/gnb.css">
	<link rel="stylesheet" href="/static/css/main.css">
	<link rel="stylesheet" href="/static/css/sub.css">
	<link rel="stylesheet" href="/static/css/common.css">
	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-multiselect.css">

	<style>
		#wb1001m01-editor {
			--wb-editor-primary: #2563eb;
			--wb-editor-primary-hover: #1d4ed8;
			--wb-editor-bg-dark: #1e293b;
			--wb-editor-border: #e2e8f0;
			--wb-editor-text: #334155;
			--wb-editor-text-light: #64748b;
			--wb-editor-toolbar-width: 60px;
			--wb-editor-properties-width: 240px;
			--wb-editor-header-height: 50px;
			width: 100%;
			height: 100%;
		}

		#wb1001m01-editor .editor-wrapper {
			display: flex;
			flex-direction: column;
			height: calc(100vh - 165px);
			position: relative;
			border: 1px solid var(--wb-editor-border);
			border-radius: 12px;
			background: #fff;
			overflow: hidden;
		}

		#wb1001m01-editor .editor-body {
			display: flex;
			flex: 1;
			position: relative;
			overflow: hidden;
		}

		#wb1001m01-editor .editor-header {
			height: var(--wb-editor-header-height);
			background: var(--wb-editor-bg-dark);
			color: white;
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 0 16px;
		}

		#wb1001m01-editor .editor-header-title {
			font-size: 14px;
			font-weight: 600;
			letter-spacing: 0.2px;
		}

		#wb1001m01-editor .editor-header-actions {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			justify-content: flex-end;
		}

		#wb1001m01-editor .editor-header-btn {
			background: var(--wb-editor-primary);
			color: white;
			border: none;
			padding: 5px 12px;
			border-radius: 4px;
			font-size: 11px;
			cursor: pointer;
			transition: background 0.2s;
		}

		#wb1001m01-editor .editor-header-btn:hover {
			background: var(--wb-editor-primary-hover);
		}

		#wb1001m01-editor .editor-header-btn.secondary {
			background: #475569;
		}

		#wb1001m01-editor .editor-header-btn.secondary:hover {
			background: #64748b;
		}

		#wb1001m01-editor .editor-toolbar {
			width: var(--wb-editor-toolbar-width);
			background: white;
			border-right: 1px solid var(--wb-editor-border);
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 10px 8px;
			gap: 6px;
			overflow-y: auto;
			z-index: 10;
		}

		#wb1001m01-editor .editor-toolbar-btn {
			width: 40px;
			height: 40px;
			border: 1px solid transparent;
			background: transparent;
			border-radius: 6px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			transition: all 0.15s;
			color: var(--wb-editor-text-light);
		}

		#wb1001m01-editor .editor-toolbar-btn:hover {
			background: #f1f5f9;
			color: var(--wb-editor-text);
		}

		#wb1001m01-editor .editor-toolbar-btn.active {
			background: #eff6ff;
			border-color: var(--wb-editor-primary);
			color: var(--wb-editor-primary);
		}

		#wb1001m01-editor .editor-toolbar-divider {
			width: 30px;
			height: 1px;
			background: var(--wb-editor-border);
			margin: 8px 0;
		}

		#wb1001m01-editor .editor-properties {
			width: var(--wb-editor-properties-width);
			background: white;
			border-left: 1px solid var(--wb-editor-border);
			padding: 12px;
			overflow-y: auto;
			z-index: 10;
		}

		#wb1001m01-editor .editor-properties-section {
			margin-bottom: 16px;
		}

		#wb1001m01-editor .editor-properties-title {
			font-size: 10px;
			font-weight: 600;
			text-transform: uppercase;
			color: var(--wb-editor-text-light);
			margin-bottom: 8px;
			letter-spacing: 0.5px;
		}

		#wb1001m01-editor .editor-properties-row {
			display: flex;
			align-items: center;
			margin-bottom: 8px;
			gap: 8px;
		}

		#wb1001m01-editor .editor-properties-label {
			font-size: 11px;
			color: var(--wb-editor-text);
			flex: 1;
		}

		#wb1001m01-editor .editor-properties-input {
			width: 100%;
			padding: 4px 8px;
			border: 1px solid var(--wb-editor-border);
			border-radius: 4px;
			font-size: 11px;
		}

		#wb1001m01-editor .editor-properties-input[type="color"] {
			width: 32px;
			height: 28px;
			padding: 2px;
			cursor: pointer;
		}

		#wb1001m01-editor .editor-properties-value {
			width: 34px;
			text-align: right;
			font-size: 11px;
			color: var(--wb-editor-text-light);
		}

		#wb1001m01-editor .editor-color-palette {
			display: grid;
			grid-template-columns: repeat(6, 1fr);
			gap: 4px;
			margin-top: 6px;
		}

		#wb1001m01-editor .editor-color-swatch {
			width: 22px;
			height: 22px;
			border-radius: 4px;
			cursor: pointer;
			border: 2px solid transparent;
			transition: transform 0.15s;
		}

		#wb1001m01-editor .editor-color-swatch:hover {
			transform: scale(1.08);
		}

		#wb1001m01-editor .editor-canvas-container {
			flex: 1;
			background: #f8fafc;
			overflow: hidden;
			position: relative;
		}

		#wb1001m01-editor .editor-canvas-wrapper {
			position: absolute;
			top: 0;
			left: 0;
			transform-origin: 0 0;
		}

		#wb1001m01-editor canvas#mainCanvas {
			background: white;
			box-shadow: 0 2px 8px rgba(0,0,0,0.08);
			cursor: crosshair;
			display: block;
		}

		#wb1001m01-editor .editor-zoom-controls {
			position: absolute;
			bottom: 14px;
			left: 14px;
			display: flex;
			gap: 4px;
			background: white;
			padding: 4px;
			border-radius: 6px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			z-index: 5;
		}

		#wb1001m01-editor .editor-zoom-btn {
			width: 28px;
			height: 28px;
			border: 1px solid var(--wb-editor-border);
			background: white;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		#wb1001m01-editor .editor-zoom-btn:hover {
			background: #f1f5f9;
		}

		#wb1001m01-editor .editor-zoom-level {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 45px;
			font-size: 11px;
			color: var(--wb-editor-text);
		}

		#wb1001m01-editor .editor-shortcuts-info {
			position: absolute;
			bottom: 14px;
			right: 14px;
			background: rgba(30, 41, 59, 0.9);
			color: white;
			padding: 8px 12px;
			border-radius: 6px;
			font-size: 10px;
			z-index: 5;
		}

		#wb1001m01-editor .editor-shortcuts-info kbd {
			background: rgba(255,255,255,0.2);
			padding: 2px 4px;
			border-radius: 3px;
			margin-right: 4px;
		}

		#wb1001m01-editor .editor-toast {
			position: absolute;
			bottom: 64px;
			left: 50%;
			transform: translateX(-50%);
			background: var(--wb-editor-bg-dark);
			color: white;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 12px;
			z-index: 100;
			opacity: 0;
			transition: opacity 0.3s;
			pointer-events: none;
		}

		#wb1001m01-editor .editor-toast.show {
			opacity: 1;
		}

		#wb1001m01-editor #fileInput {
			display: none;
		}

		@media (max-width: 768px) {
			#wb1001m01-editor .editor-properties { display: none; }
			#wb1001m01-editor .editor-shortcuts-info { display: none; }
		}
	</style>
</head>
<body>
	<div id="head_area"></div>
	<div id="top_area"></div>
	<div id="main_area">
		<input type="hidden" id="pgmId" name="pgmId" value="WB1001M01">

		<div class="contents no_bg" style="padding-bottom: 8px;">
			<div style="display:flex; align-items:center; gap:14px;">
				<div style="font-size: 16px; font-weight: 700;">드로잉 에디터</div>
				<label style="display:inline-flex; align-items:center; gap:6px; font-weight:600; margin:0;">
					<input type="checkbox" id="wb1001_refresh" style="margin:0;"> Refresh(1분)
				</label>
				<span id="wb1001_last_sync" style="color:#64748b; font-size:12px;"></span>
			</div>
			<ul class="btn_ul">
				<li class="btn_r">
					<button type="button" class="bg_gray" onclick="app.openEquipmentPicker();">설비선택</button>
					<button type="button" class="bg_gray" onclick="manualPopup();">도움말</button>
				</li>
			</ul>
		</div>

		<div id="wb1001m01-editor">
			<div class="editor-wrapper">
				<header class="editor-header">
					<div class="editor-header-title">WB1001M01 Drawing Editor</div>
					<div class="editor-header-actions">
						<button class="editor-header-btn secondary" type="button" onclick="app.openEquipmentPicker()">설비</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.undo()">Undo</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.redo()">Redo</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.clearCanvas()">Clear</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.exportJSON()">Export</button>
						<button class="editor-header-btn secondary" type="button" onclick="document.getElementById('fileInput').click()">Import</button>
						<button class="editor-header-btn" type="button" onclick="app.saveToServer()">Save</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.loadFromServer()">Load</button>
					</div>
				</header>

				<div class="editor-body">
					<aside class="editor-toolbar">
						<button class="editor-toolbar-btn active" type="button" data-tool="select" title="Select (V)">↖</button>
						<button class="editor-toolbar-btn" type="button" data-tool="rectangle" title="Rectangle (R)">□</button>
						<button class="editor-toolbar-btn" type="button" data-tool="ellipse" title="Ellipse (E)">○</button>
					<button class="editor-toolbar-btn" type="button" data-tool="arrow" title="Arrow (A)">→</button>
						<button class="editor-toolbar-btn" type="button" data-tool="pen" title="Pen (P)">✎</button>
						<button class="editor-toolbar-btn" type="button" data-tool="text" title="Text (T)">T</button>
						<button class="editor-toolbar-btn" type="button" data-tool="equipmentNode" title="설비 노드">⚙</button>
						<div class="editor-toolbar-divider"></div>
						<button class="editor-toolbar-btn" type="button" onclick="app.openEquipmentPicker()" title="설비 선택">E</button>
						<button class="editor-toolbar-btn" type="button" onclick="app.undo()" title="Undo (Ctrl+Z)">↶</button>
						<button class="editor-toolbar-btn" type="button" onclick="app.redo()" title="Redo (Ctrl+Y)">↷</button>
					</aside>

					<div class="editor-canvas-container" id="canvasContainer">
						<div class="editor-canvas-wrapper" id="canvasWrapper">
							<canvas id="mainCanvas"></canvas>
						</div>
					</div>

					<aside class="editor-properties">
						<div class="editor-properties-section">
							<div class="editor-properties-title">Stroke</div>
							<div class="editor-properties-row">
								<span class="editor-properties-label">Color</span>
								<input type="color" id="strokeColor" class="editor-properties-input" value="#000000">
							</div>
							<div class="editor-color-palette" id="strokePalette">
								<div class="editor-color-swatch" data-color="#000000" style="background:#000000"></div>
								<div class="editor-color-swatch" data-color="#ef4444" style="background:#ef4444"></div>
								<div class="editor-color-swatch" data-color="#f59e0b" style="background:#f59e0b"></div>
								<div class="editor-color-swatch" data-color="#22c55e" style="background:#22c55e"></div>
								<div class="editor-color-swatch" data-color="#3b82f6" style="background:#3b82f6"></div>
								<div class="editor-color-swatch" data-color="#8b5cf6" style="background:#8b5cf6"></div>
							</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Fill</div>
							<div class="editor-properties-row">
								<span class="editor-properties-label">Color</span>
								<input type="color" id="fillColor" class="editor-properties-input" value="#ffffff">
							</div>
							<div class="editor-properties-row">
								<span class="editor-properties-label">Transparent</span>
								<input type="checkbox" id="fillTransparent" checked>
							</div>
							<div class="editor-color-palette" id="fillPalette">
								<div class="editor-color-swatch" data-color="#ffffff" style="background:#ffffff; border:1px solid #e2e8f0"></div>
								<div class="editor-color-swatch" data-color="#fef3c7" style="background:#fef3c7"></div>
								<div class="editor-color-swatch" data-color="#dcfce7" style="background:#dcfce7"></div>
								<div class="editor-color-swatch" data-color="#dbeafe" style="background:#dbeafe"></div>
								<div class="editor-color-swatch" data-color="#fce7f3" style="background:#fce7f3"></div>
								<div class="editor-color-swatch" data-color="#f1f5f9" style="background:#f1f5f9"></div>
							</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Width</div>
							<div class="editor-properties-row">
								<input type="range" id="strokeWidth" class="editor-properties-input" min="1" max="20" value="2">
								<span class="editor-properties-value" id="strokeWidthValue">2px</span>
							</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Selected</div>
							<div class="editor-properties-row">
								<button class="editor-header-btn" type="button" style="width:100%;" onclick="app.deleteSelected()">Delete Selected</button>
							</div>
							<div class="editor-properties-row" id="selectedInfo" style="font-size:10px; color: var(--wb-editor-text-light);">No selection</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Info</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>Elements: <span id="elementCount">0</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>설비: <span id="wb1001_meta_eqpNm">-</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>SalesCd: <span id="wb1001_meta_salesCd">-</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>일정상태: <span id="wb1001_meta_schedule">-</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>문제: <span id="wb1001_meta_issues">-</span></span>
							</div>
						</div>
					</aside>
				</div>
			</div>

			<div class="editor-zoom-controls">
				<button class="editor-zoom-btn" type="button" onclick="app.zoomOut()">-</button>
				<span class="editor-zoom-level" id="zoomLevel">100%</span>
				<button class="editor-zoom-btn" type="button" onclick="app.zoomIn()">+</button>
				<button class="editor-zoom-btn" type="button" onclick="app.resetView()" title="Reset View">R</button>
			</div>

			<div class="editor-shortcuts-info">
				<kbd>Ctrl+Z</kbd>Undo <kbd>Ctrl+Y</kbd>Redo <kbd>Delete</kbd>Delete <kbd>Ctrl+S</kbd>Save
			</div>

			<div class="editor-toast" id="toast"></div>

			<div id="wb1001_context_menu" style="display:none; position:fixed; z-index:9999; min-width:180px; background:#0f172a; color:#fff; border:1px solid rgba(148,163,184,0.35); border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.25); padding:6px; font-size:12px;">
				<div id="wb1001_context_menu_title" style="padding:6px 8px; color:#cbd5e1; font-size:11px; border-bottom:1px solid rgba(148,163,184,0.2); margin-bottom:6px;"></div>
				<div id="wb1001_context_menu_items"></div>
			</div>

			<input type="file" id="fileInput" accept=".json" onchange="app.importJSON(event)">
		</div>
	</div>

	<script src="/static/js/jquery-latest.min.js"></script>
	<script src="/static/js/jquery.serializeObject.js"></script>
	<script src="/static/bootstrap/js/bootstrap.min.js"></script>
	<script src="/static/bootstrap/js/bootstrap-datepicker.min.js"></script>
	<script src="/static/bootstrap/js/bootstrap-datepicker.ko.min.js"></script>
	<script src="/static/js/moment/moment-with-locales.js"></script>
	<script src="/static/js/jstree/jstree.min.js"></script>
	<script src="/static/js/ax5/ax5core.min.js"></script>
	<script src="/static/js/ax5/ax5grid.min.js"></script>
	<script src="/static/js/ax5/ax5mask.min.js"></script>
	<script src="/static/js/ax5/ax5modal.min.js"></script>
	<script src="/static/js/ax5/ax5toast.min.js"></script>
	<script src="/static/js/ax5/ax5calendar.min.js"></script>
	<script src="/static/js/ax5/ax5picker.min.js"></script>
	<script src="/static/js/ax5/ax5menu.min.js"></script>
	<script src="/static/js/ax5/ax5formatter.min.js"></script>
	<script src="/static/js/ax5/ax5combobox.min.js"></script>
	<script src="/static/js/ax5/ax5select.min.js"></script>
	<script src="/static/js/exceljs.min.js"></script>
	<script src="/static/js/global.js"></script>
	<script src="/static/js/fileTree.js"></script>
	<script src="/static/js/workingDayCalc.js"></script>
	<script src="/static/js/korean-lunar-calendar.min.js"></script>
	<script src="/static/js/jquery.blockUI.js"></script>
	<script src="/static/bootstrap/js/bootstrap-multiselect.min.js"></script>
	<script src="/static/js/manualPopup.js"></script>

	<script>
		$(document).ready(function() {
			mainDefaultLoad("실행계획", "드로잉 에디터");
			setCommonSelect($("#main_area select[data-kind]"));

			$('#head_area').toggleClass('off');
			$('#top_area').toggleClass('on');
			$('#main_area').toggleClass('on');

			app.init();
		});
	</script>

	<script>
		const app = {
			canvas: null,
			ctx: null,
			elements: [],
			history: [],
			historyIndex: -1,
			selectedElement: null,
			selectedElements: [],
			_lastHit: { x: 0, y: 0, ts: 0, idx: 0, stackIds: [] },
			currentTool: 'select',
			isDrawing: false,
			isPanning: false,
			isMarquee: false,
			marqueeStart: null,
			marqueeEnd: null,
			marqueeAdd: false,
			spaceDown: false,
			panStartClient: null,
			panStartPan: null,
			dragLast: null,
			startX: 0,
			startY: 0,
			panX: 0,
			panY: 0,
			zoom: 1,
			properties: {
				strokeColor: '#000000',
				fillColor: '#ffffff',
				fillTransparent: true,
				strokeWidth: 2
			},
			meta: {
				eqpNm: '',
				salesCd: '',
				scheduleStatus: '',
				issueCount: 0,
				lastSyncAt: ''
			},
			autoRefresh: false,
			autoRefreshTimer: null,
			resizeHandle: null,
			dragOffset: { x: 0, y: 0 },
			contextMenu: null,
			contextMenuTarget: null,
			contextMenuHit: { x: 0, y: 0 },
			lastPointer: { x: 0, y: 0 },
			imageCache: {},
			copyBuffer: null,
			internalPasteArmed: false,

			init() {
				this.canvas = document.getElementById('mainCanvas');
				this.ctx = this.canvas.getContext('2d');
				this.setupCanvas();
				this.setupEventListeners();
				this.setupContextMenu();
				this.loadFromLocalStorage();
				this.render();
				this.bindRefreshCheckbox();
				if (this.autoRefresh) {
					this.setAutoRefresh(true);
				}
				window.addEventListener('beforeunload', () => {
					this.setAutoRefresh(false);
				});
			},

			setupContextMenu() {
				this.contextMenu = document.getElementById('wb1001_context_menu');
				if (!this.contextMenu) return;
				document.addEventListener('mousedown', (e) => {
					// hide on any click outside the menu
					if (!this.contextMenu) return;
					if (this.contextMenu.style.display !== 'none' && !this.contextMenu.contains(e.target)) {
						this.hideContextMenu();
					}
				});
				window.addEventListener('scroll', () => this.hideContextMenu(), true);
			},

			getSelection() {
				return Array.isArray(this.selectedElements) ? this.selectedElements.filter(Boolean) : [];
			},

			isSelected(el) {
				return !!el && this.getSelection().some(x => x && x.id === el.id);
			},

			clearSelection() {
				this.selectedElements = [];
				this.selectedElement = null;
				this.updateSelectedInfo();
				this.render();
			},

			setSingleSelection(el) {
				this.selectedElements = el ? [el] : [];
				this.selectedElement = el || null;
				this.updateSelectedInfo();
				this.render();
			},

			toggleSelection(el) {
				if (!el) return;
				const sel = this.getSelection();
				const idx = sel.findIndex(x => x && x.id === el.id);
				if (idx >= 0) {
					sel.splice(idx, 1);
					this.selectedElements = sel;
					this.selectedElement = sel.length ? sel[sel.length - 1] : null;
				} else {
					sel.push(el);
					this.selectedElements = sel;
					this.selectedElement = el;
				}
				this.updateSelectedInfo();
				this.render();
			},

			updateSelectedInfo() {
				const info = document.getElementById('selectedInfo');
				if (!info) return;
				const sel = this.getSelection();
				if (!sel.length) {
					info.textContent = 'No selection';
					return;
				}
				if (sel.length === 1) {
					const el = sel[0];
					info.innerHTML = `<strong>${el.type}</strong><br>X: ${Math.round(el.x)}, Y: ${Math.round(el.y)}`;
					return;
				}
				const primary = sel[sel.length - 1];
				info.innerHTML = `<strong>Multi</strong> (${sel.length})<br>Primary: ${primary ? primary.type : '-'}`;
			},

			hideContextMenu() {
				if (!this.contextMenu) return;
				this.contextMenu.style.display = 'none';
				this.contextMenuTarget = null;
			},

			showContextMenu(screenX, screenY, target, hitInfo) {
				if (!this.contextMenu) return;
				this.contextMenuTarget = target || null;
				this.contextMenuHit = hitInfo || { x: 0, y: 0 };
				const titleEl = document.getElementById('wb1001_context_menu_title');
				const itemsEl = document.getElementById('wb1001_context_menu_items');
				if (!itemsEl) return;
				if (titleEl) {
					const t = target ? `${target.type}${target.type === 'equipmentNode' ? ` (${target.salesCd || '-'})` : ''}` : 'Canvas';
					titleEl.textContent = t;
				}
				itemsEl.innerHTML = '';

				const addItem = (label, onClick, danger) => {
					const btn = document.createElement('button');
					btn.type = 'button';
					btn.textContent = label;
					btn.style.width = '100%';
					btn.style.textAlign = 'left';
					btn.style.background = 'transparent';
					btn.style.border = 'none';
					btn.style.color = danger ? '#fecaca' : '#e2e8f0';
					btn.style.padding = '7px 10px';
					btn.style.borderRadius = '6px';
					btn.style.cursor = 'pointer';
					btn.addEventListener('mouseenter', () => { btn.style.background = 'rgba(148,163,184,0.16)'; });
					btn.addEventListener('mouseleave', () => { btn.style.background = 'transparent'; });
					btn.addEventListener('click', () => {
						this.hideContextMenu();
						try { onClick && onClick(); } catch (e) {}
					});
					itemsEl.appendChild(btn);
				};

				const addSep = (label) => {
					const div = document.createElement('div');
					div.style.padding = '6px 8px';
					div.style.marginTop = '6px';
					div.style.color = '#94a3b8';
					div.style.fontSize = '10px';
					div.style.borderTop = '1px solid rgba(148,163,184,0.18)';
					div.textContent = label;
					itemsEl.appendChild(div);
				};

				const sel = this.getSelection();
				const multi = sel.length > 1;

				if (target) {
					addItem(multi ? '선택 삭제' : '삭제', () => {
						this.deleteSelected();
					}, true);
					addItem(multi ? '선택 복제' : '복제', () => {
						this.duplicateSelected();
					});
					addItem('앞으로 가져오기', () => {
						this.bringToFront(target);
					});
					addItem('뒤로 보내기', () => {
						this.sendToBack(target);
					});
					addItem('겹침 선택(다음)', () => {
						this.selectNextUnderCursor(this.contextMenuHit.x, this.contextMenuHit.y);
					});

					if (target.type === 'equipmentNode') {
						addItem('설비 변경', () => {
							this.openEquipmentPickerWithOptions({
								searchValue: target.salesCd || this.meta.salesCd || '',
								onSelected: (picked) => {
									const salesCd = String(picked && picked.salesCd || '').trim();
									if (!salesCd) return;
									target.salesCd = salesCd;
									target.eqpNm = String(picked.eqpNm || '').trim();
									this.saveState();
									this.refreshSalesStatus();
								}
							});
						});
						addItem('이 노드 재조회', () => {
							this.refreshSalesStatus();
						});
					}
				} else {
					addItem('겹침 선택(다음)', () => {
						this.selectNextUnderCursor(this.contextMenuHit.x, this.contextMenuHit.y);
					});
				}

				if (multi) {
					addSep('정렬/맞춤 (기준: 마지막 선택)');
					addItem('같은 너비', () => this.matchSelectionSize('width'));
					addItem('같은 높이', () => this.matchSelectionSize('height'));
					addItem('위쪽 맞춤', () => this.alignSelection('top'));
					addItem('가운데 맞춤(세로)', () => this.alignSelection('vcenter'));
					addItem('아래쪽 맞춤', () => this.alignSelection('bottom'));
					addItem('왼쪽 맞춤', () => this.alignSelection('left'));
					addItem('가운데 맞춤(가로)', () => this.alignSelection('hcenter'));
					addItem('오른쪽 맞춤', () => this.alignSelection('right'));
				}

				this.contextMenu.style.left = Math.round(screenX) + 'px';
				this.contextMenu.style.top = Math.round(screenY) + 'px';
				this.contextMenu.style.display = 'block';
			},

			duplicateSelected() {
				const sel = this.getSelection();
				if (!sel.length) return;
				const copies = [];
				for (const src of sel) {
					const copy = JSON.parse(JSON.stringify(src));
					copy.id = Date.now() + Math.random();
					if (copy.type === 'pen' && Array.isArray(copy.points)) {
						for (const p of copy.points) { p.x += 20; p.y += 20; }
					} else {
						copy.x += 20; copy.y += 20;
						if (typeof copy.x2 === 'number') copy.x2 += 20;
						if (typeof copy.y2 === 'number') copy.y2 += 20;
					}
					this.elements.push(copy);
					copies.push(copy);
				}
				this.selectedElements = copies;
				this.selectedElement = copies[copies.length - 1] || null;
				this.updateSelectedInfo();
				this.saveState();
				this.render();
				this.updateElementCount();
			},

			bringToFront(el) {
				const idx = this.elements.indexOf(el);
				if (idx < 0) return;
				this.elements.splice(idx, 1);
				this.elements.push(el);
				this.selectElement(el);
				this.saveState();
				this.render();
			},

			sendToBack(el) {
				const idx = this.elements.indexOf(el);
				if (idx < 0) return;
				this.elements.splice(idx, 1);
				this.elements.unshift(el);
				this.selectElement(el);
				this.saveState();
				this.render();
			},

			hitTestAll(x, y) {
				const hits = [];
				for (let i = this.elements.length - 1; i >= 0; i--) {
					const el = this.elements[i];
					if (!el) continue;
					if (el.type === 'pen') {
						if (el.points) {
							for (const point of el.points) {
								const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
								if (dist < 10) { hits.push(el); break; }
							}
						}
					} else if (el.type === 'text') {
						this.ctx.font = `${el.strokeWidth * 8}px sans-serif`;
						const metrics = this.ctx.measureText(el.text || '');
						const width = metrics.width;
						const height = el.strokeWidth * 8;
						if (x >= el.x && x <= el.x + width && y >= el.y - height && y <= el.y) hits.push(el);
					} else if (el.type === 'image') {
						const minX = Math.min(el.x, el.x2);
						const maxX = Math.max(el.x, el.x2);
						const minY = Math.min(el.y, el.y2);
						const maxY = Math.max(el.y, el.y2);
						if (x >= minX && x <= maxX && y >= minY && y <= maxY) hits.push(el);
					} else {
						const minX = Math.min(el.x, el.x2);
						const maxX = Math.max(el.x, el.x2);
						const minY = Math.min(el.y, el.y2);
						const maxY = Math.max(el.y, el.y2);
						if (x >= minX && x <= maxX && y >= minY && y <= maxY) hits.push(el);
					}
				}
				return hits;
			},

			selectNextUnderCursor(x, y) {
				const now = Date.now();
				const hits = this.hitTestAll(x, y);
				if (!hits.length) return;
				const tol = 6;
				const within = Math.abs(x - this._lastHit.x) <= tol && Math.abs(y - this._lastHit.y) <= tol && (now - this._lastHit.ts) <= 1000;
				let idx = 0;
				if (within) {
					idx = (this._lastHit.idx + 1) % hits.length;
				}
				this._lastHit = { x, y, ts: now, idx, stackIds: hits.map(h => h.id) };
				this.selectElement(hits[idx]);
			},

			bindRefreshCheckbox() {
				const el = document.getElementById('wb1001_refresh');
				if (!el) return;
				el.checked = !!this.autoRefresh;
				el.addEventListener('change', () => {
					this.setAutoRefresh(el.checked);
				});
			},

			setAutoRefresh(enabled) {
				this.autoRefresh = !!enabled;
				if (this.autoRefreshTimer) {
					clearInterval(this.autoRefreshTimer);
					this.autoRefreshTimer = null;
				}
				if (this.autoRefresh) {
					this.refreshSalesStatus();
					this.autoRefreshTimer = setInterval(() => this.refreshSalesStatus(), 60000);
					this.showToast('Refresh ON (1분)');
				} else {
					this.showToast('Refresh OFF');
				}
				this.saveToLocalStorage();
			},

			getCoCd() {
				const jwtObj = (typeof window !== 'undefined') ? window.jwt : null;
				if (jwtObj && jwtObj.coCd) return jwtObj.coCd;
				return 'GUN';
			},

			parseDateLike(v) {
				const s = String(v || '').trim();
				if (!s) return null;
				if (/^\d{8}$/.test(s)) {
					const norm = `${s.substr(0, 4)}-${s.substr(4, 2)}-${s.substr(6, 2)}`;
					const d = new Date(norm);
					return isNaN(d.getTime()) ? null : d;
				}
				if (/^\d{4}[-\.]\d{2}[-\.]\d{2}$/.test(s)) {
					const d = new Date(s.replace(/\./g, '-'));
					return isNaN(d.getTime()) ? null : d;
				}
				const d = new Date(s);
				return isNaN(d.getTime()) ? null : d;
			},

			postAjaxPromise(url, data) {
				return new Promise((resolve, reject) => {
					try {
						if (typeof postAjax === 'function') {
							postAjax(url, data, null, function(res){
								resolve(res);
							});
							return;
						}
					} catch (e) {
						reject(e);
						return;
					}
					fetch(url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(data || {})
					}).then(r => r.json()).then(resolve).catch(reject);
				});
			},

				openEquipmentPicker() {
					return this.openEquipmentPickerWithOptions(null);
				},

				openEquipmentPickerWithOptions(options) {
					const coCd = this.getCoCd();
					const opt = options || {};
					const paramObj = { coCd: coCd, searchValue: (opt.searchValue || '') };
					if (typeof openSecondModal !== 'function') {
						this.showToast('설비 선택 모달을 열 수 없습니다.');
						return;
					}
					openSecondModal('/static/html/cmn/modal/wbsSalesCodeSearch.html', 1200, 700, 'SALES CODE 검색', paramObj, (grid) => {
						const row = grid && grid.target && typeof grid.target.getList === 'function'
							? (grid.target.getList('selected')[0] || null)
							: null;
						if (!row) return;
						const picked = {
							salesCd: row.salesCd || '',
							eqpNm: row.eqpNm || row.eqp || ''
						};
						if (typeof opt.onSelected === 'function') {
							opt.onSelected(picked, row);
							return;
						}
						this.setSalesContext(picked);
					});
				},

				setSalesContext({ salesCd, eqpNm, ensureSummaryNode }) {
					this.meta.salesCd = String(salesCd || '').trim();
					this.meta.eqpNm = String(eqpNm || '').trim();
					this.updateMetaView();
					this.saveToLocalStorage();
					if (ensureSummaryNode !== false) {
						this.ensureEquipmentSummaryNode(this.meta.salesCd, this.meta.eqpNm);
					}
					this.refreshSalesStatus();
				},

			ensureEquipmentSummaryNode(salesCd, eqpNm) {
				const s = String(salesCd || '').trim();
				if (!s) return;
				const existing = this.elements.find(el => el && el.type === 'equipmentNode' && el.summary === true && String(el.salesCd || '').trim() === s);
				if (existing) {
					existing.eqpNm = String(eqpNm || existing.eqpNm || '').trim();
					this.render();
					return;
				}
				const center = this.getViewportCenterCanvas();
				const x = Math.max(10, Math.round(center.x - 140));
				const y = Math.max(10, Math.round(center.y - 55));
				this.createEquipmentNodeAt(x, y, {
					salesCd: s,
					eqpNm: String(eqpNm || '').trim(),
					scheduleStatus: this.meta.scheduleStatus,
					issueCount: this.meta.issueCount,
					lastSyncAt: this.meta.lastSyncAt,
					summary: true
				});
				this.saveState();
			},

			getViewportCenterCanvas() {
				const container = document.getElementById('canvasContainer');
				if (!container) return { x: 100, y: 100 };
				// screen = canvas * zoom + pan (pan is translate after scale in current transform order)
				const x = (container.clientWidth / 2 - this.panX) / this.zoom;
				const y = (container.clientHeight / 2 - this.panY) / this.zoom;
				return { x, y };
			},

				createEquipmentNodeAt(x, y, data) {
					const w = 280;
					const h = 110;
					const node = this.createElement('equipmentNode', x, y, x + w, y + h, {
						salesCd: String((data && data.salesCd) || '').trim(),
						eqpNm: String((data && data.eqpNm) || '').trim(),
						scheduleStatus: String((data && data.scheduleStatus) || '').trim(),
						issueCount: (data && typeof data.issueCount === 'number') ? data.issueCount : parseInt(data && data.issueCount, 10) || 0,
						lastSyncAt: String((data && data.lastSyncAt) || '').trim(),
						summary: !!(data && data.summary),
						fillColor: '#ffffff',
						strokeColor: '#2563eb',
						strokeWidth: 2
					});
					this.selectElement(node);
					this.render();
					this.updateElementCount();
					return node;
				},

			updateMetaView() {
				const setText = (id, v) => {
					const el = document.getElementById(id);
					if (el) el.textContent = v;
				};
				setText('wb1001_meta_eqpNm', this.meta.eqpNm || '-');
				setText('wb1001_meta_salesCd', this.meta.salesCd || '-');
				setText('wb1001_meta_schedule', this.meta.scheduleStatus || '-');
				setText('wb1001_meta_issues', (typeof this.meta.issueCount === 'number') ? String(this.meta.issueCount) : '-');
				const last = document.getElementById('wb1001_last_sync');
				if (last) {
					last.textContent = this.meta.lastSyncAt ? `Last: ${this.meta.lastSyncAt}` : '';
				}
			},

			collectSalesCdsForRefresh() {
				const set = new Set();
				for (const el of this.elements) {
					if (!el || el.type !== 'equipmentNode') continue;
					const cd = String(el.salesCd || '').trim();
					if (cd) set.add(cd);
				}
				const metaCd = String(this.meta.salesCd || '').trim();
				if (metaCd) set.add(metaCd);
				return Array.from(set);
			},

			async refreshSalesStatus() {
				const salesCds = this.collectSalesCdsForRefresh();
				if (!salesCds.length) return;
				try {
					const [schRes, issRes] = await Promise.all([
						this.postAjaxPromise('/user/wb/wb26/select_wb06_List', { salesCds: salesCds }),
						this.postAjaxPromise('/user/wb/wb24/selectWbsIssueCountBySalesCds', { coCd: this.getCoCd(), salesCds: salesCds })
					]);

					const scheduleRows = (schRes && Array.isArray(schRes.result)) ? schRes.result : [];
					const issueList = (issRes && Array.isArray(issRes.result)) ? issRes.result : [];

					const scheduleMap = {};
					for (const r of scheduleRows) {
						const cd = String((r && r.salesCd) || '').trim();
						if (!cd) continue;
						if (!scheduleMap[cd]) scheduleMap[cd] = [];
						scheduleMap[cd].push(r);
					}
					const scheduleStatusByCd = {};
					for (const cd of Object.keys(scheduleMap)) {
						scheduleStatusByCd[cd] = this.computeScheduleStatus(scheduleMap[cd]);
					}

					const issueCountByCd = {};
					for (const it of issueList) {
						const cd = String((it && it.salesCd) || '').trim();
						if (!cd) continue;
						const cnt = parseInt((it && (it.cnt ?? it.count ?? it.issueCount)) || 0, 10);
						issueCountByCd[cd] = isNaN(cnt) ? 0 : cnt;
					}

					const nowStr = new Date().toLocaleString('ko-KR');
					let changed = false;
					for (const el of this.elements) {
						if (!el || el.type !== 'equipmentNode') continue;
						const cd = String(el.salesCd || '').trim();
						if (!cd) continue;
						el.scheduleStatus = scheduleStatusByCd[cd] || '없음';
						el.issueCount = (typeof issueCountByCd[cd] === 'number') ? issueCountByCd[cd] : 0;
						el.lastSyncAt = nowStr;
						changed = true;
					}

					const metaCd = String(this.meta.salesCd || '').trim();
					if (metaCd) {
						this.meta.scheduleStatus = scheduleStatusByCd[metaCd] || '없음';
						this.meta.issueCount = (typeof issueCountByCd[metaCd] === 'number') ? issueCountByCd[metaCd] : 0;
						this.meta.lastSyncAt = nowStr;
						this.updateMetaView();
					}
					if (changed) this.render();
					this.saveToLocalStorage();
				} catch (e) {
					this.showToast('상태 조회 실패');
				}
			},

			computeScheduleStatus(rows) {
				if (!rows || !rows.length) return '없음';
				const today = new Date();
				today.setHours(0, 0, 0, 0);
				let anyClosed = false;
				let allClosed = true;
				let anyDelayed = false;
				for (const r of rows) {
					const wbsCloseYn = String(r.wbsCloseYn || '').toUpperCase();
					const closeYn = String(r.closeYn || '').toUpperCase();
					const isClosed = (wbsCloseYn === 'Y' || closeYn === 'Y');
					if (isClosed) anyClosed = true;
					if (!isClosed) allClosed = false;
					const endStr = String(r.wbsPlaneDtFm || r.wbsPlaneDt || '').trim();
					const d = this.parseDateLike(endStr);
					if (d) {
						d.setHours(0, 0, 0, 0);
						if (d < today && !isClosed) anyDelayed = true;
					}
				}
				if (allClosed) return '완료';
				if (anyDelayed) return '지연';
				if (anyClosed) return '확정';
				return '진행';
			},

			setupCanvas() {
				const container = document.getElementById('canvasContainer');
				this.canvas.width = 2000;
				this.canvas.height = 1500;
				const containerRect = container.getBoundingClientRect();
				this.panX = (containerRect.width - this.canvas.width) / 2;
				this.panY = (containerRect.height - this.canvas.height) / 2;
				this.updateTransform();
			},

			updateTransform() {
				const wrapper = document.getElementById('canvasWrapper');
				wrapper.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
				document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
			},

			setupEventListeners() {
				document.querySelectorAll('.editor-toolbar-btn[data-tool]').forEach(btn => {
					btn.addEventListener('click', () => {
						this.setTool(btn.dataset.tool);
					});
				});

				document.getElementById('strokeColor').addEventListener('input', (e) => {
					this.properties.strokeColor = e.target.value;
					this.updateSelectedProperties();
				});
				document.getElementById('fillColor').addEventListener('input', (e) => {
					this.properties.fillColor = e.target.value;
					this.updateSelectedProperties();
				});
				document.getElementById('fillTransparent').addEventListener('change', (e) => {
					this.properties.fillTransparent = e.target.checked;
					this.updateSelectedProperties();
				});
				document.getElementById('strokeWidth').addEventListener('input', (e) => {
					this.properties.strokeWidth = parseInt(e.target.value, 10);
					document.getElementById('strokeWidthValue').textContent = e.target.value + 'px';
					this.updateSelectedProperties();
				});

				document.querySelectorAll('#strokePalette .editor-color-swatch').forEach(swatch => {
					swatch.addEventListener('click', () => {
						this.properties.strokeColor = swatch.dataset.color;
						document.getElementById('strokeColor').value = swatch.dataset.color;
						this.updateSelectedProperties();
					});
				});
				document.querySelectorAll('#fillPalette .editor-color-swatch').forEach(swatch => {
					swatch.addEventListener('click', () => {
						this.properties.fillColor = swatch.dataset.color;
						document.getElementById('fillColor').value = swatch.dataset.color;
						this.updateSelectedProperties();
					});
				});

				this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
				this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
				this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
				this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
				this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
				this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));
				this.canvas.addEventListener('contextmenu', (e) => {
					e.preventDefault();
					const pos = this.getMousePos(e);
					const hits = this.hitTestAll(pos.x, pos.y);
					const target = hits.length ? hits[0] : null;
					if (target) {
						if (!this.isSelected(target) || this.getSelection().length <= 1) {
							this.setSingleSelection(target);
						} else {
							// make right-clicked element the primary (last selected)
							const sel = this.getSelection().filter(x => x && x.id !== target.id);
							sel.push(target);
							this.selectedElements = sel;
							this.selectedElement = target;
							this.updateSelectedInfo();
							this.render();
						}
					}
					this.showContextMenu(e.clientX, e.clientY, target, { x: pos.x, y: pos.y });
				});

				this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
				this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
				this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));

				document.addEventListener('keydown', this.handleKeyDown.bind(this));
				document.addEventListener('keyup', this.handleKeyUp.bind(this));
				document.addEventListener('paste', this.handlePaste.bind(this));
				window.addEventListener('resize', this.handleResize.bind(this));
				this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
			},

			handlePaste(e) {
				// Support paste image from clipboard
				const ae = document.activeElement;
				if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA')) return;
				const cd = e.clipboardData;
				if (!cd || !cd.items) return;
				let handled = false;
				// 1) Prefer file images
				for (const item of cd.items) {
					if (!item || item.kind !== 'file') continue;
					if (!item.type || item.type.indexOf('image/') !== 0) continue;
					const file = item.getAsFile();
					if (!file) continue;
					e.preventDefault();
					const reader = new FileReader();
					reader.onload = () => {
						const dataUrl = String(reader.result || '');
						if (dataUrl) this.addImageFromDataUrl(dataUrl);
					};
					reader.readAsDataURL(file);
					handled = true;
					this.internalPasteArmed = false;
					return;
				}

				// 1.5) Try our own element clipboard format
				try {
					const text = String(cd.getData('text/plain') || '').trim();
					if (text.indexOf('WB1001_CLIP:') === 0) {
						e.preventDefault();
						const json = text.substring('WB1001_CLIP:'.length);
						const payload = JSON.parse(json);
						this.pasteElementsFromPayload(payload);
						handled = true;
						this.internalPasteArmed = false;
						return;
					}
				} catch (err) {}

				// 2) Try HTML clipboard (often used by browsers / web apps)
				try {
					const html = cd.getData('text/html');
					const src = this.extractFirstImgSrcFromHtml(html);
					if (src) {
						e.preventDefault();
						if (src.indexOf('data:image/') === 0) {
							this.addImageFromDataUrl(src);
							handled = true;
							this.internalPasteArmed = false;
							return;
						}
						// remote url -> fetch -> dataURL
						if (src.indexOf('http://') === 0 || src.indexOf('https://') === 0) {
							fetch(src)
								.then(r => r.blob())
								.then(b => this.blobToDataUrl(b))
								.then((dataUrl) => { if (dataUrl) this.addImageFromDataUrl(dataUrl); })
								.catch(() => this.showToast('이미지 붙여넣기 실패(외부 URL)'));
							handled = true;
							this.internalPasteArmed = false;
							return;
						}
					}
				} catch (err) {}

				// 3) Try plain text data URL
				try {
					const text = String(cd.getData('text/plain') || '').trim();
					if (text.indexOf('data:image/') === 0) {
						e.preventDefault();
						this.addImageFromDataUrl(text);
						handled = true;
						this.internalPasteArmed = false;
						return;
					}
				} catch (err) {}

				// 4) Internal fallback (when clipboard write is blocked)
				if (!handled && this.internalPasteArmed && this.copyBuffer) {
					e.preventDefault();
					this.pasteElementsFromPayload(this.copyBuffer);
					this.internalPasteArmed = false;
				}
			},

			copySelectionToClipboard() {
				const sel = this.getSelection();
				if (!sel.length) return;
				const payload = {
					type: 'WB1001_CLIP',
					version: 1,
					elements: JSON.parse(JSON.stringify(sel))
				};
				this.copyBuffer = payload;
				const text = 'WB1001_CLIP:' + JSON.stringify(payload);
				if (navigator.clipboard && navigator.clipboard.writeText) {
					navigator.clipboard.writeText(text)
						.then(() => this.showToast('복사됨'))
						.catch(() => this.showToast('복사됨(내부)'));
				} else {
					this.showToast('복사됨(내부)');
				}
			},

			pasteElementsFromPayload(payload) {
				if (!payload || payload.type !== 'WB1001_CLIP' || !Array.isArray(payload.elements) || !payload.elements.length) return;
				const src = payload.elements;
				// compute bounds
				let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
				for (const el of src) {
					const b = this.getElementBounds(el);
					minX = Math.min(minX, b.minX); minY = Math.min(minY, b.minY);
					maxX = Math.max(maxX, b.maxX); maxY = Math.max(maxY, b.maxY);
				}
				if (!isFinite(minX)) return;
				const center = this.getViewportCenterCanvas();
				const cx = (minX + maxX) / 2;
				const cy = (minY + maxY) / 2;
				const dx = Math.round(center.x - cx + 20);
				const dy = Math.round(center.y - cy + 20);
				const copies = [];
				for (const el of src) {
					const copy = JSON.parse(JSON.stringify(el));
					copy.id = Date.now() + Math.random();
					this.moveElementBy(copy, dx, dy);
					this.elements.push(copy);
					// ensure image cache preloads
					if (copy.type === 'image' && copy.src) {
						const img = new Image();
						img.onload = () => this.render();
						img.src = copy.src;
						this.imageCache[copy.id] = img;
					}
					copies.push(copy);
				}
				this.selectedElements = copies;
				this.selectedElement = copies[copies.length - 1] || null;
				this.updateSelectedInfo();
				this.saveState();
				this.render();
				this.updateElementCount();
				this.showToast('붙여넣기');
			},

			extractFirstImgSrcFromHtml(html) {
				const s = String(html || '');
				if (!s) return '';
				const m = s.match(/<img[^>]+src=["']([^"']+)["']/i);
				return m ? String(m[1] || '') : '';
			},

			blobToDataUrl(blob) {
				return new Promise((resolve) => {
					try {
						const reader = new FileReader();
						reader.onload = () => resolve(String(reader.result || ''));
						reader.onerror = () => resolve('');
						reader.readAsDataURL(blob);
					} catch (e) {
						resolve('');
					}
				});
			},

			addImageFromDataUrl(dataUrl) {
				const img = new Image();
				img.onload = () => {
					const center = this.getViewportCenterCanvas();
					let w = img.naturalWidth || 400;
					let h = img.naturalHeight || 300;
					const maxW = 600;
					if (w > maxW) {
						const s = maxW / w;
						w = Math.round(w * s);
						h = Math.round(h * s);
					}
					const x = Math.round(center.x - w / 2);
					const y = Math.round(center.y - h / 2);
					const el = this.createElement('image', x, y, x + w, y + h, { src: dataUrl });
					this.imageCache[el.id] = img;
					this.saveState();
					this.render();
					this.showToast('이미지 붙여넣기');
				};
				img.src = dataUrl;
			},

			getMousePos(e) {
				// canvas is CSS-transformed via wrapper translate(panX, panY) scale(zoom)
				// so use the container's screen space, then invert the transform.
				const container = document.getElementById('canvasContainer');
				const rect = container ? container.getBoundingClientRect() : this.canvas.getBoundingClientRect();
				const sx = e.clientX - rect.left;
				const sy = e.clientY - rect.top;
				return {
					x: (sx - this.panX) / this.zoom,
					y: (sy - this.panY) / this.zoom
				};
			},

			handleMouseDown(e) {
				this.hideContextMenu();
				const pos = this.getMousePos(e);
				this.lastPointer = { x: pos.x, y: pos.y };
				this.startX = pos.x;
				this.startY = pos.y;
				this.isDrawing = true;
				this.dragLast = { x: pos.x, y: pos.y };

				// Space + left-drag = pan
				if (this.spaceDown && e.button === 0) {
					this.isPanning = true;
					this.isDrawing = false;
					this.isMarquee = false;
					this.panStartClient = { x: e.clientX, y: e.clientY };
					this.panStartPan = { x: this.panX, y: this.panY };
					this.canvas.style.cursor = 'grabbing';
					return;
				}

				if (this.currentTool === 'select') {
					if (this.selectedElement) {
						const handle = this.getResizeHandle(pos.x, pos.y);
						if (handle) {
							this.resizeHandle = handle;
							return;
						}
					}

					const hits = this.hitTestAll(pos.x, pos.y);
					if (hits && hits.length) {
						const top = hits[0];
						if (e.shiftKey) {
							this.toggleSelection(top);
							this.dragLast = { x: pos.x, y: pos.y };
							this.isMarquee = false;
							return;
						}

						// cycle when repeatedly clicking same spot (only when shift not pressed)
						const now = Date.now();
						const tol = 6;
						const within = Math.abs(pos.x - this._lastHit.x) <= tol && Math.abs(pos.y - this._lastHit.y) <= tol && (now - this._lastHit.ts) <= 1000;
						let pickIdx = 0;
						if (within) pickIdx = (this._lastHit.idx + 1) % hits.length;
						this._lastHit = { x: pos.x, y: pos.y, ts: now, idx: pickIdx, stackIds: hits.map(h => h.id) };
						const element = hits[pickIdx];

						// keep existing multi-selection when clicking inside it
						if (this.getSelection().length > 1 && this.isSelected(element)) {
							const sel = this.getSelection().filter(x => x && x.id !== element.id);
							sel.push(element);
							this.selectedElements = sel;
							this.selectedElement = element;
							this.updateSelectedInfo();
							this.render();
						} else {
							this.setSingleSelection(element);
						}
						this.dragLast = { x: pos.x, y: pos.y };
						this.isMarquee = false;
					} else {
						// marquee selection (drag on empty space)
						this.marqueeAdd = !!e.shiftKey;
						if (!e.shiftKey) this.clearSelection();
						this.isMarquee = true;
						this.marqueeStart = { x: pos.x, y: pos.y };
						this.marqueeEnd = { x: pos.x, y: pos.y };
						this.isDrawing = true;
					}
				} else if (this.currentTool === 'text') {
					const text = prompt('Enter text:', 'Text');
					if (text) {
						this.createElement('text', pos.x, pos.y, pos.x, pos.y, { text });
						this.saveState();
					}
					this.isDrawing = false;
				} else if (this.currentTool === 'equipmentNode') {
					const placeX = pos.x;
					const placeY = pos.y;
					this.isDrawing = false;
					this.openEquipmentPickerWithOptions({
						searchValue: this.meta.salesCd || '',
						onSelected: (picked) => {
							const salesCd = String(picked && picked.salesCd || '').trim();
							if (!salesCd) return;
							this.createEquipmentNodeAt(placeX, placeY, {
								salesCd: salesCd,
								eqpNm: picked.eqpNm,
								scheduleStatus: this.meta.scheduleStatus,
								issueCount: this.meta.issueCount,
								lastSyncAt: this.meta.lastSyncAt,
								summary: false
							});
							this.saveState();
							this.setSalesContext({ salesCd: salesCd, eqpNm: picked.eqpNm, ensureSummaryNode: false });
							this.setTool('select');
							this.showToast('설비 노드 생성');
						}
					});
				} else if (this.currentTool === 'pen') {
					this.createElement('pen', pos.x, pos.y, pos.x, pos.y);
				} else if (['rectangle', 'ellipse', 'arrow'].includes(this.currentTool)) {
					this.createElement(this.currentTool, pos.x, pos.y, pos.x, pos.y);
				}
			},

			handleMouseMove(e) {
				const pos = this.getMousePos(e);
				this.lastPointer = { x: pos.x, y: pos.y };

				if (this.isPanning && this.panStartClient && this.panStartPan) {
					const dx = e.clientX - this.panStartClient.x;
					const dy = e.clientY - this.panStartClient.y;
					this.panX = this.panStartPan.x + dx;
					this.panY = this.panStartPan.y + dy;
					this.updateTransform();
					return;
				}

				if (!this.isDrawing && this.currentTool === 'select' && this.selectedElement) {
					const handle = this.getResizeHandle(pos.x, pos.y);
					if (handle) {
						this.canvas.style.cursor = (handle === 'nw' || handle === 'se') ? 'nwse-resize' : 'nesw-resize';
					} else {
						this.canvas.style.cursor = 'default';
					}
				}

				if (this.resizeHandle && this.selectedElement) {
					this.handleResize(pos.x, pos.y);
					this.render();
					return;
				}

				if (this.isMarquee && this.marqueeStart) {
					this.marqueeEnd = { x: pos.x, y: pos.y };
					this.render();
					return;
				}

				if (!this.isDrawing) return;

				if (this.currentTool === 'select' && this.getSelection().length) {
					if (this.dragLast) {
						const dx = pos.x - this.dragLast.x;
						const dy = pos.y - this.dragLast.y;
						this.moveSelectionBy(dx, dy);
						this.dragLast = { x: pos.x, y: pos.y };
						this.render();
					}
				} else if (this.currentTool === 'pen') {
					const current = this.elements[this.elements.length - 1];
					if (current && current.type === 'pen') {
						current.points.push({ x: pos.x, y: pos.y });
						this.render();
					}
				} else if (['rectangle', 'ellipse', 'arrow'].includes(this.currentTool)) {
					const current = this.elements[this.elements.length - 1];
					if (current) {
						current.x2 = pos.x;
						current.y2 = pos.y;
						this.render();
					}
				}
			},

			handleMouseUp(e) {
				if (this.resizeHandle) {
					this.normalizeElementBounds(this.selectedElement);
					this.saveState();
					this.resizeHandle = null;
					// prevent accidental move after resize
					this.isDrawing = false;
					this.dragLast = null;
					return;
				}
				if (this.isPanning) {
					this.isPanning = false;
					this.panStartClient = null;
					this.panStartPan = null;
					this.canvas.style.cursor = this.spaceDown ? 'grab' : (this.currentTool === 'select' ? 'default' : 'crosshair');
					return;
				}

				if (this.isMarquee && this.marqueeStart && this.marqueeEnd) {
					const r = {
						minX: Math.min(this.marqueeStart.x, this.marqueeEnd.x),
						minY: Math.min(this.marqueeStart.y, this.marqueeEnd.y),
						maxX: Math.max(this.marqueeStart.x, this.marqueeEnd.x),
						maxY: Math.max(this.marqueeStart.y, this.marqueeEnd.y)
					};
					const picked = this.getElementsInRect(r, true);
					if (picked.length) {
						if (this.marqueeAdd) {
							const existing = this.getSelection();
							const merged = existing.slice();
							for (const el of picked) {
								if (!merged.some(x => x && x.id === el.id)) merged.push(el);
							}
							this.selectedElements = merged;
							this.selectedElement = picked[picked.length - 1] || merged[merged.length - 1] || null;
						} else {
							this.selectedElements = picked;
							this.selectedElement = picked[picked.length - 1] || null;
						}
					} else {
						// no hits keeps current selection
					}
					this.isMarquee = false;
					this.marqueeStart = null;
					this.marqueeEnd = null;
					this.marqueeAdd = false;
					this.isDrawing = false;
					this.dragLast = null;
					this.updateSelectedInfo();
					this.render();
					return;
				} else if (['rectangle', 'ellipse', 'arrow'].includes(this.currentTool)) {
					const pos = this.getMousePos(e);
					const current = this.elements[this.elements.length - 1];
					if (current) {
						current.x2 = pos.x;
						current.y2 = pos.y;
						if (current.x > current.x2) [current.x, current.x2] = [current.x2, current.x];
						if (current.y > current.y2) [current.y, current.y2] = [current.y2, current.y];
						this.saveState();
					}
				} else if (this.currentTool === 'pen') {
					this.saveState();
				}

				if (this.currentTool === 'select' && this.getSelection().length) {
					this.saveState();
				}

				this.isDrawing = false;
				this.dragLast = null;
				this.updateElementCount();
			},

			normalizeElementBounds(el) {
				if (!el) return;
				if (typeof el.x2 === 'number' && typeof el.y2 === 'number') {
					if (el.x > el.x2) { const t = el.x; el.x = el.x2; el.x2 = t; }
					if (el.y > el.y2) { const t = el.y; el.y = el.y2; el.y2 = t; }
				}
			},

			getElementBounds(el) {
				if (!el) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
				if (el.type === 'pen' && el.points && el.points.length) {
					let minX = el.points[0].x, maxX = el.points[0].x;
					let minY = el.points[0].y, maxY = el.points[0].y;
					for (const p of el.points) {
						minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
						minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
					}
					return { minX, minY, maxX, maxY };
				}
				if (el.type === 'text') {
					this.ctx.font = `${el.strokeWidth * 8}px sans-serif`;
					const metrics = this.ctx.measureText(el.text || '');
					const w = metrics.width;
					const h = el.strokeWidth * 8;
					return { minX: el.x, minY: el.y - h, maxX: el.x + w, maxY: el.y };
				}
				return {
					minX: Math.min(el.x, el.x2),
					minY: Math.min(el.y, el.y2),
					maxX: Math.max(el.x, el.x2),
					maxY: Math.max(el.y, el.y2)
				};
			},

			moveElementBy(el, dx, dy) {
				if (!el) return;
				if (el.type === 'pen' && el.points) {
					for (const p of el.points) { p.x += dx; p.y += dy; }
					return;
				}
				if (el.type === 'text') {
					el.x += dx;
					el.y += dy;
					return;
				}
				if (typeof el.x === 'number') el.x += dx;
				if (typeof el.y === 'number') el.y += dy;
				if (typeof el.x2 === 'number') el.x2 += dx;
				if (typeof el.y2 === 'number') el.y2 += dy;
			},

			moveSelectionBy(dx, dy) {
				const sel = this.getSelection();
				if (!sel.length) return;
				for (const el of sel) {
					this.moveElementBy(el, dx, dy);
				}
			},

			getElementsInRect(rect, fullyContained) {
				const out = [];
				for (const el of this.elements) {
					if (!el) continue;
					const b = this.getElementBounds(el);
					const inside = fullyContained
						? (b.minX >= rect.minX && b.maxX <= rect.maxX && b.minY >= rect.minY && b.maxY <= rect.maxY)
						: !(b.maxX < rect.minX || b.minX > rect.maxX || b.maxY < rect.minY || b.minY > rect.maxY);
					if (inside) out.push(el);
				}
				return out;
			},

			alignSelection(mode) {
				const sel = this.getSelection();
				if (sel.length < 2) return;
				const ref = sel[sel.length - 1];
				if (!ref) return;
				const rb = this.getElementBounds(ref);
				const refCx = (rb.minX + rb.maxX) / 2;
				const refCy = (rb.minY + rb.maxY) / 2;
				for (const el of sel) {
					if (!el || el.id === ref.id) continue;
					const b = this.getElementBounds(el);
					let dx = 0;
					let dy = 0;
					switch (mode) {
						case 'left': dx = rb.minX - b.minX; break;
						case 'hcenter': dx = refCx - (b.minX + b.maxX) / 2; break;
						case 'right': dx = rb.maxX - b.maxX; break;
						case 'top': dy = rb.minY - b.minY; break;
						case 'vcenter': dy = refCy - (b.minY + b.maxY) / 2; break;
						case 'bottom': dy = rb.maxY - b.maxY; break;
					}
					this.moveElementBy(el, dx, dy);
				}
				this.saveState();
				this.render();
			},

			matchSelectionSize(kind) {
				const sel = this.getSelection();
				if (sel.length < 2) return;
				const ref = sel[sel.length - 1];
				if (!ref) return;
				const rb = this.getElementBounds(ref);
				const refW = rb.maxX - rb.minX;
				const refH = rb.maxY - rb.minY;
				for (const el of sel) {
					if (!el || el.id === ref.id) continue;
					if (el.type === 'pen') continue;
					if (el.type === 'text') continue;
					const b = this.getElementBounds(el);
					if (kind === 'width') {
						const minX = b.minX;
						el.x = minX;
						el.x2 = minX + refW;
					}
					if (kind === 'height') {
						const minY = b.minY;
						el.y = minY;
						el.y2 = minY + refH;
					}
					this.normalizeElementBounds(el);
				}
				this.saveState();
				this.render();
			},

			handleTouchStart(e) {
				e.preventDefault();
				const touch = e.touches[0];
				this.canvas.dispatchEvent(new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY }));
			},
			handleTouchMove(e) {
				e.preventDefault();
				const touch = e.touches[0];
				this.canvas.dispatchEvent(new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY }));
			},
			handleTouchEnd(e) {
				e.preventDefault();
				this.canvas.dispatchEvent(new MouseEvent('mouseup', {}));
			},

			handleWheel(e) {
				e.preventDefault();
				const container = document.getElementById('canvasContainer');
				const rect = container ? container.getBoundingClientRect() : this.canvas.getBoundingClientRect();
				const sx = e.clientX - rect.left;
				const sy = e.clientY - rect.top;
				const wx = (sx - this.panX) / this.zoom;
				const wy = (sy - this.panY) / this.zoom;
				const delta = e.deltaY > 0 ? 0.9 : 1.1;
				const newZoom = Math.max(0.1, Math.min(5, this.zoom * delta));
				this.zoom = newZoom;
				this.panX = sx - wx * this.zoom;
				this.panY = sy - wy * this.zoom;
				this.updateTransform();
			},

			handleDoubleClick(e) {
				const pos = this.getMousePos(e);
				const element = this.hitTest(pos.x, pos.y);
				if (element && element.type === 'equipmentNode') {
					this.openEquipmentPickerWithOptions({
						searchValue: element.salesCd || this.meta.salesCd || '',
						onSelected: (picked) => {
							const salesCd = String(picked && picked.salesCd || '').trim();
							if (!salesCd) return;
							element.salesCd = salesCd;
							element.eqpNm = String(picked.eqpNm || '').trim();
							this.setSalesContext({ salesCd: salesCd, eqpNm: element.eqpNm, ensureSummaryNode: false });
							this.saveState();
							this.refreshSalesStatus();
						}
					});
					return;
				}
				if (element && element.type === 'text') {
					const text = prompt('Edit text:', element.text);
					if (text !== null) {
						element.text = text;
						this.saveState();
						this.render();
					}
				}
			},

			handleKeyDown(e) {
				if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) {
					if (document.activeElement.tagName !== 'INPUT') {
						e.preventDefault();
						this.copySelectionToClipboard();
						return;
					}
				}
				if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) {
					// let paste event decide (image vs elements). arm internal fallback.
					this.internalPasteArmed = true;
				}
				if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
					e.preventDefault();
					this.spaceDown = true;
					this.canvas.style.cursor = 'grab';
					return;
				}
				if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
					e.preventDefault();
					this.undo();
				}
				if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
					e.preventDefault();
					this.redo();
				}
				if (e.key === 'Delete' || e.key === 'Backspace') {
					if (document.activeElement.tagName !== 'INPUT') {
						e.preventDefault();
						this.deleteSelected();
					}
				}
				if (e.ctrlKey && e.key === 's') {
					e.preventDefault();
					this.saveToServer();
				}
				if (!e.ctrlKey && document.activeElement.tagName !== 'INPUT') {
					switch (e.key.toLowerCase()) {
						case 'v': this.setTool('select'); break;
						case 'r': this.setTool('rectangle'); break;
						case 'e': this.setTool('ellipse'); break;
						case 'a': this.setTool('arrow'); break;
						case 'p': this.setTool('pen'); break;
						case 't': this.setTool('text'); break;
					}
				}
			},

			handleKeyUp(e) {
				if (e.code === 'Space') {
					this.spaceDown = false;
					this.canvas.style.cursor = (this.currentTool === 'select') ? 'default' : 'crosshair';
				}
			},

			handleResize() {
				this.render();
			},

			setTool(tool) {
				this.currentTool = tool;
				document.querySelectorAll('.editor-toolbar-btn').forEach(btn => {
					btn.classList.toggle('active', btn.dataset.tool === tool);
				});
				this.canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';
			},

			createElement(type, x1, y1, x2, y2, extra = {}) {
				const element = {
					id: Date.now() + Math.random(),
					type,
					x: x1,
					y: y1,
					x2: x2,
					y2: y2,
					strokeColor: this.properties.strokeColor,
					fillColor: this.properties.fillColor,
					fillAlpha: this.properties.fillTransparent ? 0.55 : 1,
					strokeWidth: this.properties.strokeWidth,
					...extra
				};
				if (type === 'pen') {
					element.points = [{ x: x1, y: y1 }];
				}
				this.elements.push(element);
				this.selectElement(element);
				this.render();
				return element;
			},

			hitTest(x, y) {
				for (let i = this.elements.length - 1; i >= 0; i--) {
					const el = this.elements[i];
					if (el.type === 'pen') {
						for (const point of el.points) {
							const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
							if (dist < 10) return el;
						}
					} else if (el.type === 'text') {
						this.ctx.font = `${el.strokeWidth * 8}px sans-serif`;
						const metrics = this.ctx.measureText(el.text);
						const width = metrics.width;
						const height = el.strokeWidth * 8;
						if (x >= el.x && x <= el.x + width && y >= el.y - height && y <= el.y) {
							return el;
						}
					} else {
						const minX = Math.min(el.x, el.x2);
						const maxX = Math.max(el.x, el.x2);
						const minY = Math.min(el.y, el.y2);
						const maxY = Math.max(el.y, el.y2);
						if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
							return el;
						}
					}
				}
				return null;
			},

			getResizeHandle(x, y) {
				if (!this.selectedElement) return null;
				const el = this.selectedElement;
				if (el.type === 'text' || el.type === 'pen') return null;
				const b = this.getElementBounds(el);
				const minX = b.minX;
				const maxX = b.maxX;
				const minY = b.minY;
				const maxY = b.maxY;
				const hs = 7;
				if (Math.abs(x - minX) <= hs && Math.abs(y - minY) <= hs) return 'nw';
				if (Math.abs(x - maxX) <= hs && Math.abs(y - minY) <= hs) return 'ne';
				if (Math.abs(x - minX) <= hs && Math.abs(y - maxY) <= hs) return 'sw';
				if (Math.abs(x - maxX) <= hs && Math.abs(y - maxY) <= hs) return 'se';
				return null;
			},

			handleResize(x, y) {
				const el = this.selectedElement;
				if (!el) return;
				switch (this.resizeHandle) {
					case 'nw': el.x = x; el.y = y; break;
					case 'ne': el.x2 = x; el.y = y; break;
					case 'sw': el.x = x; el.y2 = y; break;
					case 'se': el.x2 = x; el.y2 = y; break;
				}

				// If user drags past the opposite side, flip the active handle so
				// resizing remains intuitive (no "inverted" feel).
				if (typeof el.x2 === 'number' && typeof el.y2 === 'number') {
					let h = this.resizeHandle;
					if (el.x > el.x2) {
						const t = el.x; el.x = el.x2; el.x2 = t;
						if (h === 'nw') h = 'ne';
						else if (h === 'ne') h = 'nw';
						else if (h === 'sw') h = 'se';
						else if (h === 'se') h = 'sw';
					}
					if (el.y > el.y2) {
						const t = el.y; el.y = el.y2; el.y2 = t;
						if (h === 'nw') h = 'sw';
						else if (h === 'sw') h = 'nw';
						else if (h === 'ne') h = 'se';
						else if (h === 'se') h = 'ne';
					}
					this.resizeHandle = h;
				}
			},

			selectElement(element) {
				if (element) this.setSingleSelection(element);
				else this.clearSelection();
			},

			deleteSelected() {
				const sel = this.getSelection();
				if (!sel.length) return;
				const ids = {};
				for (const el of sel) ids[el.id] = true;
				this.elements = this.elements.filter(el => !ids[el.id]);
				this.clearSelection();
				this.saveState();
				this.render();
				this.updateElementCount();
			},

			updateSelectedProperties() {
				const sel = this.getSelection();
				if (!sel.length) return;
				for (const el of sel) {
					if (!el) continue;
					el.strokeColor = this.properties.strokeColor;
					if (el.type !== 'pen' && el.type !== 'arrow') {
						el.fillColor = this.properties.fillColor;
						el.fillAlpha = this.properties.fillTransparent ? 0.55 : 1;
					}
					el.strokeWidth = this.properties.strokeWidth;
				}
				this.render();
			},

			render() {
				const ctx = this.ctx;
				ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
				this.drawGrid();
				this.elements.forEach(el => {
					ctx.strokeStyle = el.strokeColor;
					ctx.lineWidth = el.strokeWidth;
					ctx.lineCap = 'round';
					ctx.lineJoin = 'round';

				switch (el.type) {
							case 'rectangle':
							{
								const fill = (el.fillColor && el.fillColor !== 'transparent') ? el.fillColor : null;
								if (fill) {
									const a = (typeof el.fillAlpha === 'number') ? el.fillAlpha : 1;
									ctx.save();
									ctx.globalAlpha = a;
									ctx.globalCompositeOperation = (a < 1) ? 'multiply' : 'source-over';
									ctx.fillStyle = fill;
									ctx.beginPath();
									ctx.rect(el.x, el.y, el.x2 - el.x, el.y2 - el.y);
									ctx.fill();
									ctx.restore();
								}
								ctx.beginPath();
								ctx.rect(el.x, el.y, el.x2 - el.x, el.y2 - el.y);
								ctx.stroke();
								break;
							}
							case 'ellipse': {
								const fill = (el.fillColor && el.fillColor !== 'transparent') ? el.fillColor : null;
								const cx = (el.x + el.x2) / 2;
								const cy = (el.y + el.y2) / 2;
								const rx = Math.abs(el.x2 - el.x) / 2;
								const ry = Math.abs(el.y2 - el.y) / 2;
								if (fill) {
									const a = (typeof el.fillAlpha === 'number') ? el.fillAlpha : 1;
									ctx.save();
									ctx.globalAlpha = a;
									ctx.globalCompositeOperation = (a < 1) ? 'multiply' : 'source-over';
									ctx.fillStyle = fill;
									ctx.beginPath();
									ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
									ctx.fill();
									ctx.restore();
								}
								ctx.beginPath();
								ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
								ctx.stroke();
								break;
							}
						case 'arrow':
							this.drawArrow(ctx, el.x, el.y, el.x2, el.y2);
							break;
						case 'pen':
							if (el.points && el.points.length > 1) {
								ctx.beginPath();
								ctx.moveTo(el.points[0].x, el.points[0].y);
								for (let i = 1; i < el.points.length; i++) ctx.lineTo(el.points[i].x, el.points[i].y);
								ctx.stroke();
							}
							break;
							case 'text':
								ctx.fillStyle = el.strokeColor;
								ctx.font = `${el.strokeWidth * 8}px sans-serif`;
								ctx.fillText(el.text, el.x, el.y);
								break;
							case 'image':
								this.drawImageElement(ctx, el);
								break;
							case 'equipmentNode':
								this.drawEquipmentNode(ctx, el);
								break;
						}
				});

				if (this.currentTool === 'select') {
					const sel = this.getSelection();
					if (sel.length) {
						for (const el of sel) {
							if (!el) continue;
							ctx.strokeStyle = '#2563eb';
							ctx.lineWidth = 1;
							ctx.setLineDash([5, 5]);
							if (el.type === 'text') {
								this.ctx.font = `${el.strokeWidth * 8}px sans-serif`;
								const metrics = this.ctx.measureText(el.text || '');
								const width = metrics.width;
								const height = el.strokeWidth * 8;
								ctx.strokeRect(el.x - 5, el.y - height - 5, width + 10, height + 10);
							} else {
								const b = this.getElementBounds(el);
								ctx.strokeRect(b.minX - 5, b.minY - 5, b.maxX - b.minX + 10, b.maxY - b.minY + 10);
								// draw resize handles only for primary
								if (this.selectedElement && el.id === this.selectedElement.id) {
									ctx.setLineDash([]);
									this.drawResizeHandles(ctx, b.minX, b.minY, b.maxX, b.maxY);
								}
							}
							ctx.setLineDash([]);
						}
					}
				}

				if (this.isMarquee && this.marqueeStart && this.marqueeEnd) {
					const x1 = this.marqueeStart.x;
					const y1 = this.marqueeStart.y;
					const x2 = this.marqueeEnd.x;
					const y2 = this.marqueeEnd.y;
					ctx.save();
					ctx.strokeStyle = 'rgba(37, 99, 235, 0.85)';
					ctx.lineWidth = 1;
					ctx.setLineDash([6, 4]);
					ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
					ctx.setLineDash([]);
					ctx.restore();
				}
			},

			drawImageElement(ctx, el) {
			if (!el || !el.src) return;
			const b = this.getElementBounds(el);
			let img = this.imageCache[el.id];
			if (!img) {
				img = new Image();
				img.onload = () => {
					this.imageCache[el.id] = img;
					this.render();
				};
				img.src = el.src;
				this.imageCache[el.id] = img;
			}
			if (!img || !img.complete || !img.naturalWidth) {
				// not ready yet
				return;
			}
			ctx.save();
			ctx.globalAlpha = 1;
			ctx.globalCompositeOperation = 'source-over';
			ctx.drawImage(img, b.minX, b.minY, b.maxX - b.minX, b.maxY - b.minY);
			ctx.strokeStyle = el.strokeColor || '#000000';
			ctx.lineWidth = el.strokeWidth || 1;
			ctx.strokeRect(b.minX, b.minY, b.maxX - b.minX, b.maxY - b.minY);
			ctx.restore();
		},

			drawResizeHandles(ctx, minX, minY, maxX, maxY) {
			const size = 8;
			ctx.save();
			ctx.fillStyle = '#ffffff';
			ctx.strokeStyle = '#2563eb';
			ctx.lineWidth = 1;
			const pts = [
				{ x: minX, y: minY },
				{ x: maxX, y: minY },
				{ x: minX, y: maxY },
				{ x: maxX, y: maxY }
			];
			for (const p of pts) {
				ctx.beginPath();
				ctx.rect(p.x - size / 2, p.y - size / 2, size, size);
				ctx.fill();
				ctx.stroke();
			}
			ctx.restore();
		},

			drawEquipmentNode(ctx, el) {
			const x1 = Math.min(el.x, el.x2);
			const y1 = Math.min(el.y, el.y2);
			const x2 = Math.max(el.x, el.x2);
			const y2 = Math.max(el.y, el.y2);
			const w = Math.max(40, x2 - x1);
			const h = Math.max(30, y2 - y1);
			const r = 10;
			ctx.save();

			// blended fill (when colored) so overlaps show mixed colors
			const fill = (el.fillColor && el.fillColor !== 'transparent') ? el.fillColor : null;
			if (fill) {
				ctx.save();
				const a = (typeof el.fillAlpha === 'number') ? el.fillAlpha : 0.55;
				ctx.globalAlpha = a;
				ctx.globalCompositeOperation = (a < 1) ? 'multiply' : 'source-over';
				ctx.fillStyle = fill;
				this.roundRect(ctx, x1, y1, w, h, r);
				ctx.fill();
				ctx.restore();
			} else {
				ctx.fillStyle = 'rgba(255,255,255,0.65)';
				this.roundRect(ctx, x1, y1, w, h, r);
				ctx.fill();
			}

			ctx.strokeStyle = el.strokeColor || '#2563eb';
			ctx.lineWidth = 2;
			this.roundRect(ctx, x1, y1, w, h, r);
			ctx.stroke();

			// header bar
			ctx.fillStyle = 'rgba(37, 99, 235, 0.10)';
			this.roundRect(ctx, x1, y1, w, 26, r);
			ctx.fill();

			ctx.fillStyle = '#0f172a';
			ctx.font = 'bold 12px sans-serif';
			const title = (el.summary ? '[요약] ' : '') + (el.eqpNm ? `설비: ${el.eqpNm}` : '설비');
			ctx.fillText(this.ellipsisText(ctx, title, w - 140), x1 + 8, y1 + 18);

			// badges (status + issue count)
			const status = String(el.scheduleStatus || '').trim();
			const issueCnt = (typeof el.issueCount === 'number') ? el.issueCount : parseInt(el.issueCount || 0, 10) || 0;
			this.drawEquipmentBadges(ctx, x1, y1, w, status, issueCnt);

			ctx.font = '11px sans-serif';
			ctx.fillStyle = '#334155';
			ctx.fillText(this.ellipsisText(ctx, `SalesCd: ${el.salesCd || '-'}`, w - 16), x1 + 8, y1 + 44);
			ctx.fillText(this.ellipsisText(ctx, `일정상태: ${el.scheduleStatus || '-'}`, w - 16), x1 + 8, y1 + 62);
			ctx.fillText(this.ellipsisText(ctx, `문제: ${typeof el.issueCount === 'number' ? el.issueCount : '-'}`, w - 16), x1 + 8, y1 + 80);
			if (el.lastSyncAt) {
				ctx.fillStyle = '#64748b';
				ctx.font = '10px sans-serif';
				ctx.fillText(this.ellipsisText(ctx, `Last: ${el.lastSyncAt}`, w - 16), x1 + 8, y1 + h - 10);
			}
			ctx.restore();
		},

			drawEquipmentBadges(ctx, x1, y1, w, scheduleStatus, issueCount) {
			ctx.save();
			ctx.font = 'bold 10px sans-serif';
			const map = {
				'완료': '#64748b',
				'지연': '#ef4444',
				'확정': '#22c55e',
				'진행': '#3b82f6',
				'없음': '#94a3b8'
			};
			const st = scheduleStatus || '없음';
			const stColor = map[st] || '#94a3b8';
			const padX = 6;
			const padY = 3;
			const h = 16;
			const stW = Math.min(80, Math.ceil(ctx.measureText(st).width) + padX * 2);
			let x = x1 + w - 8;
			// issue badge
			const issueText = `문제 ${issueCount}`;
			const issueW = Math.min(80, Math.ceil(ctx.measureText(issueText).width) + padX * 2);
			const issueBg = issueCount > 0 ? '#f97316' : '#475569';
			x -= issueW;
			this.roundRect(ctx, x, y1 + 5, issueW, h, 7);
			ctx.fillStyle = issueBg;
			ctx.fill();
			ctx.fillStyle = '#ffffff';
			ctx.fillText(issueText, x + padX, y1 + 5 + 11);
			// status badge
			x -= (stW + 6);
			this.roundRect(ctx, x, y1 + 5, stW, h, 7);
			ctx.fillStyle = stColor;
			ctx.fill();
			ctx.fillStyle = '#ffffff';
			ctx.fillText(st, x + padX, y1 + 5 + 11);
			ctx.restore();
		},

			roundRect(ctx, x, y, w, h, r) {
			const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			ctx.arcTo(x + w, y, x + w, y + h, radius);
			ctx.arcTo(x + w, y + h, x, y + h, radius);
			ctx.arcTo(x, y + h, x, y, radius);
			ctx.arcTo(x, y, x + w, y, radius);
			ctx.closePath();
		},

			ellipsisText(ctx, text, maxWidth) {
			const s = String(text || '');
			if (ctx.measureText(s).width <= maxWidth) return s;
			let out = s;
			while (out.length > 0 && ctx.measureText(out + '...').width > maxWidth) {
				out = out.slice(0, -1);
			}
			return (out.length ? out : '') + '...';
		},

			drawGrid() {
				const ctx = this.ctx;
				ctx.strokeStyle = '#f1f5f9';
				ctx.lineWidth = 1;
				const gridSize = 20;
				for (let x = 0; x < this.canvas.width; x += gridSize) {
					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x, this.canvas.height);
					ctx.stroke();
				}
				for (let y = 0; y < this.canvas.height; y += gridSize) {
					ctx.beginPath();
					ctx.moveTo(0, y);
					ctx.lineTo(this.canvas.width, y);
					ctx.stroke();
				}
			},

			drawArrow(ctx, x1, y1, x2, y2) {
				const headLength = 15;
				const angle = Math.atan2(y2 - y1, x2 - x1);
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
				ctx.stroke();
			},

			saveState() {
				this.history = this.history.slice(0, this.historyIndex + 1);
				this.history.push(JSON.stringify(this.elements));
				this.historyIndex = this.history.length - 1;
				if (this.history.length > 50) {
					this.history.shift();
					this.historyIndex--;
				}
				this.saveToLocalStorage();
			},

			undo() {
				if (this.historyIndex > 0) {
					this.historyIndex--;
					this.elements = JSON.parse(this.history[this.historyIndex]);
					this.selectElement(null);
					this.render();
					this.updateElementCount();
					this.showToast('Undo');
				}
			},

			redo() {
				if (this.historyIndex < this.history.length - 1) {
					this.historyIndex++;
					this.elements = JSON.parse(this.history[this.historyIndex]);
					this.selectElement(null);
					this.render();
					this.updateElementCount();
					this.showToast('Redo');
				}
			},

			clearCanvas() {
				if (confirm('Clear all elements?')) {
					this.elements = [];
					this.selectElement(null);
					this.saveState();
					this.render();
					this.updateElementCount();
				}
			},

			saveToLocalStorage() {
				try {
					localStorage.setItem('wb1001m01_drawing', JSON.stringify({
						elements: this.elements,
						properties: this.properties,
						meta: this.meta,
						autoRefresh: this.autoRefresh
					}));
				} catch (e) {
					console.warn('Could not save to localStorage:', e);
				}
			},

			loadFromLocalStorage() {
				try {
					const saved = localStorage.getItem('wb1001m01_drawing');
					if (saved) {
						const data = JSON.parse(saved);
						this.elements = data.elements || [];
						this.properties = data.properties || this.properties;
						this.meta = data.meta ? { ...this.meta, ...data.meta } : this.meta;
						this.autoRefresh = !!data.autoRefresh;
						this.updateMetaView();
						this.history = [JSON.stringify(this.elements)];
						this.historyIndex = 0;
						this.updateElementCount();
					}
				} catch (e) {
					console.warn('Could not load from localStorage:', e);
				}
			},

			exportJSON() {
				const data = {
					version: '1.0',
					timestamp: new Date().toISOString(),
					elements: this.elements,
					properties: this.properties,
					meta: this.meta
				};
				const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `drawing_${Date.now()}.json`;
				a.click();
				URL.revokeObjectURL(url);
				this.showToast('Exported');
			},

			importJSON(event) {
				const file = event.target.files[0];
				if (!file) return;
				const reader = new FileReader();
				reader.onload = (e) => {
					try {
						const data = JSON.parse(e.target.result);
						if (data.elements) {
							this.elements = data.elements;
							if (data.properties) {
								this.properties = { ...this.properties, ...data.properties };
							}
							if (data.meta) {
								this.meta = { ...this.meta, ...data.meta };
								this.updateMetaView();
							}
							this.saveState();
							this.render();
							this.updateElementCount();
							this.showToast('Imported');
						}
					} catch (err) {
						this.showToast('Invalid JSON');
					}
				};
				reader.readAsText(file);
				event.target.value = '';
			},

			async saveToServer() {
				const data = {
					id: 'wb1001m01_default',
					name: 'Default Drawing',
					elements: this.elements,
					properties: this.properties,
					updatedAt: new Date().toISOString()
				};
				try {
					const response = await fetch('/api/drawings', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(data)
					});
					this.showToast(response.ok ? 'Saved' : 'Save failed');
				} catch (err) {
					console.log('Server save stub:', data);
					this.showToast('Saved (stub)');
				}
			},

			async loadFromServer() {
				try {
					const response = await fetch('/api/drawings/wb1001m01_default');
					if (response.ok) {
						const data = await response.json();
						this.elements = data.elements || [];
						this.properties = data.properties || this.properties;
						this.saveState();
						this.render();
						this.updateElementCount();
						this.showToast('Loaded');
					} else {
						this.showToast('Load failed');
					}
				} catch (err) {
					this.showToast('Server unavailable');
				}
			},

			zoomIn() {
				this.zoom = Math.min(5, this.zoom * 1.2);
				this.updateTransform();
			},
			zoomOut() {
				this.zoom = Math.max(0.1, this.zoom / 1.2);
				this.updateTransform();
			},
			resetView() {
				this.zoom = 1;
				const container = document.getElementById('canvasContainer');
				this.panX = (container.clientWidth - this.canvas.width) / 2;
				this.panY = (container.clientHeight - this.canvas.height) / 2;
				this.updateTransform();
			},

			updateElementCount() {
				document.getElementById('elementCount').textContent = this.elements.length;
			},

			showToast(message) {
				const toast = document.getElementById('toast');
				toast.textContent = message;
				toast.classList.add('show');
				setTimeout(() => toast.classList.remove('show'), 2000);
			}
		};
	</script>
</body>
</html>
