<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8" />
	<title>WB1001M01 Drawing Editor</title>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=0.6, user-scalable=no">
	<link rel="icon" href="/static/favicon.ico" type="image/x-icon">

	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-theme.min.css">
	<link rel="stylesheet" href="/static/bootstrap/css/dashboard.css">
	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-datepicker.css">
	<link rel="stylesheet" href="/static/fontawesome/css/all.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5grid.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5mask.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5modal.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5toast.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5menu.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5calendar.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5picker.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5select.css">
	<link rel="stylesheet" href="/static/css/jstree/style.min.css">
	<link rel="stylesheet" href="/static/css/ax5/ax5combobox.css">
	<link rel="stylesheet" href="/static/css/gnb.css">
	<link rel="stylesheet" href="/static/css/main.css">
	<link rel="stylesheet" href="/static/css/sub.css">
	<link rel="stylesheet" href="/static/css/common.css">
	<link rel="stylesheet" href="/static/bootstrap/css/bootstrap-multiselect.css">

	<style>
		#wb1001m01-editor {
			--wb-editor-primary: #2563eb;
			--wb-editor-primary-hover: #1d4ed8;
			--wb-editor-bg-dark: #1e293b;
			--wb-editor-border: #e2e8f0;
			--wb-editor-text: #334155;
			--wb-editor-text-light: #64748b;
			--wb-editor-toolbar-width: 60px;
			--wb-editor-properties-width: 240px;
			--wb-editor-header-height: 50px;
			width: 100%;
			height: 100%;
		}

		#wb1001m01-editor .editor-wrapper {
			display: flex;
			flex-direction: column;
			height: calc(100vh - 100px);
			position: relative;
			border: 1px solid var(--wb-editor-border);
			border-radius: 12px;
			background: #fff;
			overflow: hidden;
		}

		#wb1001m01-editor .editor-body {
			display: flex;
			flex: 1;
			position: relative;
			overflow: hidden;
		}

		#wb1001m01-editor .editor-header {
			height: var(--wb-editor-header-height);
			background: var(--wb-editor-bg-dark);
			color: white;
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 0 5px;
		}

		#wb1001m01-editor .editor-header-title {
			font-size: 14px;
			font-weight: 600;
			letter-spacing: 0.2px;
		}

		#wb1001m01-editor .editor-header-actions {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			justify-content: flex-end;
		}

		#wb1001m01-editor .editor-header-btn {
			background: var(--wb-editor-primary);
			color: white;
			border: none;
			padding: 5px 12px;
			border-radius: 4px;
			font-size: 11px;
			cursor: pointer;
			transition: background 0.2s;
		}

		#wb1001m01-editor .editor-header-btn:hover {
			background: var(--wb-editor-primary-hover);
		}

		#wb1001m01-editor .editor-header-btn.secondary {
			background: #475569;
		}

		#wb1001m01-editor .editor-header-btn.secondary:hover {
			background: #64748b;
		}

		/* Readable disabled state for edit-only controls */
		#wb1001m01-editor .requires-edit[aria-disabled="true"] {
			opacity: 1 !important;
			filter: none !important;
			background: #e2e8f0 !important;
			color: #64748b !important;
			border: 1px solid #cbd5e1 !important;
			cursor: not-allowed !important;
		}

		#wb1001m01-editor .editor-toolbar {
			width: var(--wb-editor-toolbar-width);
			background: white;
			border-right: 1px solid var(--wb-editor-border);
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 10px 8px;
			gap: 6px;
			overflow-y: auto;
			z-index: 10;
		}

		#wb1001m01-editor .editor-toolbar-btn {
			width: 40px;
			height: 40px;
			border: 1px solid transparent;
			background: transparent;
			border-radius: 6px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			transition: all 0.15s;
			color: var(--wb-editor-text-light);
		}

		#wb1001m01-editor .editor-toolbar-btn:hover {
			background: #f1f5f9;
			color: var(--wb-editor-text);
		}

		#wb1001m01-editor .editor-toolbar-btn.active {
			background: #eff6ff;
			border-color: var(--wb-editor-primary);
			color: var(--wb-editor-primary);
		}

		#wb1001m01-editor .editor-toolbar-divider {
			width: 30px;
			height: 1px;
			background: var(--wb-editor-border);
			margin: 8px 0;
		}

		#wb1001m01-editor .editor-properties {
			width: var(--wb-editor-properties-width);
			background: white;
			border-left: 1px solid var(--wb-editor-border);
			padding: 12px;
			overflow-y: auto;
			z-index: 10;
		}

		#wb1001m01-editor.properties-collapsed .editor-properties {
			display: none;
		}

		#wb1001m01-editor.properties-collapsed {
			--wb-editor-properties-width: 0px;
		}

		#wb1001m01-editor .wb1001-properties-handle {
			position: absolute;
			top: 50%;
			right: 6px;
			transform: translateY(-50%);
			display: none;
			z-index: 50;
		}

		#wb1001m01-editor.properties-collapsed .wb1001-properties-handle {
			display: block;
		}

		#wb1001m01-editor .wb1001-properties-handle button {
			border: 1px solid rgba(148,163,184,0.35);
			background: rgba(255,255,255,0.92);
			color: var(--wb-editor-text);
			border-radius: 999px;
			padding: 10px 8px;
			font-size: 11px;
			font-weight: 700;
			cursor: pointer;
			box-shadow: 0 6px 20px rgba(0,0,0,0.15);
			writing-mode: vertical-rl;
			text-orientation: mixed;
			letter-spacing: 0.5px;
		}

		#wb1001m01-editor .wb1001-properties-handle button:hover {
			background: #ffffff;
			border-color: rgba(37,99,235,0.45);
		}

		#wb1001m01-editor .editor-properties-section {
			margin-bottom: 16px;
		}

		#wb1001m01-editor .editor-properties-title {
			font-size: 10px;
			font-weight: 600;
			text-transform: uppercase;
			color: var(--wb-editor-text-light);
			margin-bottom: 8px;
			letter-spacing: 0.5px;
		}

		#wb1001m01-editor .editor-properties-row {
			display: flex;
			align-items: center;
			margin-bottom: 8px;
			gap: 8px;
		}

		#wb1001m01-editor .editor-properties-label {
			font-size: 11px;
			color: var(--wb-editor-text);
			flex: 1;
		}

		#wb1001m01-editor .editor-properties-input {
			width: 100%;
			padding: 4px 8px;
			border: 1px solid var(--wb-editor-border);
			border-radius: 4px;
			font-size: 11px;
		}

		#wb1001m01-editor .editor-properties-input[type="color"] {
			width: 32px;
			height: 28px;
			padding: 2px;
			cursor: pointer;
		}

		#wb1001m01-editor .editor-properties-value {
			width: 34px;
			text-align: right;
			font-size: 11px;
			color: var(--wb-editor-text-light);
		}

		#wb1001m01-editor .editor-color-palette {
			display: grid;
			grid-template-columns: repeat(6, 1fr);
			gap: 4px;
			margin-top: 6px;
		}

		#wb1001m01-editor .editor-color-swatch {
			width: 22px;
			height: 22px;
			border-radius: 4px;
			cursor: pointer;
			border: 2px solid transparent;
			transition: transform 0.15s;
		}

		#wb1001m01-editor .editor-color-swatch:hover {
			transform: scale(1.08);
		}

		#wb1001m01-editor .editor-canvas-container {
			flex: 1;
			background: #f8fafc;
			overflow: hidden;
			position: relative;
		}

		#wb1001m01-editor .editor-canvas-wrapper {
			position: absolute;
			top: 0;
			left: 0;
			transform-origin: 0 0;
		}

		#wb1001m01-editor canvas#mainCanvas {
			background: white;
			box-shadow: 0 2px 8px rgba(0,0,0,0.08);
			cursor: crosshair;
			display: block;
		}

		#wb1001m01-editor .editor-zoom-controls {
			position: absolute;
			bottom: 14px;
			left: 14px;
			display: flex;
			gap: 4px;
			background: white;
			padding: 4px;
			border-radius: 6px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.1);
			z-index: 5;
		}

		#wb1001m01-editor .editor-zoom-btn {
			width: 28px;
			height: 28px;
			border: 1px solid var(--wb-editor-border);
			background: white;
			color: var(--wb-editor-text);
			font-weight: 700;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		#wb1001m01-editor .editor-zoom-btn:hover {
			background: #f1f5f9;
		}

		#wb1001m01-editor .editor-zoom-level {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 45px;
			font-size: 11px;
			color: var(--wb-editor-text);
		}

		#wb1001m01-editor .editor-shortcuts-info {
			position: absolute;
			bottom: 14px;
			right: 14px;
			background: rgba(30, 41, 59, 0.9);
			color: white;
			padding: 8px 12px;
			border-radius: 6px;
			font-size: 10px;
			z-index: 5;
		}

		.wb1001-top-tools {
			display: inline-flex;
			align-items: center;
			gap: 8px;
			white-space: nowrap;
		}

		.wb1001-top-tools .wb1001-header-actions-inline {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			flex-wrap: nowrap;
			white-space: nowrap;
		}

		.wb1001-top-tools .editor-header-btn {
			background: var(--wb-editor-primary);
			color: #fff;
			border: none;
			padding: 5px 10px;
			border-radius: 4px;
			font-size: 11px;
			cursor: pointer;
			transition: background 0.2s;
		}

		.wb1001-top-tools .editor-header-btn:hover {
			background: var(--wb-editor-primary-hover);
		}

		.wb1001-top-tools .editor-header-btn.secondary {
			background: #475569;
		}

		.wb1001-top-tools .editor-header-btn.secondary:hover {
			background: #64748b;
		}

		.wb1001-top-tools .wb1001-save-btn.dirty {
			background: #dc2626;
		}

		.wb1001-top-tools .wb1001-save-btn.dirty:hover {
			background: #b91c1c;
		}

		.wb1001-top-tools .editor-zoom-controls {
			position: static;
			bottom: auto;
			left: auto;
			display: flex;
			align-items: center;
			gap: 4px;
			background: white;
			padding: 2px;
			border-radius: 6px;
			box-shadow: none;
			border: 1px solid var(--wb-editor-border);
		}

		.wb1001-top-tools .editor-zoom-btn {
			width: 26px;
			height: 26px;
			font-size: 13px;
			border: 1px solid var(--wb-editor-border);
			background: white;
			color: var(--wb-editor-text);
			font-weight: 700;
			border-radius: 4px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.wb1001-top-tools .editor-zoom-btn:hover {
			background: #f1f5f9;
		}

		.wb1001-top-tools .editor-zoom-level {
			width: 48px;
			font-size: 11px;
		}

		.wb1001-top-tools .editor-shortcuts-info {
			position: static;
			bottom: auto;
			right: auto;
			background: rgba(30, 41, 59, 0.92);
			padding: 4px 8px;
			border-radius: 6px;
			font-size: 10px;
			white-space: nowrap;
		}

		.wb1001-top-tools .editor-shortcuts-info kbd {
			background: rgba(255,255,255,0.18);
			padding: 2px 4px;
			border-radius: 3px;
			margin-right: 4px;
		}

		#wb1001m01-editor .editor-shortcuts-info kbd {
			background: rgba(255,255,255,0.2);
			padding: 2px 4px;
			border-radius: 3px;
			margin-right: 4px;
		}

		#wb1001m01-editor .editor-toast {
			position: absolute;
			bottom: 64px;
			left: 50%;
			transform: translateX(-50%);
			background: var(--wb-editor-bg-dark);
			color: white;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 12px;
			z-index: 100;
			opacity: 0;
			transition: opacity 0.3s;
			pointer-events: none;
		}

		#wb1001m01-editor .editor-toast.show {
			opacity: 1;
		}

		#wb1001m01-editor #fileInput {
			display: none;
		}

		@media (max-width: 768px) {
			#wb1001m01-editor .editor-properties { display: none; }
			#wb1001m01-editor .editor-shortcuts-info { display: none; }
			#wb1001m01-editor .wb1001-properties-handle { display: none; }
		}
	</style>
</head>
<body>
	<div id="head_area"></div>
	<div id="top_area"></div>
	<div id="main_area">
		<input type="hidden" id="pgmId" name="pgmId" value="WB1001M01">

		<div class="contents no_bg" style="padding-bottom: 8px;">
			<div style="display:flex; align-items:center; justify-content:space-between; gap:14px; flex-wrap:nowrap;">
				<div style="display:flex; align-items:center; gap:14px; flex-wrap:nowrap;">
					<div style="font-size: 16px; font-weight: 700; white-space:nowrap;">드로잉 에디터</div>
					<label style="display:inline-flex; align-items:center; gap:6px; font-weight:600; margin:0; white-space:nowrap;">
						<input type="checkbox" id="wb1001_refresh" style="margin:0;"> Refresh(1분)
					</label>
					<span id="wb1001_last_sync" style="color:#64748b; font-size:12px; white-space:nowrap;"></span>
				</div>

				<div class="wb1001-top-tools">
					<div class="wb1001-header-actions-inline">
						<button class="editor-header-btn secondary requires-edit" type="button" onclick="app.openEquipmentPicker()">설비</button>
						<button class="editor-header-btn secondary requires-edit" type="button" onclick="app.undo()">Undo</button>
						<button class="editor-header-btn secondary requires-edit" type="button" onclick="app.redo()">Redo</button>
						<button class="editor-header-btn secondary requires-edit" type="button" onclick="app.clearCanvas()">Clear</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.exportJSON()">Export</button>
						<button class="editor-header-btn secondary requires-edit" type="button" onclick="$('#fileInput').trigger('click')">Import</button>
						<button class="editor-header-btn secondary wb1001-save-btn requires-edit" type="button" onclick="app.saveToServer()">Save</button>
						<button class="editor-header-btn secondary" type="button" onclick="app.loadFromServer()">Load</button>
					</div>
					<div class="editor-zoom-controls">
						<button class="editor-zoom-btn" type="button" onclick="app.zoomOut()">-</button>
						<span class="editor-zoom-level" id="zoomLevel">100%</span>
						<button class="editor-zoom-btn" type="button" onclick="app.zoomIn()">+</button>
						<button class="editor-zoom-btn" type="button" onclick="app.resetView()" title="Reset View">R</button>
					</div>
					<div class="editor-shortcuts-info">
						<kbd>Ctrl+Z</kbd>Undo <kbd>Ctrl+Y</kbd>Redo <kbd>Delete</kbd>Delete <kbd>Ctrl+S</kbd>Save
					</div>
					<ul class="btn_ul" style="margin:0;">
						<li class="btn_r" style="float:none;">
							<button type="button" class="bg_gray requires-edit" onclick="app.openEquipmentPicker();">설비선택</button>
							<button type="button" class="bg_gray" onclick="manualPopup();">도움말</button>
						</li>
					</ul>
				</div>
			</div>
		</div>

		<div id="wb1001m01-editor">
			<div class="editor-wrapper">
<!-- 				<header class="editor-header"> -->
<!-- <!-- 					<div class="editor-header-title">WB1001M01 Drawing Editor</div> --> -->
<!-- 				</header> -->

				<div class="editor-body">
					<aside class="editor-toolbar">
						<button class="editor-toolbar-btn active" type="button" data-tool="select" title="Select (V)">↖</button>
						<button class="editor-toolbar-btn requires-edit" type="button" data-tool="rectangle" title="Rectangle (R)">□</button>
						<button class="editor-toolbar-btn requires-edit" type="button" data-tool="ellipse" title="Ellipse (E)">○</button>
					<button class="editor-toolbar-btn requires-edit" type="button" data-tool="arrow" title="Arrow (A)">→</button>
						<button class="editor-toolbar-btn requires-edit" type="button" data-tool="pen" title="Pen (P)">✎</button>
						<button class="editor-toolbar-btn requires-edit" type="button" data-tool="text" title="Text (T)">T</button>
						<button class="editor-toolbar-btn requires-edit" type="button" data-tool="equipmentNode" title="설비 노드">⚙</button>
						<div class="editor-toolbar-divider"></div>
						<button class="editor-toolbar-btn requires-edit" type="button" onclick="app.openEquipmentPicker()" title="설비 선택">E</button>
						<button class="editor-toolbar-btn requires-edit" type="button" onclick="app.undo()" title="Undo (Ctrl+Z)">↶</button>
						<button class="editor-toolbar-btn requires-edit" type="button" onclick="app.redo()" title="Redo (Ctrl+Y)">↷</button>
					</aside>

					<div class="editor-canvas-container" id="canvasContainer">
						<div class="editor-canvas-wrapper" id="canvasWrapper">
							<canvas id="mainCanvas"></canvas>
						</div>
					</div>

					<aside class="editor-properties">
						<div class="editor-properties-section">
							<div class="editor-properties-title">Stroke</div>
							<div class="editor-properties-row">
								<button class="editor-header-btn secondary" type="button" style="width:100%;" data-action="toggle-properties" onclick="app.togglePropertiesPanel()">속성 숨김</button>
							</div>
							<div class="editor-properties-row">
								<span class="editor-properties-label">Color</span>
								<input type="color" id="strokeColor" class="editor-properties-input" value="#000000">
							</div>
							<div class="editor-color-palette" id="strokePalette">
								<div class="editor-color-swatch" data-color="#000000" style="background:#000000"></div>
								<div class="editor-color-swatch" data-color="#ef4444" style="background:#ef4444"></div>
								<div class="editor-color-swatch" data-color="#f59e0b" style="background:#f59e0b"></div>
								<div class="editor-color-swatch" data-color="#22c55e" style="background:#22c55e"></div>
								<div class="editor-color-swatch" data-color="#3b82f6" style="background:#3b82f6"></div>
								<div class="editor-color-swatch" data-color="#8b5cf6" style="background:#8b5cf6"></div>
							</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Fill</div>
							<div class="editor-properties-row">
								<span class="editor-properties-label">Color</span>
								<input type="color" id="fillColor" class="editor-properties-input" value="#ffffff">
							</div>
							<div class="editor-properties-row">
								<span class="editor-properties-label">Transparent</span>
								<input type="checkbox" id="fillTransparent" checked>
							</div>
							<div class="editor-color-palette" id="fillPalette">
								<div class="editor-color-swatch" data-color="#ffffff" style="background:#ffffff; border:1px solid #e2e8f0"></div>
								<div class="editor-color-swatch" data-color="#fef3c7" style="background:#fef3c7"></div>
								<div class="editor-color-swatch" data-color="#dcfce7" style="background:#dcfce7"></div>
								<div class="editor-color-swatch" data-color="#dbeafe" style="background:#dbeafe"></div>
								<div class="editor-color-swatch" data-color="#fce7f3" style="background:#fce7f3"></div>
								<div class="editor-color-swatch" data-color="#f1f5f9" style="background:#f1f5f9"></div>
							</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Width</div>
							<div class="editor-properties-row">
								<input type="range" id="strokeWidth" class="editor-properties-input" min="1" max="20" value="2">
								<span class="editor-properties-value" id="strokeWidthValue">2px</span>
							</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Selected</div>
							<div class="editor-properties-row">
								<button class="editor-header-btn" type="button" style="width:100%;" onclick="app.deleteSelected()">Delete Selected</button>
							</div>
							<div class="editor-properties-row" id="selectedInfo" style="font-size:10px; color: var(--wb-editor-text-light);">No selection</div>
						</div>

						<div class="editor-properties-section">
							<div class="editor-properties-title">Info</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>Elements: <span id="elementCount">0</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>설비: <span id="wb1001_meta_eqpNm">-</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>SalesCd: <span id="wb1001_meta_salesCd">-</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>상태: <span id="wb1001_meta_schedule">-</span></span>
							</div>
							<div class="editor-properties-row" style="font-size:10px; color: var(--wb-editor-text-light);">
								<span>문제: <span id="wb1001_meta_issues">-</span></span>
							</div>
						</div>
					</aside>
				</div>
			</div>

			<div class="wb1001-properties-handle" aria-hidden="true">
				<button type="button" onclick="app.togglePropertiesPanel()" title="속성 보임/숨김">◀</button>
			</div>

			<div class="editor-toast" id="toast"></div>

			<div id="wb1001_context_menu" style="display:none; position:fixed; z-index:9999; min-width:180px; background:#0f172a; color:#fff; border:1px solid rgba(148,163,184,0.35); border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.25); padding:6px; font-size:12px;">
				<div id="wb1001_context_menu_title" style="padding:6px 8px; color:#cbd5e1; font-size:11px; border-bottom:1px solid rgba(148,163,184,0.2); margin-bottom:6px;"></div>
				<div id="wb1001_context_menu_items"></div>
			</div>

			<input type="file" id="fileInput" accept=".json" onchange="app.importJSON(event)">
		</div>
	</div>

	<script src="/static/js/jquery-latest.min.js"></script>
	<script src="/static/js/jquery.serializeObject.js"></script>
	<script src="/static/bootstrap/js/bootstrap.min.js"></script>
	<script src="/static/bootstrap/js/bootstrap-datepicker.min.js"></script>
	<script src="/static/bootstrap/js/bootstrap-datepicker.ko.min.js"></script>
	<script src="/static/js/moment/moment-with-locales.js"></script>
	<script src="/static/js/jstree/jstree.min.js"></script>
	<script src="/static/js/ax5/ax5core.min.js"></script>
	<script src="/static/js/ax5/ax5grid.min.js"></script>
	<script src="/static/js/ax5/ax5mask.min.js"></script>
	<script src="/static/js/ax5/ax5modal.min.js"></script>
	<script src="/static/js/ax5/ax5toast.min.js"></script>
	<script src="/static/js/ax5/ax5calendar.min.js"></script>
	<script src="/static/js/ax5/ax5picker.min.js"></script>
	<script src="/static/js/ax5/ax5menu.min.js"></script>
	<script src="/static/js/ax5/ax5formatter.min.js"></script>
	<script src="/static/js/ax5/ax5combobox.min.js"></script>
	<script src="/static/js/ax5/ax5select.min.js"></script>
	<script src="/static/js/exceljs.min.js"></script>
	<script src="/static/js/global.js"></script>
	<script src="/static/js/fileTree.js"></script>
	<script src="/static/js/workingDayCalc.js"></script>
	<script src="/static/js/korean-lunar-calendar.min.js"></script>
	<script src="/static/js/jquery.blockUI.js"></script>
	<script src="/static/bootstrap/js/bootstrap-multiselect.min.js"></script>
	<script src="/static/js/manualPopup.js"></script>

	<script>
		$(document).ready(function() {
			mainDefaultLoad("실행계획", "드로잉 에디터");
			setCommonSelect($("#main_area select[data-kind]"));

			$('#head_area').toggleClass('off');
			$('#top_area').toggleClass('on');
			$('#main_area').toggleClass('on');

			app.init();
		});
	</script>

	<script>
		const app = {
			canvas: null,
			ctx: null,
			elements: [],
			history: [],
			historyIndex: -1,
			selectedElement: null,
			selectedElements: [],
			_lastHit: { x: 0, y: 0, ts: 0, idx: 0, stackIds: [] },
			currentTool: 'select',
			isDrawing: false,
			isPanning: false,
			isMarquee: false,
			marqueeStart: null,
			marqueeEnd: null,
			marqueeAdd: false,
			spaceDown: false,
			panStartClient: null,
			panStartPan: null,
			dragLast: null,
			dragStart: null,
			draggingSelection: false,
			panX: 0,
			panY: 0,
			zoom: 1,
			properties: {
				strokeColor: '#000000',
				fillColor: '#ffffff',
				fillTransparent: true,
				strokeWidth: 2,
				fontSize: 14
			},
			meta: {
				eqpNm: '',
				salesCd: '',
				scheduleStatus: '',
				issueCount: 0,
				lastSyncAt: ''
			},
			autoRefresh: false,
			autoRefreshTimer: null,
				resizeHandle: null,
				textResizeStart: null,
				penResizeStart: null,
				boxResizeStart: null,
			contextMenu: null,
			contextMenuHit: { x: 0, y: 0 },
			lastPointer: { x: 0, y: 0 },
			imageCache: {},
			copyBuffer: null,
			internalPasteArmed: false,
			pasteArmedAt: 0,
			canEdit: false,
			editUserIds: ['js.nam'],
			propertiesCollapsed: false,
			dirty: false,
			didMutate: false,

			init() {
				this.canvas = $('#mainCanvas')[0];
				this.ctx = this.canvas.getContext('2d');
				this.setupCanvas();
				this.setupEventListeners();
				this.setupContextMenu();
				this.canEdit = this.isEditUser();
				this.applyPermissions();
				this.loadUiState();
				this.applyPropertiesPanelState();
				this.loadFromLocalStorage();
				this.applyPropertiesInputs();
				this.syncInfoPanelFromSelection();
				this.setDirty(false);
				this.render();
				this.bindRefreshCheckbox();
				if (this.autoRefresh) {
					this.setAutoRefresh(true);
				}
				$(window).off('beforeunload.wb1001').on('beforeunload.wb1001', () => {
					this.setAutoRefresh(false);
				});
			},

			setDirty(flag) {
				this.dirty = !!flag;
				$('.wb1001-save-btn').toggleClass('dirty', this.dirty);
			},

			markDirty() {
				this.setDirty(true);
			},

			markSaved() {
				this.setDirty(false);
			},

			async checkClipboardHasData() {
				// Best-effort check. May fail due to browser permissions.
				try {
					if (navigator.clipboard && navigator.clipboard.read) {
						const items = await navigator.clipboard.read();
						if (items && items.length) return true;
					}
				} catch (e) {}
				try {
					if (navigator.clipboard && navigator.clipboard.readText) {
						const t = await navigator.clipboard.readText();
						return !!String(t || '').trim();
					}
				} catch (e) {}
				return false;
			},

			async pasteFromMenu() {
				if (!this.canEdit) return;
				// Prefer internal element clipboard first
				if (this.copyBuffer) {
					this.pasteElementsFromPayload(this.copyBuffer);
					return;
				}
				// Try clipboard read (images/text)
				try {
					if (navigator.clipboard && navigator.clipboard.read) {
						const items = await navigator.clipboard.read();
						for (const item of items || []) {
							for (const type of (item.types || [])) {
								if (type && type.indexOf('image/') === 0) {
									const blob = await item.getType(type);
									const dataUrl = await new Promise((resolve) => {
										try {
											const reader = new FileReader();
											reader.onload = () => resolve(String(reader.result || ''));
											reader.onerror = () => resolve('');
											reader.readAsDataURL(blob);
										} catch (e) {
											resolve('');
										}
									});
									if (dataUrl) {
										this.addImageFromDataUrl(dataUrl);
										return;
									}
								}
							}
						}
					}
				} catch (e) {}
				try {
					if (navigator.clipboard && navigator.clipboard.readText) {
						const t = await navigator.clipboard.readText();
						const text = String(t || '').trim();
						if (text) {
							if (text.indexOf('WB1001_CLIP:') === 0) {
								const json = text.substring('WB1001_CLIP:'.length);
								this.pasteElementsFromPayload(JSON.parse(json));
								return;
							}
							if (text.indexOf('data:image/') === 0) {
								this.addImageFromDataUrl(text);
								return;
							}
							this.pastePlainText(text);
							return;
						}
					}
				} catch (e) {}
				this.showToast('붙여넣기 실패(권한)');
			},

			getPasteAnchorCanvas() {
				// Prefer last known pointer on canvas; fallback to viewport center.
				if (this.lastPointer && typeof this.lastPointer.x === 'number' && typeof this.lastPointer.y === 'number') {
					return { x: this.lastPointer.x, y: this.lastPointer.y };
				}
				return this.getViewportCenterCanvas();
			},

			pastePlainText(text) {
				const raw = String(text || '');
				if (!raw.trim()) return;
				const anchor = this.getPasteAnchorCanvas();
				const lines = raw.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
				const baseSize = (typeof this.properties.fontSize === 'number') ? this.properties.fontSize : 14;
				const lineGap = 4;
				let y = anchor.y;
				let created = 0;
				for (const line of lines) {
					const s = String(line);
					if (!s && lines.length > 1) { y += baseSize + lineGap; continue; }
					this.createElement('text', anchor.x, y, anchor.x, y, {
						text: s,
						fontSize: baseSize
					});
					created++;
					y += baseSize + lineGap;
				}
				if (created) {
					this.saveState();
					this.render();
					this.syncInfoPanelFromSelection();
					this.markDirty();
					this.setTool('select');
					this.showToast('텍스트 붙여넣기');
				}
			},

			tryPasteFromClipboardText(armedAt) {
				if (!this.canEdit) return;
				if (this.pasteArmedAt !== armedAt) return;
				if (!navigator.clipboard || !navigator.clipboard.readText) return;
				navigator.clipboard.readText()
					.then((t) => {
						if (this.pasteArmedAt !== armedAt) return;
						const text = String(t || '');
						if (!text.trim()) return;
						// don't steal internal element clipboard or image data urls
						if (text.indexOf('WB1001_CLIP:') === 0) return;
						if (text.indexOf('data:image/') === 0) return;
						this.pastePlainText(text);
					})
					.catch(() => {})
					.finally(() => {
						if (this.pasteArmedAt === armedAt) this.pasteArmedAt = 0;
					});
			},

			loadUiState() {
				try {
					const raw = localStorage.getItem('wb1001_ui');
					if (!raw) return;
					const obj = JSON.parse(raw);
					this.propertiesCollapsed = !!(obj && obj.propertiesCollapsed);
					this.applyPropertiesPanelState();
				} catch (e) {}
			},

			saveUiState() {
				try {
					localStorage.setItem('wb1001_ui', JSON.stringify({
						propertiesCollapsed: !!this.propertiesCollapsed
					}));
				} catch (e) {}
			},

			applyPropertiesPanelState() {
				const $root = $('#wb1001m01-editor');
				if (!$root.length) return;
				$root.toggleClass('properties-collapsed', !!this.propertiesCollapsed);
				$('[data-action="toggle-properties"]').text(this.propertiesCollapsed ? '속성 보임' : '속성 숨김');
			},

			togglePropertiesPanel() {
				this.propertiesCollapsed = !this.propertiesCollapsed;
				this.applyPropertiesPanelState();
				this.saveUiState();
				this.render();
			},

			getJwtUserId() {
				const jwtObj = window.jwt || null;
				if (!jwtObj) return '';
				// support common variants
				return String(jwtObj.userid || jwtObj.userId || jwtObj.user_id || '').trim();
			},

			isEditUser() {
				const uid = this.getJwtUserId();
				if (!uid) return false;
				return Array.isArray(this.editUserIds) && this.editUserIds.indexOf(uid) >= 0;
			},

			assertCanEdit(actionName) {
				if (this.canEdit) return true;
				this.showToast('조회만 가능합니다.');
				return false;
			},

			isTypingTargetFocused() {
				const ae = $(':focus')[0] || null;
				if (!ae) return false;
				const t = String(ae.tagName || '').toUpperCase();
				return t === 'INPUT' || t === 'TEXTAREA';
			},

			applyPermissions() {
				const $root = $('#wb1001m01-editor');
				if (!$root.length) return;
				const lock = !this.canEdit;
				$('.requires-edit').each(function() {
					const $el = $(this);
					$el.attr('aria-disabled', lock ? 'true' : null);
					$el.css('pointer-events', lock ? 'none' : '');
					$el.css('opacity', '');
					$el.css('filter', '');
				});
				$('#strokeColor,#fillColor,#fillTransparent,#strokeWidth').prop('disabled', lock);
				$('#strokePalette,#fillPalette').css('pointer-events', lock ? 'none' : '').css('opacity', lock ? '0.45' : '');
			},

			setupContextMenu() {
				this.contextMenu = $('#wb1001_context_menu')[0];
				if (!this.contextMenu) return;
				$(document).off('mousedown.wb1001menu').on('mousedown.wb1001menu', (e) => {
					if (!this.contextMenu) return;
					if (this.contextMenu.style.display !== 'none') {
						if ($(e.target).closest('#wb1001_context_menu').length === 0) {
							this.hideContextMenu();
						}
					}
				});
				$(window).off('scroll.wb1001menu').on('scroll.wb1001menu', () => this.hideContextMenu());
			},

			getSelection() {
				return Array.isArray(this.selectedElements) ? this.selectedElements.filter(Boolean) : [];
			},

			isSelected(el) {
				return !!el && this.getSelection().some(x => x && x.id === el.id);
			},

			clearSelection() {
				this.selectedElements = [];
				this.selectedElement = null;
				this.updateSelectedInfo();
				this.syncInfoPanelFromSelection();
				this.render();
			},

			setSingleSelection(el) {
				this.selectedElements = el ? [el] : [];
				this.selectedElement = el || null;
				this.updateSelectedInfo();
				if (el) this.syncPropertiesPanelFromSelection();
				this.syncInfoPanelFromSelection();
				this.render();
			},

			toggleSelection(el) {
				if (!el) return;
				const sel = this.getSelection();
				const idx = sel.findIndex(x => x && x.id === el.id);
				if (idx >= 0) {
					sel.splice(idx, 1);
					this.selectedElements = sel;
					this.selectedElement = sel.length ? sel[sel.length - 1] : null;
				} else {
					sel.push(el);
					this.selectedElements = sel;
					this.selectedElement = el;
				}
				this.updateSelectedInfo();
				if (this.selectedElement) this.syncPropertiesPanelFromSelection();
				this.syncInfoPanelFromSelection();
				this.render();
			},

			updateSelectedInfo() {
				const $info = $('#selectedInfo');
				if (!$info.length) return;
				const sel = this.getSelection();
				if (!sel.length) {
					$info.text('No selection');
					return;
				}
				if (sel.length === 1) {
					const el = sel[0];
					$info.html(`<strong>${el.type}</strong><br>X: ${Math.round(el.x)}, Y: ${Math.round(el.y)}`);
					return;
				}
				const primary = sel[sel.length - 1];
				$info.html(`<strong>Multi</strong> (${sel.length})<br>Primary: ${primary ? primary.type : '-'}`);
			},

			syncPropertiesPanelFromSelection() {
				const sel = this.getSelection();
				if (!sel.length) return;
				const primary = sel[sel.length - 1];
				if (!primary) return;
				// reflect primary element's style into the properties panel
				this.properties.strokeColor = primary.strokeColor || this.properties.strokeColor;
				this.properties.strokeWidth = (typeof primary.strokeWidth === 'number') ? primary.strokeWidth : this.properties.strokeWidth;
				if (primary.type !== 'pen' && primary.type !== 'arrow') {
					if (primary.fillColor) this.properties.fillColor = primary.fillColor;
					const a = (typeof primary.fillAlpha === 'number') ? primary.fillAlpha : 1;
					this.properties.fillTransparent = a < 1;
				}
				this.applyPropertiesInputs();
			},

			syncInfoPanelFromSelection() {
				const setText = (id, v) => $('#' + id).text(v);
				$('#elementCount').text(String((this.elements && this.elements.length) ? this.elements.length : 0));
				const sel = this.getSelection();
				const primary = sel.length ? sel[sel.length - 1] : null;
				if (primary && primary.type === 'equipmentNode') {
					setText('wb1001_meta_eqpNm', primary.eqpNm || '-');
					setText('wb1001_meta_salesCd', primary.salesCd || '-');
					setText('wb1001_meta_schedule', primary.scheduleStatus || '-');
					setText('wb1001_meta_issues', (typeof primary.issueCount === 'number') ? String(primary.issueCount) : String(parseInt(primary.issueCount || 0, 10) || 0));
				} else {
					// clear info when selection is not equipmentNode
					setText('wb1001_meta_eqpNm', '-');
					setText('wb1001_meta_salesCd', '-');
					setText('wb1001_meta_schedule', '-');
					setText('wb1001_meta_issues', '-');
				}
				$('#wb1001_last_sync').text(this.meta.lastSyncAt ? `Last: ${this.meta.lastSyncAt}` : '');
			},

			applyPropertiesInputs() {
				$('#strokeColor').val(this.properties.strokeColor);
				$('#fillColor').val(this.properties.fillColor);
				$('#fillTransparent').prop('checked', !!this.properties.fillTransparent);
				$('#strokeWidth').val(String(this.properties.strokeWidth));
				$('#strokeWidthValue').text(String(this.properties.strokeWidth) + 'px');
			},

			hideContextMenu() {
				if (!this.contextMenu) return;
				this.contextMenu.style.display = 'none';
			},

			showContextMenu(screenX, screenY, target, hitInfo) {
				if (!this.contextMenu) return;
				this.contextMenuHit = hitInfo || { x: 0, y: 0 };
				const $titleEl = $('#wb1001_context_menu_title');
				const $itemsEl = $('#wb1001_context_menu_items');
				if (!$itemsEl.length) return;
				if ($titleEl.length) {
					const t = target ? `${target.type}${target.type === 'equipmentNode' ? ` (${target.salesCd || '-'})` : ''}` : 'Canvas';
					$titleEl.text(t);
				}
				$itemsEl.empty();

				const addItem = (label, onClick, danger, disabled) => {
					const $btn = $('<button type="button"></button>');
					$btn.text(label);
					$btn.css({
						width: '100%',
						textAlign: 'left',
						background: 'transparent',
						border: 'none',
						color: danger ? '#fecaca' : '#e2e8f0',
						padding: '7px 10px',
						borderRadius: '6px',
						cursor: disabled ? 'not-allowed' : 'pointer',
						opacity: disabled ? 0.55 : 1,
						pointerEvents: disabled ? 'none' : 'auto'
					});
					$btn.on('mouseenter', function() { $(this).css('background', 'rgba(148,163,184,0.16)'); });
					$btn.on('mouseleave', function() { $(this).css('background', 'transparent'); });
					$btn.on('click', () => {
						this.hideContextMenu();
						try { onClick && onClick(); } catch (e) {}
					});
					$itemsEl.append($btn);
					return $btn;
				};

				const addSep = (label) => {
					const $div = $('<div></div>');
					$div.text(label);
					$div.css({
						padding: '6px 8px',
						marginTop: '6px',
						color: '#94a3b8',
						fontSize: '10px',
						borderTop: '1px solid rgba(148,163,184,0.18)'
					});
					$itemsEl.append($div);
				};

				const sel = this.getSelection();
				const multi = sel.length > 1;

				let $pasteBtn = null;
				const addPasteAction = () => {
					if (!this.canEdit) return;
					addSep('클립보드');
					const hasInternal = !!this.copyBuffer;
					$pasteBtn = addItem('붙여넣기', () => this.pasteFromMenu(), false, !hasInternal);
					if (!hasInternal) {
						this.checkClipboardHasData().then((has) => {
							if (!has || !$pasteBtn) return;
							$pasteBtn.css({ opacity: 1, pointerEvents: 'auto', cursor: 'pointer' });
						}).catch(() => {});
					}
				};
				const addTopActions = () => {
					addSep('작업');
					addItem('Export', () => this.exportJSON());
					addItem('Load', () => this.loadFromServer());
					if (this.canEdit) {
						addItem('Undo', () => this.undo());
						addItem('Redo', () => this.redo());
						addItem('Import', () => $('#fileInput').trigger('click'));
						addItem('Save', () => this.saveToServer());
						addItem('Clear', () => this.clearCanvas(), true);
					}
				};
				// view-only: show only safe items (no edit operations)
				if (!this.canEdit) {
					$itemsEl.empty();
					if ($titleEl.length) {
						$titleEl.text(target ? `${target.type}${target.type === 'equipmentNode' ? ` (${target.salesCd || '-'})` : ''}` : 'Canvas');
					}
					addTopActions();
					// allow overlap cycling (selection aid)
					addItem('겹침 선택(다음)', () => {
						this.selectNextUnderCursor(this.contextMenuHit.x, this.contextMenuHit.y);
					});
					// allow refresh only for equipment nodes
					if (target && target.type === 'equipmentNode') {
						addItem('이 노드 재조회', () => {
							this.refreshSalesStatus();
						});
					}
					// if no meaningful action, don't show menu
					const hasItems = $itemsEl.children().length > 0;
					if (!hasItems || (!target && $itemsEl.children().length <= 1)) {
						this.hideContextMenu();
						return;
					}
					this.contextMenu.style.left = Math.round(screenX) + 'px';
					this.contextMenu.style.top = Math.round(screenY) + 'px';
					this.contextMenu.style.display = 'block';
					return;
				}

				addTopActions();
				addPasteAction();

				if (target) {
					addItem('겹침 선택(다음)', () => {
						this.selectNextUnderCursor(this.contextMenuHit.x, this.contextMenuHit.y);
					});
					if (target.type === 'equipmentNode') {
						addItem('이 노드 재조회', () => {
							this.refreshSalesStatus();
						});
					}
					if (this.canEdit) {
						addItem(multi ? '선택 삭제' : '삭제', () => {
							this.deleteSelected();
						}, true);
						addItem(multi ? '선택 복제' : '복제', () => {
							this.duplicateSelected();
						});
						addItem('앞으로 가져오기', () => {
							this.bringToFront(target);
						});
						addItem('뒤로 보내기', () => {
							this.sendToBack(target);
						});
						if (target.type === 'equipmentNode') {
							addItem('설비 변경', () => {
								this.openEquipmentPickerWithOptions({
									searchValue: target.salesCd || this.meta.salesCd || '',
									onSelected: (picked) => {
										const salesCd = String(picked && picked.salesCd || '').trim();
										if (!salesCd) return;
										target.salesCd = salesCd;
										target.eqpNm = String(picked.eqpNm || '').trim();
										this.saveState();
										this.refreshSalesStatus();
									}
								});
							});
						}
					}
				} else {
					addItem('겹침 선택(다음)', () => {
						this.selectNextUnderCursor(this.contextMenuHit.x, this.contextMenuHit.y);
					});
				}

				if (multi) {
					addSep('정렬/맞춤 (기준: 마지막 선택)');
					addItem('같은 너비', () => this.matchSelectionSize('width'));
					addItem('같은 높이', () => this.matchSelectionSize('height'));
					addItem('위쪽 맞춤', () => this.alignSelection('top'));
					addItem('가운데 맞춤(세로)', () => this.alignSelection('vcenter'));
					addItem('아래쪽 맞춤', () => this.alignSelection('bottom'));
					addItem('왼쪽 맞춤', () => this.alignSelection('left'));
					addItem('가운데 맞춤(가로)', () => this.alignSelection('hcenter'));
					addItem('오른쪽 맞춤', () => this.alignSelection('right'));
				}

				this.contextMenu.style.left = Math.round(screenX) + 'px';
				this.contextMenu.style.top = Math.round(screenY) + 'px';
				this.contextMenu.style.display = 'block';
			},

			duplicateSelected() {
				if (!this.assertCanEdit('duplicate')) return;
				const sel = this.getSelection();
				if (!sel.length) return;
				const copies = [];
				for (const src of sel) {
					const copy = JSON.parse(JSON.stringify(src));
					copy.id = Date.now() + Math.random();
					if (copy.type === 'pen' && Array.isArray(copy.points)) {
						for (const p of copy.points) { p.x += 20; p.y += 20; }
					} else {
						copy.x += 20; copy.y += 20;
						if (typeof copy.x2 === 'number') copy.x2 += 20;
						if (typeof copy.y2 === 'number') copy.y2 += 20;
					}
					this.elements.push(copy);
					copies.push(copy);
				}
				this.selectedElements = copies;
				this.selectedElement = copies[copies.length - 1] || null;
				this.updateSelectedInfo();
				this.saveState();
				this.render();
				this.syncInfoPanelFromSelection();
				this.markDirty();
			},

			bringToFront(el) {
				if (!this.assertCanEdit('zorder')) return;
				const idx = this.elements.indexOf(el);
				if (idx < 0) return;
				this.elements.splice(idx, 1);
				this.elements.push(el);
				this.setSingleSelection(el);
				this.saveState();
				this.render();
				this.markDirty();
			},

			sendToBack(el) {
				if (!this.assertCanEdit('zorder')) return;
				const idx = this.elements.indexOf(el);
				if (idx < 0) return;
				this.elements.splice(idx, 1);
				this.elements.unshift(el);
				this.setSingleSelection(el);
				this.saveState();
				this.render();
				this.markDirty();
			},

				hitTestAll(x, y) {
					const hits = [];
					for (let i = this.elements.length - 1; i >= 0; i--) {
						const el = this.elements[i];
						if (!el) continue;
					if (el.type === 'pen') {
						if (el.points) {
							for (const point of el.points) {
								const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
								if (dist < 10) { hits.push(el); break; }
							}
						}
					} else if (el.type === 'text') {
						const fontSize = (typeof el.fontSize === 'number') ? el.fontSize : 14;
						const isBold = (el.strokeWidth || 1) >= 3;
						const scaleX = (typeof el.textScaleX === 'number') ? el.textScaleX : 1;
						this.ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px sans-serif`;
						const metrics = this.ctx.measureText(el.text || '');
							const width = metrics.width * scaleX;
							const height = fontSize;
							if (x >= el.x && x <= el.x + width && y >= el.y - height && y <= el.y) hits.push(el);
						} else if (el.type === 'arrow') {
						// distance from point to segment (tolerant selection)
						const x1 = el.x, y1 = el.y, x2 = el.x2, y2 = el.y2;
						const dx = x2 - x1;
						const dy = y2 - y1;
						const len2 = dx * dx + dy * dy;
						let t = 0;
						if (len2 > 0) t = ((x - x1) * dx + (y - y1) * dy) / len2;
						t = Math.max(0, Math.min(1, t));
						const px = x1 + t * dx;
						const py = y1 + t * dy;
						const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
						const tol = 6 + (el.strokeWidth || 1);
						if (dist <= tol) hits.push(el);
					} else if (el.type === 'image') {
						const minX = Math.min(el.x, el.x2);
						const maxX = Math.max(el.x, el.x2);
						const minY = Math.min(el.y, el.y2);
						const maxY = Math.max(el.y, el.y2);
						if (x >= minX && x <= maxX && y >= minY && y <= maxY) hits.push(el);
					} else {
						const minX = Math.min(el.x, el.x2);
						const maxX = Math.max(el.x, el.x2);
						const minY = Math.min(el.y, el.y2);
						const maxY = Math.max(el.y, el.y2);
						if (x >= minX && x <= maxX && y >= minY && y <= maxY) hits.push(el);
					}
				}
				return hits;
			},

			selectNextUnderCursor(x, y) {
				const now = Date.now();
				const hits = this.hitTestAll(x, y);
				if (!hits.length) return;
				const tol = 6;
				const within = Math.abs(x - this._lastHit.x) <= tol && Math.abs(y - this._lastHit.y) <= tol && (now - this._lastHit.ts) <= 1000;
				let idx = 0;
				if (within) {
					idx = (this._lastHit.idx + 1) % hits.length;
				}
				this._lastHit = { x, y, ts: now, idx, stackIds: hits.map(h => h.id) };
				this.setSingleSelection(hits[idx]);
			},

			bindRefreshCheckbox() {
				const $el = $('#wb1001_refresh');
				if (!$el.length) return;
				$el.prop('checked', !!this.autoRefresh);
				$el.off('change.wb1001').on('change.wb1001', () => {
					this.setAutoRefresh(!!$el.prop('checked'));
				});
			},

			setAutoRefresh(enabled) {
				this.autoRefresh = !!enabled;
				if (this.autoRefreshTimer) {
					clearInterval(this.autoRefreshTimer);
					this.autoRefreshTimer = null;
				}
				if (this.autoRefresh) {
					this.refreshSalesStatus(true);
					this.autoRefreshTimer = setInterval(() => this.refreshSalesStatus(true), 60000);
					this.showToast('Refresh ON (1분)');
				} else {
					this.showToast('Refresh OFF');
				}
				this.saveToLocalStorage();
			},

			refreshSalesStatus(silent) {
				// Backend integration pending. Keep refresh safe and non-dirty.
				const iso = new Date().toISOString();
				const ts = iso.replace('T', ' ').substring(0, 19);
				this.meta.lastSyncAt = ts;
				for (const el of this.elements || []) {
					if (!el || el.type !== 'equipmentNode') continue;
					el.lastSyncAt = ts;
					if (!String(el.scheduleStatus || '').trim() && String(this.meta.scheduleStatus || '').trim()) {
						el.scheduleStatus = this.meta.scheduleStatus;
					}
					if (typeof el.issueCount !== 'number') {
						const n = parseInt(el.issueCount || 0, 10);
						el.issueCount = isNaN(n) ? 0 : n;
					}
				}
				this.syncInfoPanelFromSelection();
				this.render();
				if (!silent) this.showToast('재조회(Stub)');
			},

			getCoCd() {
				const jwtObj = window.jwt || null;
				if (jwtObj && jwtObj.coCd) return jwtObj.coCd;
				return 'GUN';
			},

			parseDateLike(v) {
				const s = String(v || '').trim();
				if (!s) return null;
				if (/^\d{8}$/.test(s)) {
					const norm = `${s.substr(0, 4)}-${s.substr(4, 2)}-${s.substr(6, 2)}`;
					const d = new Date(norm);
					return isNaN(d.getTime()) ? null : d;
				}
				if (/^\d{4}[-\.]\d{2}[-\.]\d{2}$/.test(s)) {
					const d = new Date(s.replace(/\./g, '-'));
					return isNaN(d.getTime()) ? null : d;
				}
				const d = new Date(s);
				return isNaN(d.getTime()) ? null : d;
			},

			postAjaxPromise(url, data) {
				return new Promise((resolve, reject) => {
					try {
						if (typeof postAjax === 'function') {
							postAjax(url, data, null, function(res){
								resolve(res);
							});
							return;
						}
					} catch (e) {
						reject(e);
						return;
					}
					fetch(url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(data || {})
					}).then(r => r.json()).then(resolve).catch(reject);
				});
			},

			openEquipmentPicker() {
				if (!this.assertCanEdit('equipment')) return;
				return this.openEquipmentPickerWithOptions(null);
			},

			openEquipmentPickerWithOptions(options) {
				if (!this.assertCanEdit('equipment')) return;
				const coCd = this.getCoCd();
					const opt = options || {};
					const paramObj = { coCd: coCd, searchValue: (opt.searchValue || '') };
					if (typeof openSecondModal !== 'function') {
						this.showToast('설비 선택 모달을 열 수 없습니다.');
						return;
					}
					openSecondModal('/static/html/cmn/modal/wbsSalesCodeSearch.html', 1200, 700, 'SALES CODE 검색', paramObj, (grid) => {
						const row = grid && grid.target && typeof grid.target.getList === 'function'
							? (grid.target.getList('selected')[0] || null)
							: null;
						if (!row) return;
						const picked = {
							salesCd: row.salesCd || '',
							eqpNm: row.eqpNm || row.eqp || ''
						};
						if (typeof opt.onSelected === 'function') {
							opt.onSelected(picked, row);
							return;
						}
						this.setSalesContext(picked);
					});
				},

			setSalesContext({ salesCd, eqpNm, ensureSummaryNode }) {
				if (!this.assertCanEdit('salesContext')) return;
				this.meta.salesCd = String(salesCd || '').trim();
				this.meta.eqpNm = String(eqpNm || '').trim();
					this.syncInfoPanelFromSelection();
					this.saveToLocalStorage();
					this.markDirty();
					if (ensureSummaryNode !== false) {
						this.ensureEquipmentSummaryNode(this.meta.salesCd, this.meta.eqpNm);
					}
					this.refreshSalesStatus();
				},

			ensureEquipmentSummaryNode(salesCd, eqpNm) {
				const s = String(salesCd || '').trim();
				if (!s) return;
				const existing = this.elements.find(el => el && el.type === 'equipmentNode' && el.summary === true && String(el.salesCd || '').trim() === s);
				if (existing) {
					existing.eqpNm = String(eqpNm || existing.eqpNm || '').trim();
					this.render();
					this.markDirty();
					return;
				}
				const center = this.getViewportCenterCanvas();
				const x = Math.max(10, Math.round(center.x - 140));
				const y = Math.max(10, Math.round(center.y - 55));
				this.createEquipmentNodeAt(x, y, {
					salesCd: s,
					eqpNm: String(eqpNm || '').trim(),
					scheduleStatus: this.meta.scheduleStatus,
					issueCount: this.meta.issueCount,
					lastSyncAt: this.meta.lastSyncAt,
					summary: true
				});
				this.saveState();
			},

			getViewportCenterCanvas() {
				const container = $('#canvasContainer')[0];
				if (!container) return { x: 100, y: 100 };
				// screen = canvas * zoom + pan (pan is translate after scale in current transform order)
				const x = (container.clientWidth / 2 - this.panX) / this.zoom;
				const y = (container.clientHeight / 2 - this.panY) / this.zoom;
				return { x, y };
			},

				createEquipmentNodeAt(x, y, data) {
					const w = 280;
					const h = 110;
					const node = this.createElement('equipmentNode', x, y, x + w, y + h, {
						salesCd: String((data && data.salesCd) || '').trim(),
						eqpNm: String((data && data.eqpNm) || '').trim(),
						scheduleStatus: String((data && data.scheduleStatus) || '').trim(),
						issueCount: (data && typeof data.issueCount === 'number') ? data.issueCount : parseInt(data && data.issueCount, 10) || 0,
						lastSyncAt: String((data && data.lastSyncAt) || '').trim(),
						summary: !!(data && data.summary),
						fillColor: '#ffffff',
						strokeColor: '#2563eb',
						strokeWidth: 2
					});
				this.setSingleSelection(node);
				this.render();
				this.syncInfoPanelFromSelection();
				return node;
			},

			collectSalesCdsForRefresh() {
				const set = new Set();
				for (const el of this.elements) {
					if (!el || el.type !== 'equipmentNode') continue;
					const cd = String(el.salesCd || '').trim();
					if (cd) set.add(cd);
				}
				const metaCd = String(this.meta.salesCd || '').trim();
				if (metaCd) set.add(metaCd);
				return Array.from(set);
			},

			async refreshSalesStatus() {
				const salesCds = this.collectSalesCdsForRefresh();
				if (!salesCds.length) return;
				try {
					const [schRes, issRes] = await Promise.all([
						this.postAjaxPromise('/user/wb/wb26/select_wb06_List', { salesCds: salesCds }),
						this.postAjaxPromise('/user/wb/wb24/selectWbsIssueCountBySalesCds', { coCd: this.getCoCd(), salesCds: salesCds })
					]);

					const scheduleRows = (schRes && Array.isArray(schRes.result)) ? schRes.result : [];
					const issueList = (issRes && Array.isArray(issRes.result)) ? issRes.result : [];

					const scheduleMap = {};
					for (const r of scheduleRows) {
						const cd = String((r && r.salesCd) || '').trim();
						if (!cd) continue;
						if (!scheduleMap[cd]) scheduleMap[cd] = [];
						scheduleMap[cd].push(r);
					}
					const scheduleStatusByCd = {};
					for (const cd of Object.keys(scheduleMap)) {
						scheduleStatusByCd[cd] = this.computeScheduleStatus(scheduleMap[cd]);
					}

					const issueCountByCd = {};
					for (const it of issueList) {
						const cd = String((it && it.salesCd) || '').trim();
						if (!cd) continue;
						const cnt = parseInt((it && (it.cnt ?? it.count ?? it.issueCount)) || 0, 10);
						issueCountByCd[cd] = isNaN(cnt) ? 0 : cnt;
					}

					const nowStr = new Date().toLocaleString('ko-KR');
					let changed = false;
					for (const el of this.elements) {
						if (!el || el.type !== 'equipmentNode') continue;
						const cd = String(el.salesCd || '').trim();
						if (!cd) continue;
						el.scheduleStatus = scheduleStatusByCd[cd] || '없음';
						el.issueCount = (typeof issueCountByCd[cd] === 'number') ? issueCountByCd[cd] : 0;
						el.lastSyncAt = nowStr;
						changed = true;
					}

					const metaCd = String(this.meta.salesCd || '').trim();
					if (metaCd) {
						this.meta.scheduleStatus = scheduleStatusByCd[metaCd] || '없음';
						this.meta.issueCount = (typeof issueCountByCd[metaCd] === 'number') ? issueCountByCd[metaCd] : 0;
						this.meta.lastSyncAt = nowStr;
						this.syncInfoPanelFromSelection();
					}
					if (changed) this.render();
					this.saveToLocalStorage();
				} catch (e) {
					this.showToast('상태 조회 실패');
				}
			},

			computeScheduleStatus(rows) {
				if (!rows || !rows.length) return '없음';
				const today = new Date();
				today.setHours(0, 0, 0, 0);
				let anyClosed = false;
				let allClosed = true;
				let anyDelayed = false;
				for (const r of rows) {
					const wbsCloseYn = String(r.wbsCloseYn || '').toUpperCase();
					const closeYn = String(r.closeYn || '').toUpperCase();
					const isClosed = (wbsCloseYn === 'Y' || closeYn === 'Y');
					if (isClosed) anyClosed = true;
					if (!isClosed) allClosed = false;
					const endStr = String(r.wbsPlaneDtFm || r.wbsPlaneDt || '').trim();
					const d = this.parseDateLike(endStr);
					if (d) {
						d.setHours(0, 0, 0, 0);
						if (d < today && !isClosed) anyDelayed = true;
					}
				}
				if (allClosed) return '완료';
				if (anyDelayed) return '지연';
				if (anyClosed) return '확정';
				return '진행';
			},

			setupCanvas() {
				const container = $('#canvasContainer')[0];
				if (!container) return;
				this.canvas.width = 2000;
				this.canvas.height = 1500;
				const containerRect = container.getBoundingClientRect();
				this.panX = (containerRect.width - this.canvas.width) / 2;
				this.panY = (containerRect.height - this.canvas.height) / 2;
				this.updateTransform();
			},

			updateTransform() {
				$('#canvasWrapper').css('transform', `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`);
				$('#zoomLevel').text(Math.round(this.zoom * 100) + '%');
			},

			setupEventListeners() {
				const self = this;

				$('.editor-toolbar-btn[data-tool]').off('click.wb1001').on('click.wb1001', function() {
					self.setTool($(this).data('tool'));
				});

				$('#strokeColor').off('input.wb1001').on('input.wb1001', function() {
					self.properties.strokeColor = this.value;
					self.updateSelectedProperties();
				});
				$('#fillColor').off('input.wb1001').on('input.wb1001', function() {
					self.properties.fillColor = this.value;
					self.updateSelectedProperties();
				});
				$('#fillTransparent').off('change.wb1001').on('change.wb1001', function() {
					self.properties.fillTransparent = !!$(this).prop('checked');
					self.updateSelectedProperties();
				});
				$('#strokeWidth').off('input.wb1001').on('input.wb1001', function() {
					self.properties.strokeWidth = parseInt(this.value, 10);
					$('#strokeWidthValue').text(this.value + 'px');
					self.updateSelectedProperties();
				});

				$('#strokePalette .editor-color-swatch').off('click.wb1001').on('click.wb1001', function() {
					self.properties.strokeColor = $(this).data('color');
					$('#strokeColor').val(self.properties.strokeColor);
					self.updateSelectedProperties();
				});
				$('#fillPalette .editor-color-swatch').off('click.wb1001').on('click.wb1001', function() {
					self.properties.fillColor = $(this).data('color');
					$('#fillColor').val(self.properties.fillColor);
					self.updateSelectedProperties();
				});

				const $canvas = $(this.canvas);
				$canvas.off('.wb1001');
				$canvas.on('mousedown.wb1001', function(e) { self.handleMouseDown(e.originalEvent || e); });
				$canvas.on('mousemove.wb1001', function(e) { self.handleMouseMove(e.originalEvent || e); });
				$canvas.on('mouseup.wb1001', function(e) { self.handleMouseUp(e.originalEvent || e); });
				$canvas.on('mouseleave.wb1001', function(e) { self.handleMouseUp(e.originalEvent || e); });
				$canvas.on('wheel.wb1001', function(e) { self.handleWheel(e.originalEvent || e); });
				$canvas.on('dblclick.wb1001', function(e) { self.handleDoubleClick(e.originalEvent || e); });
				$canvas.on('contextmenu.wb1001', function(e) {
					const ev = e.originalEvent || e;
					ev.preventDefault();
					const pos = self.getMousePos(ev);
					const hits = self.hitTestAll(pos.x, pos.y);
					const target = hits.length ? hits[0] : null;
					if (!self.canEdit && !target) return;
					if (target) {
						if (!self.isSelected(target) || self.getSelection().length <= 1) {
							self.setSingleSelection(target);
						} else {
							const sel = self.getSelection().filter(x => x && x.id !== target.id);
							sel.push(target);
							self.selectedElements = sel;
							self.selectedElement = target;
							self.updateSelectedInfo();
							self.render();
						}
					}
					self.showContextMenu(ev.clientX, ev.clientY, target, { x: pos.x, y: pos.y });
				});

				$canvas.on('touchstart.wb1001', function(e) { self.handleTouchStart(e.originalEvent || e); });
				$canvas.on('touchmove.wb1001', function(e) { self.handleTouchMove(e.originalEvent || e); });
				$canvas.on('touchend.wb1001', function(e) { self.handleTouchEnd(e.originalEvent || e); });

				$(document).off('keydown.wb1001').on('keydown.wb1001', function(e) { self.handleKeyDown(e.originalEvent || e); });
				$(document).off('keyup.wb1001').on('keyup.wb1001', function(e) { self.handleKeyUp(e.originalEvent || e); });
				$(document).off('paste.wb1001').on('paste.wb1001', function(e) { self.handlePaste(e.originalEvent || e); });
				$(window).off('resize.wb1001').on('resize.wb1001', function(e) { self.handleWindowResize(e.originalEvent || e); });
			},

			handlePaste(e) {
				if (!this.canEdit) return;
				// Support paste image from clipboard
				if (this.isTypingTargetFocused()) return;
				this.pasteArmedAt = 0;
				const cd = e.clipboardData;
				if (!cd || !cd.items) return;
				let handled = false;
				// 1) Prefer file images
				for (const item of cd.items) {
					if (!item || item.kind !== 'file') continue;
					if (!item.type || item.type.indexOf('image/') !== 0) continue;
					const file = item.getAsFile();
					if (!file) continue;
					e.preventDefault();
					const reader = new FileReader();
					reader.onload = () => {
						const dataUrl = String(reader.result || '');
						if (dataUrl) this.addImageFromDataUrl(dataUrl);
					};
					reader.readAsDataURL(file);
					handled = true;
					this.internalPasteArmed = false;
					return;
				}

				// 1.5) Try our own element clipboard format
				try {
					const text = String(cd.getData('text/plain') || '').trim();
					if (text.indexOf('WB1001_CLIP:') === 0) {
						e.preventDefault();
						const json = text.substring('WB1001_CLIP:'.length);
						const payload = JSON.parse(json);
						this.pasteElementsFromPayload(payload);
						handled = true;
						this.internalPasteArmed = false;
						return;
					}
				} catch (err) {}

				// 2) Try HTML clipboard (often used by browsers / web apps)
				try {
					const html = cd.getData('text/html');
					const m = String(html || '').match(/<img[^>]+src=["']([^"']+)["']/i);
					const src = m ? String(m[1] || '') : '';
					if (src) {
						e.preventDefault();
						if (src.indexOf('data:image/') === 0) {
							this.addImageFromDataUrl(src);
							handled = true;
							this.internalPasteArmed = false;
							return;
						}
						// remote url -> fetch -> dataURL
						if (src.indexOf('http://') === 0 || src.indexOf('https://') === 0) {
							fetch(src)
								.then(r => r.blob())
								.then(b => new Promise((resolve) => {
									try {
										const reader = new FileReader();
										reader.onload = () => resolve(String(reader.result || ''));
										reader.onerror = () => resolve('');
										reader.readAsDataURL(b);
									} catch (e) {
										resolve('');
									}
								}))
								.then((dataUrl) => { if (dataUrl) this.addImageFromDataUrl(dataUrl); })
								.catch(() => this.showToast('이미지 붙여넣기 실패(외부 URL)'));
							handled = true;
							this.internalPasteArmed = false;
							return;
						}
					}
				} catch (err) {}

				// 3) Try plain text data URL
				try {
					const text = String(cd.getData('text/plain') || '').trim();
					if (text.indexOf('data:image/') === 0) {
						e.preventDefault();
						this.addImageFromDataUrl(text);
						handled = true;
						this.internalPasteArmed = false;
						return;
					}
					// 3.5) Plain text -> paste as text elements
					if (text && text.indexOf('WB1001_CLIP:') !== 0) {
						e.preventDefault();
						this.pastePlainText(text);
						handled = true;
						this.internalPasteArmed = false;
						return;
					}
				} catch (err) {}

				// 4) Internal fallback (when clipboard write is blocked)
				if (!handled && this.internalPasteArmed && this.copyBuffer) {
					e.preventDefault();
					this.pasteElementsFromPayload(this.copyBuffer);
					this.internalPasteArmed = false;
				}
			},

			copySelectionToClipboard() {
				const sel = this.getSelection();
				if (!sel.length) return;
				const payload = {
					type: 'WB1001_CLIP',
					version: 1,
					elements: JSON.parse(JSON.stringify(sel))
				};
				this.copyBuffer = payload;
				const text = 'WB1001_CLIP:' + JSON.stringify(payload);
				if (navigator.clipboard && navigator.clipboard.writeText) {
					navigator.clipboard.writeText(text)
						.then(() => this.showToast('복사됨'))
						.catch(() => this.showToast('복사됨(내부)'));
				} else {
					this.showToast('복사됨(내부)');
				}
			},

			pasteElementsFromPayload(payload) {
				if (!payload || payload.type !== 'WB1001_CLIP' || !Array.isArray(payload.elements) || !payload.elements.length) return;
				const src = payload.elements;
				// compute bounds
				let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
				for (const el of src) {
					const b = this.getElementBounds(el);
					minX = Math.min(minX, b.minX); minY = Math.min(minY, b.minY);
					maxX = Math.max(maxX, b.maxX); maxY = Math.max(maxY, b.maxY);
				}
				if (!isFinite(minX)) return;
				const center = this.getViewportCenterCanvas();
				const cx = (minX + maxX) / 2;
				const cy = (minY + maxY) / 2;
				const dx = Math.round(center.x - cx + 20);
				const dy = Math.round(center.y - cy + 20);
				const copies = [];
				for (const el of src) {
					const copy = JSON.parse(JSON.stringify(el));
					copy.id = Date.now() + Math.random();
					this.moveElementBy(copy, dx, dy);
					this.elements.push(copy);
					// ensure image cache preloads
					if (copy.type === 'image' && copy.src) {
						const img = new Image();
						img.onload = () => this.render();
						img.src = copy.src;
						this.imageCache[copy.id] = img;
					}
					copies.push(copy);
				}
				this.selectedElements = copies;
				this.selectedElement = copies[copies.length - 1] || null;
				this.updateSelectedInfo();
				this.saveState();
				this.render();
				this.syncInfoPanelFromSelection();
				this.showToast('붙여넣기');
				this.markDirty();
			},

			addImageFromDataUrl(dataUrl) {
				const img = new Image();
				img.onload = () => {
					const center = this.getViewportCenterCanvas();
					let w = img.naturalWidth || 400;
					let h = img.naturalHeight || 300;
					const maxW = 600;
					if (w > maxW) {
						const s = maxW / w;
						w = Math.round(w * s);
						h = Math.round(h * s);
					}
					const x = Math.round(center.x - w / 2);
					const y = Math.round(center.y - h / 2);
					const el = this.createElement('image', x, y, x + w, y + h, { src: dataUrl });
					this.imageCache[el.id] = img;
					this.saveState();
					this.render();
					this.markDirty();
					this.showToast('이미지 붙여넣기');
				};
				img.src = dataUrl;
			},

			getMousePos(e) {
				// canvas is CSS-transformed via wrapper translate(panX, panY) scale(zoom)
				// so use the container's screen space, then invert the transform.
				const container = $('#canvasContainer')[0];
				const rect = container ? container.getBoundingClientRect() : this.canvas.getBoundingClientRect();
				const sx = e.clientX - rect.left;
				const sy = e.clientY - rect.top;
				return {
					x: (sx - this.panX) / this.zoom,
					y: (sy - this.panY) / this.zoom
				};
			},

			handleMouseDown(e) {
				this.hideContextMenu();
				this.didMutate = false;
				this.draggingSelection = false;
				const pos = this.getMousePos(e);
				this.lastPointer = { x: pos.x, y: pos.y };
				this.isDrawing = true;
				this.dragLast = { x: pos.x, y: pos.y };
				this.dragStart = { x: pos.x, y: pos.y };

				// Space + left-drag = pan
				if (this.spaceDown && e.button === 0) {
					this.isPanning = true;
					this.isDrawing = false;
					this.isMarquee = false;
					this.panStartClient = { x: e.clientX, y: e.clientY };
					this.panStartPan = { x: this.panX, y: this.panY };
					this.canvas.style.cursor = 'grabbing';
					return;
				}

				if (this.currentTool === 'select') {
					if (this.selectedElement) {
						const handle = this.getResizeHandle(pos.x, pos.y);
						if (handle) {
							if (!this.canEdit) {
								this.showToast('조회만 가능합니다.');
								this.resizeHandle = null;
								this.isDrawing = false;
								return;
							}
							this.textResizeStart = null;
							this.boxResizeStart = null;
							if (this.selectedElement.type === 'text') {
								const b = this.getElementBounds(this.selectedElement);
								this.textResizeStart = {
								x: pos.x,
								y: pos.y,
								fontSize: (typeof this.selectedElement.fontSize === 'number') ? this.selectedElement.fontSize : (this.properties.fontSize || 14),
								scaleX: (typeof this.selectedElement.textScaleX === 'number') ? this.selectedElement.textScaleX : 1,
								handle: handle,
								bounds: { minX: b.minX, minY: b.minY, maxX: b.maxX, maxY: b.maxY }
							};
								this.penResizeStart = null;
								this.didMutate = true;
							} else if (this.selectedElement.type === 'pen') {
								const b = this.getElementBounds(this.selectedElement);
								this.penResizeStart = {
									x: pos.x,
									y: pos.y,
									handle: handle,
									bounds: { minX: b.minX, minY: b.minY, maxX: b.maxX, maxY: b.maxY },
									points: (this.selectedElement.points || []).map(p => ({ x: p.x, y: p.y }))
								};
								this.textResizeStart = null;
								this.boxResizeStart = null;
								this.didMutate = true;
							} else {
								const b = this.getElementBounds(this.selectedElement);
								this.boxResizeStart = {
									handle: handle,
									bounds: { minX: b.minX, minY: b.minY, maxX: b.maxX, maxY: b.maxY }
								};
								this.textResizeStart = null;
								this.penResizeStart = null;
								this.didMutate = true;
							}
							this.resizeHandle = handle;
							return;
						}
					}

					const hits = this.hitTestAll(pos.x, pos.y);
					if (hits && hits.length) {
						const top = hits[0];
						if (e.shiftKey) {
							this.toggleSelection(top);
							this.dragLast = { x: pos.x, y: pos.y };
							this.isMarquee = false;
							return;
						}

						// cycle when repeatedly clicking same spot (only when shift not pressed)
						const now = Date.now();
						const tol = 6;
						const within = Math.abs(pos.x - this._lastHit.x) <= tol && Math.abs(pos.y - this._lastHit.y) <= tol && (now - this._lastHit.ts) <= 1000;
						let pickIdx = 0;
						if (within) pickIdx = (this._lastHit.idx + 1) % hits.length;
						this._lastHit = { x: pos.x, y: pos.y, ts: now, idx: pickIdx, stackIds: hits.map(h => h.id) };
						const element = hits[pickIdx];

						// keep existing multi-selection when clicking inside it
						if (this.getSelection().length > 1 && this.isSelected(element)) {
							const sel = this.getSelection().filter(x => x && x.id !== element.id);
							sel.push(element);
							this.selectedElements = sel;
							this.selectedElement = element;
							this.updateSelectedInfo();
							this.render();
						} else {
							this.setSingleSelection(element);
						}
						this.dragLast = { x: pos.x, y: pos.y };
						this.dragStart = { x: pos.x, y: pos.y };
						this.draggingSelection = false;
						this.isMarquee = false;
						if (!this.canEdit) {
							// allow selection but disallow move
							this.isDrawing = false;
							this.dragLast = null;
							this.dragStart = null;
						}
					} else {
						// marquee selection (drag on empty space)
						this.marqueeAdd = !!e.shiftKey;
						if (!e.shiftKey) this.clearSelection();
						this.isMarquee = true;
						this.marqueeStart = { x: pos.x, y: pos.y };
						this.marqueeEnd = { x: pos.x, y: pos.y };
						this.isDrawing = true;
					}
				} else if (this.currentTool === 'text') {
					const text = prompt('Enter text:', 'Text');
					if (text) {
						this.createElement('text', pos.x, pos.y, pos.x, pos.y, { text });
						this.saveState();
						this.setTool('select');
					}
					this.isDrawing = false;
				} else if (this.currentTool === 'equipmentNode') {
					const placeX = pos.x;
					const placeY = pos.y;
					this.isDrawing = false;
					this.openEquipmentPickerWithOptions({
						searchValue: this.meta.salesCd || '',
						onSelected: (picked) => {
							const salesCd = String(picked && picked.salesCd || '').trim();
							if (!salesCd) return;
							this.createEquipmentNodeAt(placeX, placeY, {
								salesCd: salesCd,
								eqpNm: picked.eqpNm,
								scheduleStatus: this.meta.scheduleStatus,
								issueCount: this.meta.issueCount,
								lastSyncAt: this.meta.lastSyncAt,
								summary: false
							});
							this.saveState();
							this.setSalesContext({ salesCd: salesCd, eqpNm: picked.eqpNm, ensureSummaryNode: false });
							this.setTool('select');
							this.showToast('설비 노드 생성');
						}
					});
				} else if (this.currentTool === 'pen') {
					this.createElement('pen', pos.x, pos.y, pos.x, pos.y);
				} else if (['rectangle', 'ellipse', 'arrow'].includes(this.currentTool)) {
					this.createElement(this.currentTool, pos.x, pos.y, pos.x, pos.y);
				}
			},

			handleMouseMove(e) {
				const pos = this.getMousePos(e);
				this.lastPointer = { x: pos.x, y: pos.y };

				if (this.isPanning && this.panStartClient && this.panStartPan) {
					const dx = e.clientX - this.panStartClient.x;
					const dy = e.clientY - this.panStartClient.y;
					this.panX = this.panStartPan.x + dx;
					this.panY = this.panStartPan.y + dy;
					this.updateTransform();
					return;
				}

				if (!this.isDrawing && this.currentTool === 'select' && this.selectedElement) {
					const handle = this.getResizeHandle(pos.x, pos.y);
					if (handle) {
						this.canvas.style.cursor = (handle === 'nw' || handle === 'se') ? 'nwse-resize' : 'nesw-resize';
					} else {
						this.canvas.style.cursor = 'default';
					}
				}

				if (this.resizeHandle && this.selectedElement) {
					if (!this.canEdit) return;
					this.didMutate = true;
					this.handleResize(pos.x, pos.y, !!e.shiftKey);
					this.render();
					return;
				}

				if (this.isMarquee && this.marqueeStart) {
					this.marqueeEnd = { x: pos.x, y: pos.y };
					this.render();
					return;
				}

				if (!this.isDrawing) return;

				if (this.currentTool === 'select' && this.getSelection().length) {
					if (!this.canEdit) return;
					if (this.dragLast) {
						// click vs drag threshold to prevent "jump" on selection
						if (!this.draggingSelection && this.dragStart) {
							const dist = Math.sqrt((pos.x - this.dragStart.x) ** 2 + (pos.y - this.dragStart.y) ** 2);
							if (dist < 3) return;
							this.draggingSelection = true;
							this.dragLast = { x: pos.x, y: pos.y };
							return;
						}
						const dx = pos.x - this.dragLast.x;
						const dy = pos.y - this.dragLast.y;
						if (dx !== 0 || dy !== 0) this.didMutate = true;
						this.moveSelectionBy(dx, dy);
						this.dragLast = { x: pos.x, y: pos.y };
						this.render();
					}
				} else if (this.currentTool === 'pen') {
					const current = this.elements[this.elements.length - 1];
					if (current && current.type === 'pen') {
						this.didMutate = true;
						current.points.push({ x: pos.x, y: pos.y });
						this.render();
					}
				} else if (['rectangle', 'ellipse', 'arrow'].includes(this.currentTool)) {
					const current = this.elements[this.elements.length - 1];
					if (current) {
						this.didMutate = true;
						current.x2 = pos.x;
						current.y2 = pos.y;
						this.render();
					}
				}
			},

			handleMouseUp(e) {
				if (this.resizeHandle) {
					this.normalizeElementBounds(this.selectedElement);
					this.saveState();
					this.markDirty();
					this.resizeHandle = null;
					this.textResizeStart = null;
					this.penResizeStart = null;
					this.boxResizeStart = null;
					// prevent accidental move after resize
					this.isDrawing = false;
					this.dragLast = null;
					return;
				}
				if (this.isPanning) {
					this.isPanning = false;
					this.panStartClient = null;
					this.panStartPan = null;
					this.canvas.style.cursor = this.spaceDown ? 'grab' : (this.currentTool === 'select' ? 'default' : 'crosshair');
					return;
				}

				if (this.isMarquee && this.marqueeStart && this.marqueeEnd) {
					const r = {
						minX: Math.min(this.marqueeStart.x, this.marqueeEnd.x),
						minY: Math.min(this.marqueeStart.y, this.marqueeEnd.y),
						maxX: Math.max(this.marqueeStart.x, this.marqueeEnd.x),
						maxY: Math.max(this.marqueeStart.y, this.marqueeEnd.y)
					};
					const picked = this.getElementsInRect(r, true);
					if (picked.length) {
						if (this.marqueeAdd) {
							const existing = this.getSelection();
							const merged = existing.slice();
							for (const el of picked) {
								if (!merged.some(x => x && x.id === el.id)) merged.push(el);
							}
							this.selectedElements = merged;
							this.selectedElement = picked[picked.length - 1] || merged[merged.length - 1] || null;
						} else {
							this.selectedElements = picked;
							this.selectedElement = picked[picked.length - 1] || null;
						}
					} else {
						// no hits keeps current selection
					}
					this.isMarquee = false;
					this.marqueeStart = null;
					this.marqueeEnd = null;
					this.marqueeAdd = false;
					this.isDrawing = false;
					this.dragLast = null;
					this.updateSelectedInfo();
					this.render();
					return;
				} else if (['rectangle', 'ellipse', 'arrow'].includes(this.currentTool)) {
					const pos = this.getMousePos(e);
					const current = this.elements[this.elements.length - 1];
					if (current) {
						current.x2 = pos.x;
						current.y2 = pos.y;
						if (current.x > current.x2) [current.x, current.x2] = [current.x2, current.x];
						if (current.y > current.y2) [current.y, current.y2] = [current.y2, current.y];
						this.saveState();
						this.markDirty();
					}
				} else if (this.currentTool === 'pen') {
					this.saveState();
					this.markDirty();
				}

				if (this.currentTool === 'select' && this.getSelection().length && this.didMutate) {
					this.saveState();
					this.markDirty();
				}

				this.isDrawing = false;
				this.dragLast = null;
				this.dragStart = null;
				this.draggingSelection = false;
				this.syncInfoPanelFromSelection();
			},

			normalizeElementBounds(el) {
				if (!el) return;
				if (typeof el.x2 === 'number' && typeof el.y2 === 'number') {
					if (el.x > el.x2) { const t = el.x; el.x = el.x2; el.x2 = t; }
					if (el.y > el.y2) { const t = el.y; el.y = el.y2; el.y2 = t; }
				}
			},

				getElementBounds(el) {
					if (!el) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
					if (el.type === 'pen' && el.points && el.points.length) {
					let minX = el.points[0].x, maxX = el.points[0].x;
					let minY = el.points[0].y, maxY = el.points[0].y;
					for (const p of el.points) {
						minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
						minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
					}
					return { minX, minY, maxX, maxY };
				}
				if (el.type === 'text') {
					const fontSize = (typeof el.fontSize === 'number') ? el.fontSize : 14;
					const isBold = (el.strokeWidth || 1) >= 3;
					const scaleX = (typeof el.textScaleX === 'number') ? el.textScaleX : 1;
					this.ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px sans-serif`;
					const metrics = this.ctx.measureText(el.text || '');
						const w = metrics.width * scaleX;
						const h = fontSize;
						return { minX: el.x, minY: el.y - h, maxX: el.x + w, maxY: el.y };
					}
					return {
						minX: Math.min(el.x, el.x2),
						minY: Math.min(el.y, el.y2),
					maxX: Math.max(el.x, el.x2),
					maxY: Math.max(el.y, el.y2)
				};
			},

			moveElementBy(el, dx, dy) {
				if (!el) return;
				if (el.type === 'pen' && el.points) {
					for (const p of el.points) { p.x += dx; p.y += dy; }
					return;
				}
				if (el.type === 'text') {
					el.x += dx;
					el.y += dy;
					return;
				}
				if (typeof el.x === 'number') el.x += dx;
				if (typeof el.y === 'number') el.y += dy;
				if (typeof el.x2 === 'number') el.x2 += dx;
				if (typeof el.y2 === 'number') el.y2 += dy;
			},

			moveSelectionBy(dx, dy) {
				const sel = this.getSelection();
				if (!sel.length) return;
				for (const el of sel) {
					this.moveElementBy(el, dx, dy);
				}
			},

			getElementsInRect(rect, fullyContained) {
				const out = [];
				for (const el of this.elements) {
					if (!el) continue;
					const b = this.getElementBounds(el);
					const inside = fullyContained
						? (b.minX >= rect.minX && b.maxX <= rect.maxX && b.minY >= rect.minY && b.maxY <= rect.maxY)
						: !(b.maxX < rect.minX || b.minX > rect.maxX || b.maxY < rect.minY || b.minY > rect.maxY);
					if (inside) out.push(el);
				}
				return out;
			},

			alignSelection(mode) {
				if (!this.assertCanEdit('align')) return;
				const sel = this.getSelection();
				if (sel.length < 2) return;
				const ref = sel[sel.length - 1];
				if (!ref) return;
				const rb = this.getElementBounds(ref);
				const refCx = (rb.minX + rb.maxX) / 2;
				const refCy = (rb.minY + rb.maxY) / 2;
				for (const el of sel) {
					if (!el || el.id === ref.id) continue;
					const b = this.getElementBounds(el);
					let dx = 0;
					let dy = 0;
					switch (mode) {
						case 'left': dx = rb.minX - b.minX; break;
						case 'hcenter': dx = refCx - (b.minX + b.maxX) / 2; break;
						case 'right': dx = rb.maxX - b.maxX; break;
						case 'top': dy = rb.minY - b.minY; break;
						case 'vcenter': dy = refCy - (b.minY + b.maxY) / 2; break;
						case 'bottom': dy = rb.maxY - b.maxY; break;
					}
					this.moveElementBy(el, dx, dy);
				}
				this.saveState();
				this.render();
				this.markDirty();
			},

			matchSelectionSize(kind) {
				if (!this.assertCanEdit('matchSize')) return;
				const sel = this.getSelection();
				if (sel.length < 2) return;
				const ref = sel[sel.length - 1];
				if (!ref) return;
				const rb = this.getElementBounds(ref);
				const refW = rb.maxX - rb.minX;
				const refH = rb.maxY - rb.minY;
				for (const el of sel) {
					if (!el || el.id === ref.id) continue;
					if (el.type === 'pen') continue;
					if (el.type === 'text') continue;
					const b = this.getElementBounds(el);
					if (kind === 'width') {
						const minX = b.minX;
						el.x = minX;
						el.x2 = minX + refW;
					}
					if (kind === 'height') {
						const minY = b.minY;
						el.y = minY;
						el.y2 = minY + refH;
					}
					this.normalizeElementBounds(el);
				}
				this.saveState();
				this.render();
				this.markDirty();
			},

			handleTouchStart(e) {
				e.preventDefault();
				const touch = e.touches[0];
				this.canvas.dispatchEvent(new MouseEvent('mousedown', { clientX: touch.clientX, clientY: touch.clientY }));
			},
			handleTouchMove(e) {
				e.preventDefault();
				const touch = e.touches[0];
				this.canvas.dispatchEvent(new MouseEvent('mousemove', { clientX: touch.clientX, clientY: touch.clientY }));
			},
			handleTouchEnd(e) {
				e.preventDefault();
				this.canvas.dispatchEvent(new MouseEvent('mouseup', {}));
			},

			handleWheel(e) {
				e.preventDefault();
				const container = $('#canvasContainer')[0];
				const rect = container ? container.getBoundingClientRect() : this.canvas.getBoundingClientRect();
				const sx = e.clientX - rect.left;
				const sy = e.clientY - rect.top;
				const wx = (sx - this.panX) / this.zoom;
				const wy = (sy - this.panY) / this.zoom;
				const delta = e.deltaY > 0 ? 0.9 : 1.1;
				const newZoom = Math.max(0.1, Math.min(5, this.zoom * delta));
				this.zoom = newZoom;
				this.panX = sx - wx * this.zoom;
				this.panY = sy - wy * this.zoom;
				this.updateTransform();
			},

			handleDoubleClick(e) {
				const pos = this.getMousePos(e);
				const element = this.hitTest(pos.x, pos.y);
				if (element && element.type === 'equipmentNode') {
					if (!this.canEdit) {
						this.showToast('조회만 가능합니다.');
						return;
					}
					this.openEquipmentPickerWithOptions({
						searchValue: element.salesCd || this.meta.salesCd || '',
						onSelected: (picked) => {
							const salesCd = String(picked && picked.salesCd || '').trim();
							if (!salesCd) return;
							element.salesCd = salesCd;
							element.eqpNm = String(picked.eqpNm || '').trim();
							this.setSalesContext({ salesCd: salesCd, eqpNm: element.eqpNm, ensureSummaryNode: false });
							this.saveState();
							this.markDirty();
							this.refreshSalesStatus();
						}
					});
					return;
				}
				if (element && element.type === 'text') {
					if (!this.canEdit) {
						this.showToast('조회만 가능합니다.');
						return;
					}
					const text = prompt('Edit text:', element.text);
					if (text !== null) {
						element.text = text;
						this.saveState();
						this.render();
						this.markDirty();
					}
				}
			},

			handleKeyDown(e) {
				if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) {
					if (!this.isTypingTargetFocused()) {
						e.preventDefault();
						this.copySelectionToClipboard();
						return;
					}
				}
				if ((e.ctrlKey && (e.key === 'z' || e.key === 'Z')) || (e.ctrlKey && (e.key === 'y' || e.key === 'Y'))) {
					if (!this.canEdit) {
						e.preventDefault();
						this.showToast('조회만 가능합니다.');
						return;
					}
				}
				if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) {
					// let paste event decide (image vs elements). arm internal fallback.
					if (!this.canEdit) {
						this.showToast('조회만 가능합니다.');
						this.internalPasteArmed = false;
						return;
					}
					this.internalPasteArmed = true;
					this.pasteArmedAt = Date.now();
					const armedAt = this.pasteArmedAt;
					setTimeout(() => this.tryPasteFromClipboardText(armedAt), 80);
				}
				if (e.code === 'Space') {
					if (this.isTypingTargetFocused()) return;
					e.preventDefault();
					this.spaceDown = true;
					this.canvas.style.cursor = 'grab';
					return;
				}
				if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
					e.preventDefault();
					this.undo();
				}
				if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
					e.preventDefault();
					this.redo();
				}
				if (e.key === 'Delete' || e.key === 'Backspace') {
					if (!this.isTypingTargetFocused()) {
						e.preventDefault();
						this.deleteSelected();
					}
				}
				if (e.ctrlKey && e.key === 's') {
					e.preventDefault();
					if (!this.canEdit) {
						this.showToast('조회만 가능합니다.');
						return;
					}
					this.saveToServer();
				}
				if (!e.ctrlKey) {
					if (this.isTypingTargetFocused()) return;
					switch (e.key.toLowerCase()) {
						case 'v': this.setTool('select'); break;
						case 'r': this.setTool('rectangle'); break;
						case 'e': this.setTool('ellipse'); break;
						case 'a': this.setTool('arrow'); break;
						case 'p': this.setTool('pen'); break;
						case 't': this.setTool('text'); break;
					}
				}
			},

			handleKeyUp(e) {
				if (e.code === 'Space') {
					this.spaceDown = false;
					this.canvas.style.cursor = (this.currentTool === 'select') ? 'default' : 'crosshair';
				}
			},

			handleWindowResize() {
				this.render();
			},

			setTool(tool) {
				if (tool !== 'select' && !this.canEdit) {
					this.showToast('조회만 가능합니다.');
					return;
				}
				this.currentTool = tool;
				$('.editor-toolbar-btn').each(function() {
					const $btn = $(this);
					$btn.toggleClass('active', $btn.data('tool') === tool);
				});
				this.canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';
			},

			createElement(type, x1, y1, x2, y2, extra = {}) {
				if (!this.canEdit) {
					this.showToast('조회만 가능합니다.');
					return null;
				}
				const element = {
					id: Date.now() + Math.random(),
					type,
					x: x1,
					y: y1,
					x2: x2,
					y2: y2,
					strokeColor: this.properties.strokeColor,
					fillColor: this.properties.fillColor,
					fillAlpha: this.properties.fillTransparent ? 0.55 : 1,
					strokeWidth: this.properties.strokeWidth,
					...extra
				};
				if (type === 'text') {
					element.fontSize = (extra && typeof extra.fontSize === 'number') ? extra.fontSize : (this.properties.fontSize || 14);
					element.textScaleX = (extra && typeof extra.textScaleX === 'number') ? extra.textScaleX : 1;
				}
				if (type === 'pen') {
					element.points = [{ x: x1, y: y1 }];
				}
				this.elements.push(element);
				this.setSingleSelection(element);
				this.syncPropertiesPanelFromSelection();
				this.render();
				this.markDirty();
				return element;
			},

				hitTest(x, y) {
					for (let i = this.elements.length - 1; i >= 0; i--) {
						const el = this.elements[i];
					if (el.type === 'pen') {
						for (const point of el.points) {
							const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
							if (dist < 10) return el;
						}
					} else if (el.type === 'text') {
						const fontSize = (typeof el.fontSize === 'number') ? el.fontSize : 14;
						const isBold = (el.strokeWidth || 1) >= 3;
						const scaleX = (typeof el.textScaleX === 'number') ? el.textScaleX : 1;
						this.ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px sans-serif`;
						const metrics = this.ctx.measureText(el.text);
							const width = metrics.width * scaleX;
							const height = fontSize;
							if (x >= el.x && x <= el.x + width && y >= el.y - height && y <= el.y) {
								return el;
							}
						} else if (el.type === 'arrow') {
						const x1 = el.x, y1 = el.y, x2 = el.x2, y2 = el.y2;
						const dx = x2 - x1;
						const dy = y2 - y1;
						const len2 = dx * dx + dy * dy;
						let t = 0;
						if (len2 > 0) t = ((x - x1) * dx + (y - y1) * dy) / len2;
						t = Math.max(0, Math.min(1, t));
						const px = x1 + t * dx;
						const py = y1 + t * dy;
						const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
						const tol = 6 + (el.strokeWidth || 1);
						if (dist <= tol) return el;
					} else {
						const minX = Math.min(el.x, el.x2);
						const maxX = Math.max(el.x, el.x2);
						const minY = Math.min(el.y, el.y2);
						const maxY = Math.max(el.y, el.y2);
						if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
							return el;
						}
					}
				}
				return null;
			},

			getResizeHandle(x, y) {
				if (!this.selectedElement) return null;
				const el = this.selectedElement;
				const b = this.getElementBounds(el);
				const minX = b.minX;
				const maxX = b.maxX;
				const minY = b.minY;
				const maxY = b.maxY;
				const hs = 7;
				if (Math.abs(x - minX) <= hs && Math.abs(y - minY) <= hs) return 'nw';
				if (Math.abs(x - maxX) <= hs && Math.abs(y - minY) <= hs) return 'ne';
				if (Math.abs(x - minX) <= hs && Math.abs(y - maxY) <= hs) return 'sw';
				if (Math.abs(x - maxX) <= hs && Math.abs(y - maxY) <= hs) return 'se';
				return null;
			},

				handleResize(x, y, keepAspect) {
					const el = this.selectedElement;
					if (!el) return;
				if (el.type === 'pen') {
					if (!this.penResizeStart || !Array.isArray(el.points) || !Array.isArray(this.penResizeStart.points)) return;
					const b0 = this.penResizeStart.bounds;
					const h = this.penResizeStart.handle || 'se';
					let ax = b0.minX, ay = b0.minY, cx0 = b0.maxX, cy0 = b0.maxY;
					switch (h) {
						case 'nw': ax = b0.maxX; ay = b0.maxY; cx0 = b0.minX; cy0 = b0.minY; break;
						case 'ne': ax = b0.minX; ay = b0.maxY; cx0 = b0.maxX; cy0 = b0.minY; break;
						case 'sw': ax = b0.maxX; ay = b0.minY; cx0 = b0.minX; cy0 = b0.maxY; break;
						case 'se': default: ax = b0.minX; ay = b0.minY; cx0 = b0.maxX; cy0 = b0.maxY; break;
					}
					const denomX = (cx0 - ax) || 1;
					const denomY = (cy0 - ay) || 1;
					let sx = (x - ax) / denomX;
					let sy = (y - ay) / denomY;
					sx = Math.max(0.05, Math.min(20, sx));
					sy = Math.max(0.05, Math.min(20, sy));
					if (keepAspect) {
						const s = Math.max(sx, sy);
						sx = s;
						sy = s;
					}
					for (let i = 0; i < el.points.length; i++) {
						const p0 = this.penResizeStart.points[i] || this.penResizeStart.points[this.penResizeStart.points.length - 1];
						el.points[i].x = ax + (p0.x - ax) * sx;
						el.points[i].y = ay + (p0.y - ay) * sy;
					}
					return;
				}
					if (el.type === 'text') {
						// Text resize model:
						// - Resize handle corner follows the mouse.
						// - Opposite corner stays anchored.
						// - Vertical delta controls fontSize, horizontal delta controls textScaleX.
						const h = (this.textResizeStart && this.textResizeStart.handle) ? this.textResizeStart.handle : 'se';
						const b0 = (this.textResizeStart && this.textResizeStart.bounds)
							? this.textResizeStart.bounds
							: this.getElementBounds(el);
						const baseFont = (this.textResizeStart && typeof this.textResizeStart.fontSize === 'number') ? this.textResizeStart.fontSize : ((typeof el.fontSize === 'number') ? el.fontSize : 14);
						const baseScaleX = (this.textResizeStart && typeof this.textResizeStart.scaleX === 'number') ? this.textResizeStart.scaleX : ((typeof el.textScaleX === 'number') ? el.textScaleX : 1);
						const b0w = Math.max(10, b0.maxX - b0.minX);
						const b0h = Math.max(8, b0.maxY - b0.minY);

						// Determine target bounds (minX/minY/maxX/maxY).
						let minX = b0.minX;
						let minY = b0.minY;
						let maxX = b0.maxX;
						let maxY = b0.maxY;
						switch (h) {
							case 'se':
								maxX = x;
								maxY = y;
								break;
							case 'sw':
								minX = x;
								maxY = y;
								break;
							case 'ne':
								maxX = x;
								minY = y;
								break;
							case 'nw':
								minX = x;
								minY = y;
								break;
						}

						// Clamp to avoid inversion.
						minX = Math.min(minX, maxX - 10);
						minY = Math.min(minY, maxY - 8);
						// Optional: keep aspect ratio (Shift) by applying uniform scale.
						if (keepAspect) {
							const targetW0 = Math.max(10, maxX - minX);
							const targetH0 = Math.max(8, maxY - minY);
							let s = Math.max(targetW0 / b0w, targetH0 / b0h);
							s = Math.max(0.2, Math.min(10, s));
							const nextW = b0w * s;
							const nextH = b0h * s;
							switch (h) {
								case 'se':
									minX = b0.minX;
									minY = b0.minY;
									maxX = minX + nextW;
									maxY = minY + nextH;
									break;
								case 'sw':
									maxX = b0.maxX;
									minY = b0.minY;
									minX = maxX - nextW;
									maxY = minY + nextH;
									break;
								case 'ne':
									minX = b0.minX;
									maxY = b0.maxY;
									maxX = minX + nextW;
									minY = maxY - nextH;
									break;
								case 'nw':
								default:
									maxX = b0.maxX;
									maxY = b0.maxY;
									minX = maxX - nextW;
									minY = maxY - nextH;
									break;
							}
						}

						const nextFont = Math.max(8, Math.min(300, keepAspect ? Math.round(baseFont * ((maxY - minY) / b0h)) : Math.round(maxY - minY)));
						el.fontSize = nextFont;
						this.properties.fontSize = nextFont;

						const isBold = (el.strokeWidth || 1) >= 3;
						this.ctx.font = `${isBold ? 'bold' : 'normal'} ${nextFont}px sans-serif`;
						const rawW = this.ctx.measureText(el.text || '').width || 1;

						let nextScaleX = baseScaleX;
						if (!keepAspect) {
							const targetW = Math.max(10, Math.min(5000, maxX - minX));
							nextScaleX = targetW / rawW;
							nextScaleX = Math.max(0.2, Math.min(10, nextScaleX));
						}
						el.textScaleX = nextScaleX;

						// Apply modeled bounds back to element.
						el.x = minX;
						el.y = maxY;
						return;
					}
				// Box-like elements (rect/ellipse/arrow/image/equipmentNode): optional keep aspect ratio with Shift.
				if (keepAspect) {
					const h = (this.boxResizeStart && this.boxResizeStart.handle) ? this.boxResizeStart.handle : (this.resizeHandle || 'se');
					const b0 = (this.boxResizeStart && this.boxResizeStart.bounds) ? this.boxResizeStart.bounds : this.getElementBounds(el);
					const w0 = Math.max(1, b0.maxX - b0.minX);
					const h0 = Math.max(1, b0.maxY - b0.minY);
					const ratio = w0 / h0;
					let ax = b0.minX, ay = b0.minY;
					switch (h) {
						case 'nw': ax = b0.maxX; ay = b0.maxY; break;
						case 'ne': ax = b0.minX; ay = b0.maxY; break;
						case 'sw': ax = b0.maxX; ay = b0.minY; break;
						case 'se': default: ax = b0.minX; ay = b0.minY; break;
					}
					const signX = (h === 'ne' || h === 'se') ? 1 : -1;
					const signY = (h === 'sw' || h === 'se') ? 1 : -1;
					let w = Math.abs(x - ax);
					let hh = Math.abs(y - ay);
					w = Math.max(10, w);
					hh = Math.max(10, hh);
					if ((w / hh) > ratio) {
						w = hh * ratio;
					} else {
						hh = w / ratio;
					}
					x = ax + signX * w;
					y = ay + signY * hh;
				}
				switch (this.resizeHandle) {
					case 'nw': el.x = x; el.y = y; break;
					case 'ne': el.x2 = x; el.y = y; break;
					case 'sw': el.x = x; el.y2 = y; break;
					case 'se': el.x2 = x; el.y2 = y; break;
				}

				// If user drags past the opposite side, flip the active handle so
				// resizing remains intuitive (no "inverted" feel).
				if (typeof el.x2 === 'number' && typeof el.y2 === 'number') {
					let h = this.resizeHandle;
					if (el.x > el.x2) {
						const t = el.x; el.x = el.x2; el.x2 = t;
						if (h === 'nw') h = 'ne';
						else if (h === 'ne') h = 'nw';
						else if (h === 'sw') h = 'se';
						else if (h === 'se') h = 'sw';
					}
					if (el.y > el.y2) {
						const t = el.y; el.y = el.y2; el.y2 = t;
						if (h === 'nw') h = 'sw';
						else if (h === 'sw') h = 'nw';
						else if (h === 'ne') h = 'se';
						else if (h === 'se') h = 'ne';
					}
					this.resizeHandle = h;
				}
			},

			deleteSelected() {
				if (!this.assertCanEdit('delete')) return;
				const sel = this.getSelection();
				if (!sel.length) return;
				const ids = {};
				for (const el of sel) ids[el.id] = true;
				this.elements = this.elements.filter(el => !ids[el.id]);
				this.clearSelection();
				this.saveState();
				this.render();
				this.syncInfoPanelFromSelection();
				this.markDirty();
			},

			updateSelectedProperties() {
				if (!this.assertCanEdit('properties')) return;
				const sel = this.getSelection();
				if (!sel.length) return;
				for (const el of sel) {
					if (!el) continue;
					el.strokeColor = this.properties.strokeColor;
					if (el.type !== 'pen' && el.type !== 'arrow' && el.type !== 'text') {
						el.fillColor = this.properties.fillColor;
						el.fillAlpha = this.properties.fillTransparent ? 0.55 : 1;
					}
					el.strokeWidth = this.properties.strokeWidth;
					// text: width(strokeWidth) maps to font bold only
				}
				this.render();
				this.markDirty();
			},

				render() {
					const ctx = this.ctx;
					ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
					this.drawGrid();
				this.elements.forEach(el => {
					ctx.strokeStyle = el.strokeColor;
					ctx.lineWidth = el.strokeWidth;
					ctx.lineCap = 'round';
					ctx.lineJoin = 'round';

				switch (el.type) {
							case 'rectangle':
							{
								const fill = (el.fillColor && el.fillColor !== 'transparent') ? el.fillColor : null;
								if (fill) {
									const a = (typeof el.fillAlpha === 'number') ? el.fillAlpha : 1;
									ctx.save();
									ctx.globalAlpha = a;
									ctx.globalCompositeOperation = (a < 1) ? 'multiply' : 'source-over';
									ctx.fillStyle = fill;
									ctx.beginPath();
									ctx.rect(el.x, el.y, el.x2 - el.x, el.y2 - el.y);
									ctx.fill();
									ctx.restore();
								}
								ctx.beginPath();
								ctx.rect(el.x, el.y, el.x2 - el.x, el.y2 - el.y);
								ctx.stroke();
								break;
							}
							case 'ellipse': {
								const fill = (el.fillColor && el.fillColor !== 'transparent') ? el.fillColor : null;
								const cx = (el.x + el.x2) / 2;
								const cy = (el.y + el.y2) / 2;
								const rx = Math.abs(el.x2 - el.x) / 2;
								const ry = Math.abs(el.y2 - el.y) / 2;
								if (fill) {
									const a = (typeof el.fillAlpha === 'number') ? el.fillAlpha : 1;
									ctx.save();
									ctx.globalAlpha = a;
									ctx.globalCompositeOperation = (a < 1) ? 'multiply' : 'source-over';
									ctx.fillStyle = fill;
									ctx.beginPath();
									ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
									ctx.fill();
									ctx.restore();
								}
								ctx.beginPath();
								ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
								ctx.stroke();
								break;
							}
						case 'arrow':
							this.drawArrow(ctx, el.x, el.y, el.x2, el.y2);
							break;
						case 'pen':
							if (el.points && el.points.length > 1) {
								ctx.beginPath();
								ctx.moveTo(el.points[0].x, el.points[0].y);
								for (let i = 1; i < el.points.length; i++) ctx.lineTo(el.points[i].x, el.points[i].y);
								ctx.stroke();
							}
							break;
						case 'text':
							{
								const fontSize = (typeof el.fontSize === 'number') ? el.fontSize : 14;
								const isBold = (el.strokeWidth || 1) >= 3;
								const scaleX = (typeof el.textScaleX === 'number') ? el.textScaleX : 1;
								ctx.save();
									ctx.translate(el.x, el.y);
									ctx.scale(scaleX, 1);
									ctx.font = `${isBold ? 'bold' : 'normal'} ${fontSize}px sans-serif`;
									ctx.fillStyle = el.strokeColor;
									ctx.fillText(el.text || '', 0, 0);
									ctx.restore();
									break;
								}
							case 'image':
								this.drawImageElement(ctx, el);
								break;
							case 'equipmentNode':
								this.drawEquipmentNode(ctx, el);
								break;
						}
				});

				if (this.currentTool === 'select') {
					const sel = this.getSelection();
					if (sel.length) {
						for (const el of sel) {
							if (!el) continue;
							ctx.strokeStyle = '#2563eb';
							ctx.lineWidth = 1;
							ctx.setLineDash([5, 5]);
							if (el.type === 'text') {
								const b = this.getElementBounds(el);
								const width = b.maxX - b.minX;
								const height = b.maxY - b.minY;
								ctx.strokeRect(b.minX - 5, b.minY - 5, width + 10, height + 10);
								if (this.selectedElement && el.id === this.selectedElement.id) {
									ctx.setLineDash([]);
									this.drawResizeHandles(ctx, b.minX, b.minY, b.maxX, b.maxY);
								}
							} else {
								const b = this.getElementBounds(el);
								ctx.strokeRect(b.minX - 5, b.minY - 5, b.maxX - b.minX + 10, b.maxY - b.minY + 10);
								// draw resize handles only for primary
								if (this.selectedElement && el.id === this.selectedElement.id) {
									ctx.setLineDash([]);
									this.drawResizeHandles(ctx, b.minX, b.minY, b.maxX, b.maxY);
								}
							}
							ctx.setLineDash([]);
						}
					}
				}

				if (this.isMarquee && this.marqueeStart && this.marqueeEnd) {
					const x1 = this.marqueeStart.x;
					const y1 = this.marqueeStart.y;
					const x2 = this.marqueeEnd.x;
					const y2 = this.marqueeEnd.y;
					ctx.save();
					ctx.strokeStyle = 'rgba(37, 99, 235, 0.85)';
					ctx.lineWidth = 1;
					ctx.setLineDash([6, 4]);
					ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
					ctx.setLineDash([]);
					ctx.restore();
				}
			},

			drawImageElement(ctx, el) {
			if (!el || !el.src) return;
			const b = this.getElementBounds(el);
			let img = this.imageCache[el.id];
			if (!img) {
				img = new Image();
				img.onload = () => {
					this.imageCache[el.id] = img;
					this.render();
				};
				img.src = el.src;
				this.imageCache[el.id] = img;
			}
			if (!img || !img.complete || !img.naturalWidth) {
				// not ready yet
				return;
			}
			ctx.save();
			ctx.globalAlpha = 1;
			ctx.globalCompositeOperation = 'source-over';
			ctx.drawImage(img, b.minX, b.minY, b.maxX - b.minX, b.maxY - b.minY);
			ctx.strokeStyle = el.strokeColor || '#000000';
			ctx.lineWidth = el.strokeWidth || 1;
			ctx.strokeRect(b.minX, b.minY, b.maxX - b.minX, b.maxY - b.minY);
			ctx.restore();
		},

			drawResizeHandles(ctx, minX, minY, maxX, maxY) {
			const size = 8;
			ctx.save();
			ctx.fillStyle = '#ffffff';
			ctx.strokeStyle = '#2563eb';
			ctx.lineWidth = 1;
			const pts = [
				{ x: minX, y: minY },
				{ x: maxX, y: minY },
				{ x: minX, y: maxY },
				{ x: maxX, y: maxY }
			];
			for (const p of pts) {
				ctx.beginPath();
				ctx.rect(p.x - size / 2, p.y - size / 2, size, size);
				ctx.fill();
				ctx.stroke();
			}
			ctx.restore();
		},

			drawEquipmentNode(ctx, el) {
			const x1 = Math.min(el.x, el.x2);
			const y1 = Math.min(el.y, el.y2);
			const x2 = Math.max(el.x, el.x2);
			const y2 = Math.max(el.y, el.y2);
			const w = Math.max(40, x2 - x1);
			const h = Math.max(30, y2 - y1);
			const r = 10;
			ctx.save();

			// blended fill (when colored) so overlaps show mixed colors
			const fill = (el.fillColor && el.fillColor !== 'transparent') ? el.fillColor : null;
			if (fill) {
				ctx.save();
				const a = (typeof el.fillAlpha === 'number') ? el.fillAlpha : 0.55;
				ctx.globalAlpha = a;
				ctx.globalCompositeOperation = (a < 1) ? 'multiply' : 'source-over';
				ctx.fillStyle = fill;
				this.roundRect(ctx, x1, y1, w, h, r);
				ctx.fill();
				ctx.restore();
			} else {
				ctx.fillStyle = 'rgba(255,255,255,0.65)';
				this.roundRect(ctx, x1, y1, w, h, r);
				ctx.fill();
			}

			ctx.strokeStyle = el.strokeColor || '#2563eb';
			ctx.lineWidth = 2;
			this.roundRect(ctx, x1, y1, w, h, r);
			ctx.stroke();

			// header bar
			ctx.fillStyle = 'rgba(37, 99, 235, 0.10)';
			this.roundRect(ctx, x1, y1, w, 26, r);
			ctx.fill();

			ctx.fillStyle = '#0f172a';
			ctx.font = 'bold 12px sans-serif';
			const title = (el.summary ? '[요약] ' : '') + (el.eqpNm ? `설비: ${el.eqpNm}` : '설비');
			ctx.fillText(this.ellipsisText(ctx, title, w - 140), x1 + 8, y1 + 18);

			// badges (status + issue count)
			const status = String(el.scheduleStatus || '').trim();
			const issueCnt = (typeof el.issueCount === 'number') ? el.issueCount : parseInt(el.issueCount || 0, 10) || 0;
			this.drawEquipmentBadges(ctx, x1, y1, w, status, issueCnt);

			ctx.font = '11px sans-serif';
			ctx.fillStyle = '#334155';
			ctx.fillText(this.ellipsisText(ctx, `SalesCd: ${el.salesCd || '-'}`, w - 16), x1 + 8, y1 + 44);
			ctx.fillText(this.ellipsisText(ctx, `상태: ${el.scheduleStatus || '-'}`, w - 16), x1 + 8, y1 + 62);
			ctx.fillText(this.ellipsisText(ctx, `문제: ${typeof el.issueCount === 'number' ? el.issueCount : '-'}`, w - 16), x1 + 8, y1 + 80);
			if (el.lastSyncAt) {
				ctx.fillStyle = '#64748b';
				ctx.font = '10px sans-serif';
				ctx.fillText(this.ellipsisText(ctx, `Last: ${el.lastSyncAt}`, w - 16), x1 + 8, y1 + h - 10);
			}
			ctx.restore();
		},

			drawEquipmentBadges(ctx, x1, y1, w, scheduleStatus, issueCount) {
			ctx.save();
			ctx.font = 'bold 10px sans-serif';
			const map = {
				'완료': '#64748b',
				'지연': '#ef4444',
				'확정': '#22c55e',
				'진행': '#3b82f6',
				'없음': '#94a3b8'
			};
			const st = scheduleStatus || '없음';
			const stColor = map[st] || '#94a3b8';
			const padX = 6;
			const padY = 3;
			const h = 16;
			const stW = Math.min(80, Math.ceil(ctx.measureText(st).width) + padX * 2);
			let x = x1 + w - 8;
			// issue badge
			const issueText = `문제 ${issueCount}`;
			const issueW = Math.min(80, Math.ceil(ctx.measureText(issueText).width) + padX * 2);
			const issueBg = issueCount > 0 ? '#f97316' : '#475569';
			x -= issueW;
			this.roundRect(ctx, x, y1 + 5, issueW, h, 7);
			ctx.fillStyle = issueBg;
			ctx.fill();
			ctx.fillStyle = '#ffffff';
			ctx.fillText(issueText, x + padX, y1 + 5 + 11);
			// status badge
			x -= (stW + 6);
			this.roundRect(ctx, x, y1 + 5, stW, h, 7);
			ctx.fillStyle = stColor;
			ctx.fill();
			ctx.fillStyle = '#ffffff';
			ctx.fillText(st, x + padX, y1 + 5 + 11);
			ctx.restore();
		},

			roundRect(ctx, x, y, w, h, r) {
			const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			ctx.arcTo(x + w, y, x + w, y + h, radius);
			ctx.arcTo(x + w, y + h, x, y + h, radius);
			ctx.arcTo(x, y + h, x, y, radius);
			ctx.arcTo(x, y, x + w, y, radius);
			ctx.closePath();
		},

			ellipsisText(ctx, text, maxWidth) {
			const s = String(text || '');
			if (ctx.measureText(s).width <= maxWidth) return s;
			let out = s;
			while (out.length > 0 && ctx.measureText(out + '...').width > maxWidth) {
				out = out.slice(0, -1);
			}
			return (out.length ? out : '') + '...';
		},

			drawGrid() {
				const ctx = this.ctx;
				ctx.strokeStyle = '#f1f5f9';
				ctx.lineWidth = 1;
				const gridSize = 20;
				for (let x = 0; x < this.canvas.width; x += gridSize) {
					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x, this.canvas.height);
					ctx.stroke();
				}
				for (let y = 0; y < this.canvas.height; y += gridSize) {
					ctx.beginPath();
					ctx.moveTo(0, y);
					ctx.lineTo(this.canvas.width, y);
					ctx.stroke();
				}
			},

			drawArrow(ctx, x1, y1, x2, y2) {
				const headLength = 15;
				const angle = Math.atan2(y2 - y1, x2 - x1);
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
				ctx.moveTo(x2, y2);
				ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
				ctx.stroke();
			},

			saveState() {
				this.history = this.history.slice(0, this.historyIndex + 1);
				this.history.push(JSON.stringify(this.elements));
				this.historyIndex = this.history.length - 1;
				if (this.history.length > 50) {
					this.history.shift();
					this.historyIndex--;
				}
				this.saveToLocalStorage();
			},

			undo() {
				if (this.historyIndex > 0) {
					this.historyIndex--;
					this.elements = JSON.parse(this.history[this.historyIndex]);
					this.clearSelection();
					this.render();
					this.syncInfoPanelFromSelection();
					this.markDirty();
					this.showToast('Undo');
				}
			},

			redo() {
				if (this.historyIndex < this.history.length - 1) {
					this.historyIndex++;
					this.elements = JSON.parse(this.history[this.historyIndex]);
					this.clearSelection();
					this.render();
					this.syncInfoPanelFromSelection();
					this.markDirty();
					this.showToast('Redo');
				}
			},

			clearCanvas() {
				if (!this.assertCanEdit('clear')) return;
				if (confirm('Clear all elements?')) {
					this.elements = [];
					this.clearSelection();
					this.saveState();
					this.render();
					this.syncInfoPanelFromSelection();
					this.markDirty();
				}
			},

			saveToLocalStorage() {
				try {
					localStorage.setItem('wb1001m01_drawing', JSON.stringify({
						elements: this.elements,
						properties: this.properties,
						meta: this.meta,
						autoRefresh: this.autoRefresh
					}));
				} catch (e) {
					console.warn('Could not save to localStorage:', e);
				}
			},

			loadFromLocalStorage() {
				try {
					const saved = localStorage.getItem('wb1001m01_drawing');
					if (saved) {
						const data = JSON.parse(saved);
						this.elements = data.elements || [];
						this.properties = data.properties || this.properties;
						this.meta = data.meta ? { ...this.meta, ...data.meta } : this.meta;
						this.autoRefresh = !!data.autoRefresh;
						this.history = [JSON.stringify(this.elements)];
						this.historyIndex = 0;
					}
				} catch (e) {
					console.warn('Could not load from localStorage:', e);
				}
			},

			exportJSON() {
				const data = {
					version: '1.0',
					timestamp: new Date().toISOString(),
					elements: this.elements,
					properties: this.properties,
					meta: this.meta
				};
				const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = $('<a></a>')[0];
				if (a) {
					a.href = url;
					a.download = `drawing_${Date.now()}.json`;
					a.click();
				}
				URL.revokeObjectURL(url);
				this.showToast('Exported');
			},

			importJSON(event) {
				if (!this.canEdit) {
					this.showToast('조회만 가능합니다.');
					if (event && event.target) event.target.value = '';
					return;
				}
				const file = event.target.files[0];
				if (!file) return;
				const reader = new FileReader();
				reader.onload = (e) => {
					try {
						const data = JSON.parse(e.target.result);
						if (data.elements) {
							this.elements = data.elements;
							if (data.properties) {
								this.properties = { ...this.properties, ...data.properties };
							}
							if (data.meta) {
								this.meta = { ...this.meta, ...data.meta };
								this.syncInfoPanelFromSelection();
							}
							this.saveState();
							this.render();
							this.syncInfoPanelFromSelection();
							this.showToast('Imported');
							this.markDirty();
						}
					} catch (err) {
						this.showToast('Invalid JSON');
					}
				};
				reader.readAsText(file);
				event.target.value = '';
			},

			/*
			REAL BACKEND CALL (BACKEND IMPLEMENTATION PENDING)
			- Replace the stub fetch() calls in saveToServer()/loadFromServer() with
			  WB endpoints described in the design comment at file bottom.
			
			Save endpoint
			- POST /user/wb/wb06/saveDrawing
			
			Suggested request payload
			{
			  coCd: jwt.coCd,
			  userId: jwt.userid,
			  drawId: 'wb1001m01_default',
			  drawNm: 'Default Drawing',
			  salesCd: app.meta.salesCd,
			  eqpNm: app.meta.eqpNm,
			  drawJson: JSON.stringify({ version:'1.0', timestamp:..., elements:..., properties:..., meta:..., autoRefresh:... }),
			  metaJson: JSON.stringify(app.meta)
			}
			
			Implementation sketch (keep as reference; do NOT run until backend exists)
			
			async saveToServer() {
			  if (!this.canEdit) return;
			  const payload = {
			    coCd: this.getCoCd(),
			    userId: this.getJwtUserId(),
			    drawId: 'wb1001m01_default',
			    drawNm: 'Default Drawing',
			    salesCd: this.meta.salesCd,
			    eqpNm: this.meta.eqpNm,
			    drawJson: JSON.stringify({
			      version: '1.0',
			      timestamp: new Date().toISOString(),
			      elements: this.elements,
			      properties: this.properties,
			      meta: this.meta,
			      autoRefresh: this.autoRefresh
			    }),
			    metaJson: JSON.stringify(this.meta)
			  };
			  const res = await this.postAjaxPromise('/user/wb/wb06/saveDrawing', payload);
			  // jsonView typical response: { result: 'OK' }
			  this.showToast('Saved');
			}
			
			Load endpoint
			- POST /user/wb/wb06/selectDrawing
			
			async loadFromServer() {
			  const payload = { coCd: this.getCoCd(), drawId: 'wb1001m01_default' };
			  const res = await this.postAjaxPromise('/user/wb/wb06/selectDrawing', payload);
			  // expected: res.result contains DB row
			  // drawJson may be a JSON string (CLOB). Parse and apply:
			  const row = res && res.result ? res.result : null;
			  const doc = row && row.drawJson ? JSON.parse(row.drawJson) : null;
			  if (doc && doc.elements) {
			    this.elements = doc.elements || [];
			    this.properties = doc.properties || this.properties;
			    this.meta = doc.meta ? { ...this.meta, ...doc.meta } : this.meta;
			    this.autoRefresh = !!doc.autoRefresh;
			    // IMPORTANT: preload pasted images to imageCache
			    for (const el of this.elements) {
			      if (el && el.type === 'image' && el.src) {
			        const img = new Image();
			        img.onload = () => this.render();
			        img.src = el.src;
			        this.imageCache[el.id] = img;
			      }
			    }
			    this.applyPropertiesInputs();
			    this.syncInfoPanelFromSelection();
			    this.saveState();
			    this.render();
			    this.syncInfoPanelFromSelection();
			    this.showToast('Loaded');
			  }
			}
			*/

			async saveToServer() {
				const data = {
					id: 'wb1001m01_default',
					name: 'Default Drawing',
					elements: this.elements,
					properties: this.properties,
					updatedAt: new Date().toISOString()
				};
				try {
					const response = await fetch('/api/drawings', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(data)
					});
					this.showToast(response.ok ? 'Saved' : 'Save failed');
					if (response.ok) this.markSaved();
				} catch (err) {
					console.log('Server save stub:', data);
					this.showToast('Saved (stub)');
				}
			},

			async loadFromServer() {
				try {
					const response = await fetch('/api/drawings/wb1001m01_default');
					if (response.ok) {
						const data = await response.json();
						this.elements = data.elements || [];
						this.properties = data.properties || this.properties;
						this.saveState();
						this.render();
						this.syncInfoPanelFromSelection();
						this.markSaved();
						this.showToast('Loaded');
					} else {
						this.showToast('Load failed');
					}
				} catch (err) {
					this.showToast('Server unavailable');
				}
			},

			zoomIn() {
				this.zoom = Math.min(5, this.zoom * 1.2);
				this.updateTransform();
			},
			zoomOut() {
				this.zoom = Math.max(0.1, this.zoom / 1.2);
				this.updateTransform();
			},
			resetView() {
				this.zoom = 1;
				const container = $('#canvasContainer')[0];
				if (container) {
					this.panX = (container.clientWidth - this.canvas.width) / 2;
					this.panY = (container.clientHeight - this.canvas.height) / 2;
				}
				this.updateTransform();
			},

			showToast(message) {
				const $toast = $('#toast');
				$toast.text(message);
				$toast.addClass('show');
				setTimeout(() => $toast.removeClass('show'), 2000);
			}
		};
	</script>
</body>
</html>

<!--
================================================================================
WB1001M01 BACKEND SAVE DESIGN (TABLE/API/MAPPER) - Draft
================================================================================

Goal
- Persist the editor's final exported JSON (elements/properties/meta/autoRefresh)
  to DB via Spring Boot + MyBatis (Tibero).
- Store per company (CO_CD) and optionally per salesCd/eqpNm.

-------------------------------------------------------------------------------
1) Table Design (Tibero)
-------------------------------------------------------------------------------

Table: TB_WB1001M01_DRAW

Key points
- DRAW_JSON is CLOB (full document).
- Optional: THUMBNAIL_BASE64 as CLOB (small preview), or omit.
- Soft delete with DEL_YN.
- Use UPD_DTTM for ordering.

DDL (Tibero)

CREATE TABLE TB_WB1001M01_DRAW (
    CO_CD           VARCHAR2(10)    NOT NULL,
    DRAW_ID         VARCHAR2(40)    NOT NULL,
    DRAW_NM         VARCHAR2(200)   NULL,

    SALES_CD        VARCHAR2(20)    NULL,
    EQP_NM          VARCHAR2(200)   NULL,

    DRAW_JSON       CLOB            NOT NULL,
    META_JSON       CLOB            NULL,
    THUMBNAIL_BASE64 CLOB           NULL,

    DEL_YN          CHAR(1)         DEFAULT 'N' NOT NULL,
    CRT_USR_ID      VARCHAR2(50)    NOT NULL,
    CRT_DTTM        DATE            DEFAULT SYSDATE NOT NULL,
    UPD_USR_ID      VARCHAR2(50)    NOT NULL,
    UPD_DTTM        DATE            DEFAULT SYSDATE NOT NULL,

    CONSTRAINT PK_TB_WB1001M01_DRAW PRIMARY KEY (CO_CD, DRAW_ID)
);

CREATE INDEX IX_WB1001M01_DRAW_01 ON TB_WB1001M01_DRAW (CO_CD, DEL_YN, UPD_DTTM);
CREATE INDEX IX_WB1001M01_DRAW_02 ON TB_WB1001M01_DRAW (CO_CD, SALES_CD, DEL_YN);

-------------------------------------------------------------------------------
2) API Contract (suggested)
-------------------------------------------------------------------------------

Base path: /user/wb/wb06

POST /user/wb/wb06/saveDrawing
Request JSON
{
  "coCd": "GUN",
  "drawId": "wb1001m01_default",        // required
  "drawNm": "Default Drawing",
  "salesCd": "...",
  "eqpNm": "...",
  "drawJson": "{...}",                 // JSON string (store into CLOB)
  "metaJson": "{...}",                 // optional JSON string
  "thumbnailBase64": "data:image/png;base64,..." // optional
}

POST /user/wb/wb06/selectDrawing
Request JSON
{
  "coCd": "GUN",
  "drawId": "wb1001m01_default"
}
Response
{ "result": { ...row... } }

POST /user/wb/wb06/selectDrawingList
Request JSON
{
  "coCd": "GUN",
  "salesCd": "..." ,
  "pageNo": "1",
  "recordCnt": "20"
}

POST /user/wb/wb06/deleteDrawing
Request JSON
{
  "coCd": "GUN",
  "drawId": "wb1001m01_default",
  "userId": "..."
}

-------------------------------------------------------------------------------
3) Spring Controller/Service/Mapper Skeleton
-------------------------------------------------------------------------------

Package recommendation (matches repo style)
- Controller: src/main/java/com/dksys/biz/user/wb/wb06/WB06DrawCtr.java
- Service:    src/main/java/com/dksys/biz/user/wb/wb06/service/WB06DrawSvc.java
- Impl:       src/main/java/com/dksys/biz/user/wb/wb06/service/impl/WB06DrawSvcImpl.java
- Mapper:     src/main/java/com/dksys/biz/user/wb/wb06/mapper/WB06DrawMapper.java
- XML:        src/main/resources/mapper/tibero/user/wb/wb06_draw.xml

Controller (WB06DrawCtr.java)

@Controller
@RequestMapping("/user/wb/wb06")
public class WB06DrawCtr {
    @Autowired WB06DrawSvc wb06DrawSvc;

    @PostMapping("/saveDrawing")
    public String saveDrawing(@RequestBody Map<String, Object> paramMap, ModelMap model) {
        wb06DrawSvc.saveDrawing(paramMap);
        model.addAttribute("result", "OK");
        return "jsonView";
    }

    @PostMapping("/selectDrawing")
    public String selectDrawing(@RequestBody Map<String, Object> paramMap, ModelMap model) {
        model.addAttribute("result", wb06DrawSvc.selectDrawing(paramMap));
        return "jsonView";
    }

    @PostMapping("/selectDrawingList")
    public String selectDrawingList(@RequestBody Map<String, Object> paramMap, ModelMap model) {
        int totalCnt = wb06DrawSvc.selectDrawingListCount(paramMap);
        // NOTE: PaginationInfo currently expects Map<String,String> in this repo in some places.
        // Use the existing pattern used in other controllers (convert pageNo/recordCnt).
        model.addAttribute("result", wb06DrawSvc.selectDrawingList(paramMap));
        model.addAttribute("totalCnt", totalCnt);
        return "jsonView";
    }

    @PostMapping("/deleteDrawing")
    public String deleteDrawing(@RequestBody Map<String, Object> paramMap, ModelMap model) {
        wb06DrawSvc.deleteDrawing(paramMap);
        model.addAttribute("result", "OK");
        return "jsonView";
    }
}

Service (WB06DrawSvc.java)

public interface WB06DrawSvc {
    void saveDrawing(Map paramMap);
    Map<String, String> selectDrawing(Map paramMap);
    int selectDrawingListCount(Map paramMap);
    List<Map<String, String>> selectDrawingList(Map paramMap);
    void deleteDrawing(Map paramMap);
}

Impl (WB06DrawSvcImpl.java)

@Service
public class WB06DrawSvcImpl implements WB06DrawSvc {
    @Autowired WB06DrawMapper wb06DrawMapper;

    @Override
    public void saveDrawing(Map paramMap) {
        int exists = wb06DrawMapper.selectDrawingExists(paramMap);
        if (exists > 0) wb06DrawMapper.updateDrawing(paramMap);
        else wb06DrawMapper.insertDrawing(paramMap);
    }

	@Override
	public Map<String, String> selectDrawing(Map paramMap) {
		// 1) load drawing row (DRAW_JSON as CLOB -> String)
		Map<String, String> row = wb06DrawMapper.selectDrawing(paramMap);
		// 2) enrich equipmentNode issueCount from TB_WB24M02 where ISS_ST != 'ISSTS03'
		//    - parse DRAW_JSON, collect unique salesCd for elements where type == 'equipmentNode'
		//    - query counts by salesCd
		//    - update each equipmentNode.issueCount = cnt
		//    NOTE: backend implementation pending; see mapper SQL below.
		return row;
	}

    @Override
    public int selectDrawingListCount(Map paramMap) {
        return wb06DrawMapper.selectDrawingListCount(paramMap);
    }

	@Override
	public List<Map<String, String>> selectDrawingList(Map paramMap) {
		// Option A (recommended): list does NOT return DRAW_JSON by default.
		// - Use TB_WB1001M01_DRAW.SALES_CD as 대표값 and optionally return issueCnt per row.
		// Option B: if paramMap.includeJson == 'Y', include DRAW_JSON and enrich like selectDrawing()
		// - parse each DRAW_JSON elements, collect all equipmentNode.salesCd across the page,
		// - query TB_WB24M02 open issue counts where ISS_ST != 'ISSTS03',
		// - patch equipmentNode.issueCount.
		return wb06DrawMapper.selectDrawingList(paramMap);
	}

    @Override
    public void deleteDrawing(Map paramMap) {
        wb06DrawMapper.deleteDrawing(paramMap);
    }
}

Mapper (WB06DrawMapper.java)

@Mapper
public interface WB06DrawMapper {
    int selectDrawingExists(Map paramMap);
    int insertDrawing(Map paramMap);
    int updateDrawing(Map paramMap);
    Map<String, String> selectDrawing(Map paramMap);
    int selectDrawingListCount(Map paramMap);
    List<Map<String, String>> selectDrawingList(Map paramMap);
    List<Map<String, String>> selectOpenIssueCountBySalesCds(Map paramMap);
    int deleteDrawing(Map paramMap);
}

-------------------------------------------------------------------------------
4) MyBatis XML (wb06_draw.xml) - Tibero
-------------------------------------------------------------------------------

NOTE: Tibero CLOB handling (practical)
- App layer (JDBC/MyBatis): you can treat CLOB as String for save/load.
  Tibero tbJDBC supports reading/writing CLOB via Clob locator (ResultSet.getClob / PreparedStatement.setClob)
  and character streams. See TmaxTibero JDBC Dev Guide: "LOB Data Processing".
- SQL layer: do NOT assume CLOB behaves like VARCHAR2 for predicates.
  For filtering/searching inside CLOB, use DBMS_LOB.INSTR or DBMS_LOB.SUBSTR (often limited to ~4000 chars in SQL).
  Recommendation: keep JSON in CLOB as opaque blob; store searchable fields (salesCd/eqpNm/etc) as separate columns.
- List query should avoid selecting large CLOB columns; fetch CLOB only for single-record load.

<mapper namespace="com.dksys.biz.user.wb.wb06.mapper.WB06DrawMapper">

  <select id="selectDrawingExists" parameterType="Map" resultType="int">
    SELECT COUNT(1)
      FROM TB_WB1001M01_DRAW
     WHERE CO_CD = #{coCd}
       AND DRAW_ID = #{drawId}
       AND DEL_YN = 'N'
  </select>

  <insert id="insertDrawing" parameterType="Map">
    INSERT INTO TB_WB1001M01_DRAW (
        CO_CD, DRAW_ID, DRAW_NM,
        SALES_CD, EQP_NM,
        DRAW_JSON, META_JSON, THUMBNAIL_BASE64,
        DEL_YN, CRT_USR_ID, CRT_DTTM, UPD_USR_ID, UPD_DTTM
    ) VALUES (
        #{coCd}, #{drawId}, #{drawNm},
        #{salesCd}, #{eqpNm},
        #{drawJson, jdbcType=CLOB}, #{metaJson, jdbcType=CLOB}, #{thumbnailBase64, jdbcType=CLOB},
        'N', #{userId}, SYSDATE, #{userId}, SYSDATE
    )
  </insert>

  <update id="updateDrawing" parameterType="Map">
    UPDATE TB_WB1001M01_DRAW
       SET DRAW_NM = #{drawNm},
           SALES_CD = #{salesCd},
           EQP_NM = #{eqpNm},
           DRAW_JSON = #{drawJson, jdbcType=CLOB},
           META_JSON = #{metaJson, jdbcType=CLOB},
           THUMBNAIL_BASE64 = #{thumbnailBase64, jdbcType=CLOB},
           UPD_USR_ID = #{userId},
           UPD_DTTM = SYSDATE
     WHERE CO_CD = #{coCd}
       AND DRAW_ID = #{drawId}
       AND DEL_YN = 'N'
  </update>

  <select id="selectDrawing" parameterType="Map" resultType="camelMap">
    SELECT CO_CD,
           DRAW_ID,
           DRAW_NM,
           SALES_CD,
           EQP_NM,
           DRAW_JSON,
           META_JSON,
           THUMBNAIL_BASE64,
           CRT_USR_ID,
           TO_CHAR(CRT_DTTM, 'YYYY-MM-DD HH24:MI:SS') AS crtDttm,
           UPD_USR_ID,
           TO_CHAR(UPD_DTTM, 'YYYY-MM-DD HH24:MI:SS') AS updDttm
      FROM TB_WB1001M01_DRAW
     WHERE CO_CD = #{coCd}
       AND DRAW_ID = #{drawId}
       AND DEL_YN = 'N'
  </select>

  <select id="selectDrawingListCount" parameterType="Map" resultType="int">
    SELECT COUNT(1)
      FROM TB_WB1001M01_DRAW
     WHERE CO_CD = #{coCd}
       AND DEL_YN = 'N'
       <if test="salesCd != null and !salesCd.equals('')">
         AND SALES_CD = #{salesCd}
       </if>
  </select>

  <select id="selectDrawingList" parameterType="Map" resultType="camelMap">
    SELECT CO_CD,
           DRAW_ID,
           DRAW_NM,
           SALES_CD,
           EQP_NM,
           <if test="includeJson != null and includeJson.equals('Y')">
             DRAW_JSON,
           </if>
           TO_CHAR(UPD_DTTM, 'YYYY-MM-DD HH24:MI:SS') AS updDttm,
           UPD_USR_ID
      FROM TB_WB1001M01_DRAW
     WHERE CO_CD = #{coCd}
       AND DEL_YN = 'N'
       <if test="salesCd != null and !salesCd.equals('')">
         AND SALES_CD = #{salesCd}
       </if>
     ORDER BY UPD_DTTM DESC
  </select>


    EquipmentNode issue count enrichment
    - TB_WB24M02: count open issues per SALES_CD
    - Open = ISS_ST != 'ISSTS03' (요청 반영)

  <select id="selectOpenIssueCountBySalesCds" parameterType="Map" resultType="camelMap">
    SELECT ISU.SALES_CD AS salesCd
         , COUNT(*)     AS cnt
      FROM TB_WB24M02 ISU
     WHERE ISU.CO_CD = #{coCd}
       AND ISU.ISS_ST != 'ISSTS03'
       <if test="salesCds != null and salesCds.size() > 0">
         AND ISU.SALES_CD IN
         <foreach collection="salesCds" item="cd" open="(" separator="," close=")">
           #{cd}
         </foreach>
       </if>
     GROUP BY ISU.SALES_CD
  </select>

  <update id="deleteDrawing" parameterType="Map">
    UPDATE TB_WB1001M01_DRAW
       SET DEL_YN = 'Y',
           UPD_USR_ID = #{userId},
           UPD_DTTM = SYSDATE
     WHERE CO_CD = #{coCd}
       AND DRAW_ID = #{drawId}
       AND DEL_YN = 'N'
  </update>

</mapper>

-------------------------------------------------------------------------------
5) Frontend Wiring Note
-------------------------------------------------------------------------------

This page already has JS methods `saveToServer()` / `loadFromServer()`.
To wire into above endpoints, map:
- saveToServer(): POST /user/wb/wb06/saveDrawing
- loadFromServer(): POST /user/wb/wb06/selectDrawing

Suggested payload
- coCd: jwt.coCd
- userId: jwt.userid
- drawId: 'wb1001m01_default' (or UI-provided)
- salesCd/eqpNm: app.meta
- drawJson/metaJson: JSON.stringify(exportObject)

================================================================================
END
================================================================================
-->
